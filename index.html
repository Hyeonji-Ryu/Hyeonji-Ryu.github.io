<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://hyeonji-ryu.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="AI &amp; ML">
<meta property="og:url" content="https://hyeonji-ryu.github.io/index.html">
<meta property="og:site_name" content="AI &amp; ML">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="Hyeonji Ryu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hyeonji-ryu.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>AI & ML</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AI & ML</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Julia, Python, R</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>홈</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>카테고리</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>아카이브</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Hyeonji-Ryu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://hyeonji-ryu.github.io/2020/03/03/chapter-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hyeonji Ryu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AI & ML">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/03/chapter-5/" class="post-title-link" itemprop="url">4. 조건부와 재귀</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-03 13:24:12 / Updated at: 22:11:51" itemprop="dateCreated datePublished" datetime="2020-03-03T13:24:12+09:00">2020-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Think-Julia/" itemprop="url" rel="index">
                    <span itemprop="name">Think Julia</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap05" target="_blank" rel="noopener">Conditionals and Recursion</a>를 한글로 요약 정리한 글입니다.</p>
<!-- excerpt -->

<h2 id="조건부와-재귀"><a href="#조건부와-재귀" class="headerlink" title="조건부와 재귀"></a>조건부와 재귀</h2><p>이번 장의 가장 핵심적인 주제는 <code>if</code>문이지만, 그 전에 간단한 연산자 두 개를 먼저 소개하려고 한다.</p>
<h3 id="버림-나눗셈-floor-division-과-나머지-Modulus"><a href="#버림-나눗셈-floor-division-과-나머지-Modulus" class="headerlink" title="버림 나눗셈(floor division)과 나머지(Modulus)"></a>버림 나눗셈(floor division)과 나머지(Modulus)</h3><p>버림 나눗셈(floor division)이란 두 수를 나눈 후 나머지를 버리는 계산을 의미하며, 연산자 기호는 <code>÷</code>이다.<br>예를 들어, 105분동안 상영하는 영화가 있다고 해보자. 우리는 영화가 대략 몇 시간이 걸리는지 알기 위해 60분으로 나누지만, 일반적인 나눗셈은 소수점까지 모두 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; minutes = <span class="number">105</span></span><br><span class="line"><span class="number">105</span></span><br><span class="line">julia&gt; minutes / <span class="number">60</span></span><br><span class="line"><span class="number">1.75</span></span><br></pre></td></tr></table></figure>

<p>그러나 우리는 일반적으로 시간을 소수점으로 표현하지는 않는다. 버림 나눗셈은 나머지인 소수점을 모두 버리고 정수만 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; hours = minutes ÷ <span class="number">60</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>위의 1시간을 제외하고 남은 시간이 몇 분인지 알고 싶다면 105분에서 1시간을 빼면 된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; remainder = minutes - hours * <span class="number">60</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>

<p>이외에도 나눗셈에서 나머지만 반환해주는 나머지 연산자 <code>%</code>를 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; remainder = minutes % <span class="number">60</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>

<p><strong>Tip</strong><br>나머지 연산자는 생각보다 유용하다, 예로 한 숫자를 다른 숫자로 나눌 수 있는지 파악해야 할 때, 두 수의 나머지 연산 결과가 0인지로 확인할 수 있다.<br>또한 정수에서 가장 오른쪽의 숫자만 추출할 때도 사용가능하다. 이 경우, <code>%10</code>을 사용하면 된다.</p>
<h3 id="불-표현식"><a href="#불-표현식" class="headerlink" title="불 표현식"></a>불 표현식</h3><p>불 표현식(Boolean Expressions)은 <code>true</code> 또는 <code>false</code>를 나타내는 식이며, 연산자는 <code>==</code>이다. 불 표현식의 예시를 보면, 연산자는 <code>==</code>를 기분으로 양 옆의 두 피연산자들을 비교한 후 같으면 <code>true</code>를, 다르면 <code>false</code>를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="number">5</span> == <span class="number">5</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">julia&gt; <span class="number">5</span> == <span class="number">6</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><code>true</code>와 <code>false</code>은 문자열이 아니라 <code>Bool</code>이라는 데이터 타입에 속한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; typeof(<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">Bool</span></span><br><span class="line">julia&gt; typeof(<span class="literal">false</span>)</span><br><span class="line"><span class="built_in">Bool</span></span><br></pre></td></tr></table></figure>

<p>사용된 <code>==</code> 연산자는 관계 연산자들 중 하나이다. 다른 관계 연산자들은 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x != y               <span class="comment"># x is not equal to y</span></span><br><span class="line">x ≠ y                <span class="comment"># (\ne TAB)</span></span><br><span class="line">x &gt; y                <span class="comment"># x is greater than y</span></span><br><span class="line">x &lt; y                <span class="comment"># x is less than y</span></span><br><span class="line">x &gt;= y               <span class="comment"># x is greater than or equal to y</span></span><br><span class="line">x ≥ y                <span class="comment"># (\ge TAB)</span></span><br><span class="line">x &lt;= y               <span class="comment"># x is less than or equal to y</span></span><br><span class="line">x ≤ y                <span class="comment"># (\le TAB)</span></span><br></pre></td></tr></table></figure>

<p><strong>주의</strong><br>줄리아 기호는 일반적인 수학 기호와는 조금 다르다. 줄리아에서 <code>=</code>는 대입 연산자이고, <code>==</code>는 관계 연산자이다. 두 기호는 비슷해 보이지만 완전히 다르다.</p>
<h3 id="논리-연산자"><a href="#논리-연산자" class="headerlink" title="논리 연산자"></a>논리 연산자</h3><p>논리 연산자는 and 연산자인 <code>&amp;&amp;</code>, or 연산자인 <code>||</code>, not 연산자인 <code>!</code> 총 세 가지가 있다.  논리 연산자들의 사용방법은 아래의 코드에서 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &gt; <span class="number">0</span> &amp;&amp; x &lt; <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>위의 코드는 <code>&amp;&amp;</code> 연산자이다. 위의 예시는 x가 0보다 크고 10보다 작으면 이 문장은 <code>true</code>를 반환하는 것을 의미한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n % <span class="number">2</span> == <span class="number">0</span> || n % <span class="number">3</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>다음 코드는 <code>||</code> 연산자이다. 위의 코드를 해석한다면, n값이 2나 3으로 나누었을 때 나머지가 0인 숫자면 해당 코드는 <code>true</code>를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(x &gt; y)</span><br></pre></td></tr></table></figure>

<p>마지막으로 <code>!</code> 연산자이며, 이는 불 표현식을 무효화한다. 따라서 위의 예시를 본다면 x가 y보다 작거나 같은 경우에 <code>true</code> 를 반환하고, x가 y보다 크다면 <code>false</code>를 반환한다.</p>
<h3 id="조건부-Conditional-실행"><a href="#조건부-Conditional-실행" class="headerlink" title="조건부(Conditional) 실행"></a>조건부(Conditional) 실행</h3><p>유용한 프로그램을 작성하려면 우리는 프로그램의 상태를 확인하고 그에 따라 알맞게 변경하는 기능이 필요하다. 조건문은 우리에게 이런 기능을 제공한다. 가장 간단한 형식은 <code>If</code>문이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span></span><br><span class="line">    println(<span class="string">"x is positive"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>If</code>문 뒤에 쓰여 있는 불 표현식을 조건이라고 한다. 해당 조건이 참이라면 밑의 명령문이 작동되지만, 조건이 참이 아니라면 아무 일도 일어나지 않는다.</p>
<p><code>If</code>문이 함수 정의와 동일한 구조를 가진 경우를 복합 구문(compound statements)이라고 한다. 여기서 함수 정의를 다시 상기해본다면 헤더로 시작하여 본문을 작성 한후 마지막에 키워드 <code>end</code> 끝나는 구조이다.</p>
<p>복합 구문에 들어가는 명령문의 수는 제한이 없으며, 명령문이 아예 없는 본문도 작성이 가능하다 (하지만 본문이 없으면 어떤 변화도 일어나지는 않는다).</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span></span><br><span class="line">    <span class="comment"># TODO: need to handle negative values!</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="대체-Alternative-실행"><a href="#대체-Alternative-실행" class="headerlink" title="대체(Alternative) 실행"></a>대체(Alternative) 실행</h3><p><code>If</code>문의 두 번째 형식은 대체 실행(Alternative Execution)이다. 이 구조에서는 두 가지의 조건이 있으며, 각각의 조건에 따라 실행되는 코드가 결정된다. 해당 예시는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">    println(<span class="string">"x is even"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    println(<span class="string">"x is odd"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>위의 코드는 숫자인 x가 짝수인지 홀수인지 구분하여 알려주는 프로그램이다. x를 2로 나누어 나머지가 0이 된다면 짝수이고, 0이 아니라면 홀수이다. 이 간단한 원리를 사용하여 조건에 충족하면 <code>true</code>가 되어 첫 번째 본문을 실행하고, <code>false</code>라면 두 번째 본문을 실행한다.</p>
<h3 id="연결-조건부-Chained-Conditionals"><a href="#연결-조건부-Chained-Conditionals" class="headerlink" title="연결 조건부(Chained Conditionals)"></a>연결 조건부(Chained Conditionals)</h3><p>때로는 두 개 이상의 조건이 주어지는 경우도 있다. 이럴 때에는 조건을 연결하는 연결조건부 구조가 사용된다. 해당 구조의 코드는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; y</span><br><span class="line">    println(<span class="string">"x is less than y"</span>)</span><br><span class="line"><span class="keyword">elseif</span> x &gt; y</span><br><span class="line">    println(<span class="string">"x is greater than y"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    println(<span class="string">"x and y are equal"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>위에 사용한 <code>elseif</code>문의 수는 제한이 없다. 또한 <code>else</code>문을 쓰려면 반드시 끝에 입력해야 하지만, 필요없다면 작성하지 않아도 된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> choice == <span class="string">"a"</span></span><br><span class="line">    draw_a()</span><br><span class="line"><span class="keyword">elseif</span> choice == <span class="string">"b"</span></span><br><span class="line">    draw_b()</span><br><span class="line"><span class="keyword">elseif</span> choice == <span class="string">"c"</span></span><br><span class="line">    draw_c()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>각 조건들은 순서대로 작동한다. 예를 들어 첫 번째 조건이 거짓이면 다음 조건으로 넘어가며, 만약 참인 조건을 찾으면 해당 본문이 실행되며 <code>If</code>문은 종료된다.<br>그렇기 때문에 만약 2개 이상의 조건이 참인 경우에도 더 위에 작성되어 있는 조건만 실행된다.</p>
<h3 id="중첩-조건부-Nested-Conditionals"><a href="#중첩-조건부-Nested-Conditionals" class="headerlink" title="중첩 조건부(Nested Conditionals)"></a>중첩 조건부(Nested Conditionals)</h3><p>하나의 <code>If</code>문에도 다른 <code>If</code>문이 중첩될 수 있다. 이전 예제를 가져와서 확인하면 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == y</span><br><span class="line">    println(<span class="string">"x and y are equal"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; y</span><br><span class="line">        println(<span class="string">"x is less than y"</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        println(<span class="string">"x is greater than y"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>겉에 있는 <code>If</code>문은 간단한 구조를 가지고 있다. 하지만 <code>else</code>문에 또 다시 <code>If</code>문을 작성함으로서 두 개의 조건문을 중첩시킨 것을 확인할 수 있다.</p>
<p>이럽 중첩 조건부는 들여쓰기를 통해서 연결지점들을 구분해두지만, 코드를 빠르게 이해하기는 어렵다. 그렇기에 코드를 작성할 때 중첩 조건부는 피하는 것이 좋다.</p>
<p>논리 연산자를 이용하여 중첩 조건부를 단순화할 수 있다. 아래 예시를 보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt; x</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">10</span></span><br><span class="line">        println(<span class="string">"x is a positive single-digit number."</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>위의 조건문은 중첩 조건부로서 두 개의 조건을 모두 충족해야만 실행된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt; x &amp;&amp; x &lt; <span class="number">10</span></span><br><span class="line">    println(<span class="string">"x is a positive single-digit number."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>하지만 <code>&amp;&amp;</code> 연산자를 사용하면 단일 조건부로 해결할 수 있다.<br>또한 줄리아는 아래와 같이 더 간결한 구문도 제공한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt; x &lt; <span class="number">10</span></span><br><span class="line">    println(<span class="string">"x is a positive single-digit number."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="재귀-Recursion"><a href="#재귀-Recursion" class="headerlink" title="재귀(Recursion)"></a>재귀(Recursion)</h3><p>한 함수가 다른 함수를 호출하는 것은 충분히 가능한 일이다. 그렇다면 함수가 자기 자신을 호출하는 것도 가능할까?<br>위 질문에 대한 답은 가능하다는 것이다. 어떻게 가능한지 아래의 예시로 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> countdown(n)</span><br><span class="line">    <span class="keyword">if</span> n ≤ <span class="number">0</span></span><br><span class="line">        println(<span class="string">"Blastoff!"</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print(n, <span class="string">" "</span>)</span><br><span class="line">        countdown(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>위의 함수는 <code>n</code>이 0이거나 음수인 경우 “Blastoff!”를 출력하며, 아닌 경우에는 <code>n</code>을 출역한 후 <code>n-1</code>을 인수로 갖는 <code>countdown()</code>를 호출한다.</p>
<p>위의 함수는 어떤 결과를 보여줄까?</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; countdown(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> Blastoff!</span><br></pre></td></tr></table></figure>

<p>위의 예시를 보면, 조건부 원리를 이해할 수 있다.</p>
<ul>
<li>3은 0보다 크기 때문에 <code>else</code>문으로 넘어가서 3을 출력한 후 자기 자신을 호출하여 2를 인수로 제공한다.</li>
<li>2 또한 0보다 크기 때문에 <code>else</code>문으로 넘어가고 위와 같은 과정을 반복한다.</li>
<li>1 또한 0보다 크기 때문에 위와 같다.</li>
<li>0은 <code>If</code>문 조건에 해당하기 때문에 해당 본문이 실행된다. (“Blastoff!”를 호출한다.)</li>
</ul>
<p>스스로를 호출하는 함수를 실행하는 과정을 재귀(Recursion)라고 한다.<br>다른 예로 문자열을 <code>n</code>번 출력하는 함수를 만들어보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> printn(s, n)</span><br><span class="line">    <span class="keyword">if</span> n ≤ <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    println(s)</span><br><span class="line">    printn(s, n-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>해당 예시는 <code>n</code>이 <code>n &lt;= 0</code>이면 함수를 종료한다. 함수가 종료되면 그 결과가 사용자에게 반환되며, 나머지 명령문들은 실행되지 않는다.<br><code>n</code>이 양수라면 나머지 명령문들이 실행되며, 해당 명령문의 작동방식은 <code>countdown()</code>과 유사하다.</p>
<h3 id="무한-재귀-infinite-recursion"><a href="#무한-재귀-infinite-recursion" class="headerlink" title="무한 재귀(infinite recursion)"></a>무한 재귀(infinite recursion)</h3><p>도착점이 제공되지 않은 재귀는 함수 호출을 계속하며 종료되지 않는다. 이런 현상을 무한 재귀(infinite recursion)라고 한다. 실제로 무한 재귀는 일반적으로 잘 사용되지 않는다. 아래 코드는 무한재귀의 간단한 예시이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> recurse()</span><br><span class="line">    recurse()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>대부분의 프로그래밍 환경에서 무한 재귀가 있는 프로그램이 영원히 실행되지는 않는다. 줄리아는 최대 재귀 수준에 도달하면 오류 메시지를 보낸 후 실행을 중단한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; recurse()</span><br><span class="line">ERROR: <span class="built_in">StackOverflowError</span>:</span><br><span class="line">Stacktrace:</span><br><span class="line"> [<span class="number">1</span>] recurse() at ./REPL[<span class="number">1</span>]:<span class="number">2</span> (repeats <span class="number">80000</span> times)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>위의 오류를 보면 해당 함수는 80000번을 반복했다. 대부분 무한 재귀는 함수를 잘못 사용해서 발생하기 때문에 해당 오류를 만난다면 함수의 사용법을 확인해야 한다.</p>
<h3 id="키보드-입력-Keyboard-Input"><a href="#키보드-입력-Keyboard-Input" class="headerlink" title="키보드 입력(Keyboard Input)"></a>키보드 입력(Keyboard Input)</h3><p>줄리아는 <code>readline()</code>이라는 내장 함수를 제공하여 프로그램을 중지하고 사용자가 무언가를 입력할 때까지 기다린다. 사용자가 내용을 입력하고 <code>RETURN</code> 또는 <code>ENTER</code>를 누르면 해당 변수에 값이 적용된다. 이후 <code>readline()</code>은 사용자가 문자열로 입력한 내용을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; text = readline()</span><br><span class="line">What are you waiting <span class="keyword">for</span>? <span class="comment"># 내용 입력 후 `RETURN` 또는 `ENTER`를 누르기</span></span><br><span class="line"><span class="string">"What are you waiting for?"</span></span><br></pre></td></tr></table></figure>

<p>세미 콜론(;)을 사용하면 같은 줄에 여러 문장을 넣을 수 있다. REPL에서는 마지막 명령문의 결괏값만을 호출한다.<br>또한 사용자가 정수를 입력할 것으로 예상되면, 반환 값을 정수로 변환하여 가져올 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; println(<span class="string">"What...is the airspeed velocity of an unladen swallow?"</span>); speed = readline()</span><br><span class="line">What...is the airspeed velocity of an unladen swallow?</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="string">"42"</span></span><br><span class="line">julia&gt; parse(<span class="built_in">Int64</span>, speed)</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>하지만 만약 사용자가 입력한 데이터 타입과 다른 형태로 변환하면, 오류가 발생한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; println(<span class="string">"What...is the airspeed velocity of an unladen swallow? "</span>); speed = readline()</span><br><span class="line">What...is the airspeed velocity of an unladen swallow?</span><br><span class="line">What <span class="keyword">do</span> you mean, an African or a European swallow?</span><br><span class="line"><span class="string">"What do you mean, an African or a European swallow?"</span></span><br><span class="line">julia&gt; parse(<span class="built_in">Int64</span>, speed)</span><br><span class="line">ERROR: <span class="built_in">ArgumentError</span>: invalid base <span class="number">10</span> digit <span class="string">'W'</span> <span class="keyword">in</span> <span class="string">"What do you mean, an African or a European swallow?"</span></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>나중에 위와 같은 종류의 오류들을 처리하는 방법을 살펴볼 것이다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>문법이나 런타임 오류가 발생하면, 오류 메시지는 과도하게 많은 정보들을 제공한다. 따라서 오류 메시지를 정확하게 파악하는 것도 중요하다. 가장 유용한 부분들은 다음과 같다.</p>
<ul>
<li>오류의 종류는 무엇인가?</li>
<li>어디서 발생한 오류인가?</li>
</ul>
<p>문법 오류는 찾기 쉽지만 몇 가지 문제가 있다. 일반적으로 오류 메시지들은 문제가 발견된 위치를 제공하지만, 실제 오류가 일어난 위치와 다를 수 있다.</p>
<p>런타임 오류도 마찬가지이다. 다음 예시로 확인해보자.<br>다음 예시는 신호 대 잡음비를 데시벨로 계산하는 공식을 구현한 것이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">signal_power = <span class="number">9</span></span><br><span class="line">noise_power = <span class="number">10</span></span><br><span class="line">ratio = signal_power ÷ noise_power</span><br><span class="line">decibels = <span class="number">10</span> * log10(ratio)</span><br><span class="line">print(decibels)</span><br></pre></td></tr></table></figure>

<p>위의 코드를 수행하면 결과는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="literal">Inf</span></span><br></pre></td></tr></table></figure>

<p>해당 결과는 예상했던 것과 다르다.</p>
<p>오류를 찾기 위해서, 변수인 <code>ratio</code>의 값을 확인해보는 것이 좋을 것이다. 확인해보니 <code>ratio</code>는 0으로 밝혀졌다. 문제는 3번째 줄에서 버림 나눗셈을 하여 나머지들을 제거해버리는 데서 온 것으로 확인되었다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://hyeonji-ryu.github.io/2020/03/02/chapter-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hyeonji Ryu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AI & ML">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/chapter-4/" class="post-title-link" itemprop="url">3. 인터페이스 디자인</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-03-02 22:11:41" itemprop="dateCreated datePublished" datetime="2020-03-02T22:11:41+09:00">2020-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-03 22:11:51" itemprop="dateModified" datetime="2020-03-03T22:11:51+09:00">2020-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Think-Julia/" itemprop="url" rel="index">
                    <span itemprop="name">Think Julia</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap04" target="_blank" rel="noopener">Case Study: Interface Design</a>를 한글로 요약 정리한 글입니다.</p>
<!-- excerpt -->

<h2 id="사례-연구-인터페이스-디자인"><a href="#사례-연구-인터페이스-디자인" class="headerlink" title="사례 연구: 인터페이스 디자인"></a>사례 연구: 인터페이스 디자인</h2><p>이번 장에서는 함수들을 설계하는 과정들을 볼 수 있는 사례 연구를 살펴볼 것이다.</p>
<p>이를 진행하기 위해서는 그림을 생성하는 거북이 그래픽(turtle graphics)을 사용해야 한다. 거북이 그래픽은 표준 라이브러리에 포함되어 있지 않기 때문에 해당 모듈을 줄리아 설정에 추가해야 한다.</p>
<h3 id="거북이"><a href="#거북이" class="headerlink" title="거북이"></a>거북이</h3><p>모듈(module)은 관련 함수들을 모아 놓은 파일이다. 줄리아는 표준 라이브러리에서 몇 가지 모듈을 제공하고 있으며, 다른 패키지들도 모듈로 추가할 수 있다.</p>
<p>패키지를 추가하는 방법은 다음과 같다. 먼저 REPL 창에 엔터 키를 눌러서 시작한다. 이후 REPL에서 <code>]</code>를 입력하면 패키지 설정 모드로 변환된다. 거북이 그래픽을 사용하기 위해서는 아래의 코드를 입력한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(v1<span class="number">.0</span>) pkg&gt; add https://github.com/BenLauwens/ThinkJulia.jl</span><br></pre></td></tr></table></figure>

<p>모듈에 포함되어 있는 함수를 사용하려면, 먼저 <code>using</code>이라는 명령어를 사용하여 모듈을 가져와야 한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> ThinkJulia</span><br><span class="line">julia&gt; 🐢 = Turtle()</span><br><span class="line">Luxor.Turtle(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="literal">true</span>, <span class="number">0.0</span>, (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>))</span><br></pre></td></tr></table></figure>

<p><code>ThinkJulia</code> 모듈은 <code>Luxor.Turtle</code>이라는 객체를 생성하는 <code>Turtle</code> 함수를 제공하며, 해당 객체는 <code>🐢</code>라는 변수에 할당된다.</p>
<p>거북이를 만든 후에는 함수를 호출하여 거북이를 이동할 수 있다. 예를 들어 거북이를 앞으로 움직이려면 다음과 같은 코드를 입력하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>@svg</code> 키워드는 SVG그림을 그리는 매크로를 실행한다. 매크로는 줄리아의 고급 기능 중 하나이다.<br><code>forword</code>의 인수는 🐢와 픽셀 단위의 거리이므로 실제 크기는 각자 디스플레이에 따라 결정된다.<br>거북이와 함께 호출할 수 있는 다른 함수로는 거북이를 회전시키는 <code>turn</code>이 있으며, 해당 함수의 첫 번째 인수는 🐢가, 두 번째 인수에는 회전 각도가 들어간다.</p>
<p>또한 각각의 거북이들은 내리거나 올릴 수 있는 펜을 잡고 있다. 펜을 내린다면 거북이가 움직였던 경로들을 남기며, 반대로 펜을 올리면 경로들을 남기지 않는다. 즉, 펜이 내려간 상태에서 거북이가 앞으로 움직이면 거북이가 앞으로 간 경로가 남겨지는 것이다. 이런 함수를 <code>penup</code>, <code>pendown</code>이라고 부른다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line">    turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="간단한-반복"><a href="#간단한-반복" class="headerlink" title="간단한 반복"></a>간단한 반복</h3><p>다음과 같이 한번 써보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line">    turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line">    turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line">    turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>위의 예시는 사각형을 그리는 코드이다.<br>우리는 <code>for</code>문을 사용하여 위의 예시와 같은 똑같은 작업을 더 간단하게 수행할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">          println(<span class="string">"Hello!"</span>)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">Hello!</span><br><span class="line">Hello!</span><br><span class="line">Hello!</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure>

<p>해당 예시는 <code>for</code>문의 가장 간단한 예시이다. <code>for</code>문에 대한 자세한 내용은 다른 장에서 더 살펴볼 예정이다.<br>지금부터 위의 간단한 <code>for</code>문을 이용해서 사각형을 그려보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">        forward(🐢, <span class="number">100</span>)</span><br><span class="line">        turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>for</code>문의 문법은 함수를 정의하는 것과 비슷하다. 헤더(header)와 본문이 있으며, 마지막에는 키워드 <code>end</code>를 사용한다.</p>
<p>또한 <code>for</code>문은 본문을 헤더에 지정된 수만큼 반복하므로 루프(loop)라고도 부른다. 위의 예시의 경우는 (<code>i in 1:4</code>처럼 4번이라고 지정했음) 4번 반복 실행한다.</p>
<h3 id="예시-풀어보기"><a href="#예시-풀어보기" class="headerlink" title="예시 풀어보기"></a>예시 풀어보기</h3><p>이번 장에서는 거북이를 사용하여 여러 가지 연습을 해볼 것이다.</p>
<ul>
<li>거북이를 <code>t</code> 매개 변수로 사용하는 <code>square()</code>를 작성하시오.</li>
</ul>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> square()</span><br><span class="line">       t=Turtle()</span><br><span class="line">       <span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">               forward(t,<span class="number">100</span>)</span><br><span class="line">               turn(t,-<span class="number">90</span>)</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>t</code>를 <code>sqaure()</code>의 인수로 전달하는 함수를 작성한 후, 매크로를 실행하시오.</li>
</ul>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> square(t)</span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">               forward(t,<span class="number">100</span>)</span><br><span class="line">               turn(t,-<span class="number">90</span>)</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">🐢=Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">           square(🐢)</span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>변의 길이가 <code>len</code>이 되도록 본문을 수정한 후, <code>len</code>이라는 다른 매개 변수를 <code>square()</code>에 추가하시오.</li>
</ul>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> square(t, len)</span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">               forward(t, len)</span><br><span class="line">               turn(t, -<span class="number">90</span>)</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">           square(🐢,<span class="number">200</span>)</span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>square()</code>의 복사본을 만들고 이름을 <code>polygon()</code>으로 변경하시오. 그 후 새로운 매개변수 <code>n</code>을 추가하고 본문을 수정하시오. (n의 외부각도는 360/n 으로 수정하면 된다.)</li>
</ul>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> polygon(t,len,n)</span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">               forward(t,len)</span><br><span class="line">               turn(t,-<span class="number">360</span>/n)</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">           polygon(🐢,<span class="number">100</span>,<span class="number">5</span>)</span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>t</code> 와 반지름 <code>r</code>를 매개 변수로 하는 <code>circle()</code>를 작성하시오.</li>
</ul>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> circle(t, r)</span><br><span class="line">    circum = <span class="number">2</span>* <span class="literal">π</span> *r</span><br><span class="line">    n=<span class="number">20</span></span><br><span class="line">    len=circum/n</span><br><span class="line">    polygon(t, len, n)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">           circle(🐢,<span class="number">50</span>)</span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h3><p>첫 번째 연습에서는 사각형 그리기 코드를 함수 정의에 넣은 후 거북이를 매개 변수를 전달하여 함수를 호출하도록 요청한다. 해당 코드는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> square(t)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">        forward(t, <span class="number">100</span>)</span><br><span class="line">        turn(t, -<span class="number">90</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    square(🐢)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>square()</code> 가장 안쪽에 있는 명령문  <code>forward</code>와 <code>turn</code>은 <code>for</code>문에 속해있다는 것을 나타내기 위해 두 번 들여쓰기로 작성한다.</p>
<p>위의 예시와 같이 코드 조각들을 함수로 감싸는 것을 캡슐화(Encapsulation)라고 한다. 캡슐화의 이점 중 하나는 코드에 이름을 첨부하여 프로그램 과정을 명확하게 정리할 수 있다는 것이다. 또한 한 번 캡슐화를 진행한 이후에는 코드를 재사용할 때 함수 하나만 호출하면 되기 때문에 간편하다.</p>
<h3 id="일반화"><a href="#일반화" class="headerlink" title="일반화"></a>일반화</h3><p>다음으로는 <code>len</code>이라는 매개 변수를 추가하는 것이다. 코드는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> square(t, len)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">        forward(t, len)</span><br><span class="line">        turn(t, -<span class="number">90</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    square(🐢, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>함수에 매개 변수를 추가하는 것은 해당 함수를 보다 다양한 환경에서 일반적으로 사용할 수 있게 만들어주기 때문에 일반화(Generalization)라고 한다. 매개 변수 <code>len</code>을 추가함으로써 <code>square()</code>는 이제 사각형의 길이를 조정할 수 있게 되었다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> polygon(t, n, len)</span><br><span class="line">    angle = <span class="number">360</span> / n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        forward(t, len)</span><br><span class="line">        turn(t, -angle)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    polygon(🐢, <span class="number">7</span>, <span class="number">70</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>위의 코드는 칠각형을 그리는 코드 예시이다.</p>
<h3 id="인터페이스-디자인"><a href="#인터페이스-디자인" class="headerlink" title="인터페이스 디자인"></a>인터페이스 디자인</h3><p>다음 단계는 반지름 <code>r</code>를 매개 변수로 하는 <code>circle()</code>를 작성하는 것이다.  다음은 다각형 함수인 <code>polygon()</code>을 사용하여 20면 다각형을 그리는 코드이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> circle(t, r)</span><br><span class="line">    circumference = <span class="number">2</span> * <span class="literal">π</span> * r</span><br><span class="line">    n = <span class="number">20</span></span><br><span class="line">    len = circumference / n</span><br><span class="line">    polygon(t, n, len)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    circle(t, r)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>첫 번째 줄은 반지름이 <code>r</code>인 원의 둘레를 계산한다. <code>n</code>은 각도가 변형되는 수이며, <code>len</code>은 선분의 길이이기 때문에 둘레를 <code>n</code>으로 나눠 정의한다. 그러면 20면 다각형을 그릴 수 있다.</p>
<p>위의 해결안은 문제는 <code>n</code>이 상수라는 것이다. 즉, 매우 큰 원의 경우 선분이 너무 길고 작은 원의 경우는 작은 선분을 그리는데 시간이 낭비된다. 따라서 <code>n</code>을 매개 변수로 사용하여 일반화한다면, 이 문제를 해결할 수 있다.<br>하지만 이런 일반화는 사용자에게 더 많은 제어권을 부여하지만 인터페이스는 덜 깨끗해진다.</p>
<p>함수의 인터페이스(interface)는 어떻게 사용되는지에 대한 요약이다. 구체적으로 인터페이스는 매개 변수는 무엇인지, 반환 값은 무엇인지 등의 내용들을 포함하고 있다고 보면 된다.<br>보통 사용자가 불필요한 세부 사항을 처리할 필요 없이 작업이 수행되는 함수들을 인터페이스가 깨끗하다고 말한다.</p>
<p>예를 들어, 위의 예제에서 <code>r</code>은 그릴 원을 지정하므로 인터페이스에 속한다. 하지만 <code>n</code>은 원을 그리는 방법에 대한 세부 사항과 관련이 있기 때문에 인터페이스에 속하지 않는다.<br>따라서 인터페이스를 어지럽히지 말고 둘레에 따라 적절한 <code>n</code>값을 선택하는게 좋다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> circle(t, r)</span><br><span class="line">    circumference = <span class="number">2</span> * <span class="literal">π</span> * r</span><br><span class="line">    n = trunc(circumference / <span class="number">3</span>) + <span class="number">3</span></span><br><span class="line">    len = circumference / n</span><br><span class="line">    polygon(t, n, len)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    circle(t, r)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>위의 코드는 <code>len</code>의 값이 3에 가까울 수 있도록 <code>n</code>을 자동 설정한 코드다. <code>len</code>의 값은 호선의 길이로서 3정도가 원 크기와 상관없이 가장 적합하기에 3으로 결정하였다.</p>
<p><code>n</code>값에 3을 더해준 것은 다각형의 선분이 적어도 3 이상이라는 것을 보장한다.</p>
<h3 id="리팩토링"><a href="#리팩토링" class="headerlink" title="리팩토링"></a>리팩토링</h3><p>이전 장에서 <code>circle()</code>를 설계할 때는 <code>polygon()</code>를 재사용할 수 있었다. 하지만 <code>arc()</code>는 지금까지 만들었던 함수들을 이용할 수 없다.<br>한가지 대안으로는 다각형의 사본을 만들고, 호선으로 변환하는 것이다. 결과는 다음 코드와 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> arc(t, r, angle)</span><br><span class="line">    arc_len = <span class="number">2</span> * <span class="literal">π</span> * r * angle / <span class="number">360</span></span><br><span class="line">    n = trunc(arc_len / <span class="number">3</span>) + <span class="number">1</span></span><br><span class="line">    step_len = arc_len / n</span><br><span class="line">    step_angle = angle / n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        forward(t, step_len)</span><br><span class="line">        turn(t, -step_angle)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>이 함수의 후반부는 <code>polygon()</code>와 유사해보이지만 핵심요소인 인터페이스를 변경했기 때문에 재사용한 것이라고 볼 수는 없다. 따라서 위의 예시는  <code>angle</code>이라는 변수를 추가하여 <code>polygon()</code>을 일반화하였기 때문에 해당 함수는 더 이상 <code>다각형(polygon)</code>라는 이름을 가질 수 없다.</p>
<p>지금부터는 더 일반적으로 사용할 수 있는 <code>polyline()</code>을 만들어보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> polyline(t, n, len, angle)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        forward(t, len)</span><br><span class="line">        turn(t, -angle)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>위의  <code>polyline()</code>을 이용하여 <code>polygon()</code>과 <code>arc()</code>을 더 간단하게 캡슐화할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> polygon(t, n, len)</span><br><span class="line">    angle = <span class="number">360</span> / n</span><br><span class="line">    polyline(t, n, len, angle)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> arc(t, r, angle)</span><br><span class="line">    arc_len = <span class="number">2</span> * <span class="literal">π</span> * r * angle / <span class="number">360</span></span><br><span class="line">    n = trunc(arc_len / <span class="number">3</span>) + <span class="number">1</span></span><br><span class="line">    step_len = arc_len / n</span><br><span class="line">    step_angle = angle / n</span><br><span class="line">    polyline(t, n, step_len, step_angle)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>마지막으로 <code>arc()</code>을 이용하여 <code>circle()</code>를 간단하게 표현할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> circle(t, r)</span><br><span class="line">    arc(t, r, <span class="number">360</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>지금까지 복잡했던 코드들을 일반화하고 캡슐화하여 정리하였다. 이와같이 인터페이스를 개선하고 코드 재사용을 위해 프로그램을  정리하는 과정을 리팩토링이라고 한다. 이 경우는 호를 구하는 <code>arc()</code>과 다각형을 구하는 <code>polygon()</code>의 유사점을 발견하여 <code>polyline()</code>으로 정리하였다.</p>
<p>프로그램을 미리 계획한 경우에는 먼저  <code>polyline()</code>을 작성하여 리팩토링을 생략했겠지만, 대부분 프로젝트 시작시에 모든 인터페이스를 설계하지 못한다. 따라서 리팩토링을 하는 법을 알아두는 것도 중요하다.</p>
<h3 id="개발-계획"><a href="#개발-계획" class="headerlink" title="개발 계획"></a>개발 계획</h3><p>개발 계획은 프로그램을 만드는 프로세스이다. 이 사례 연구에서 사용한 프로세스는 “캡슐화 및 일반화”이며, 이 프로세스의 단계는 다음과 같다.</p>
<ol>
<li>함수 정의 없이 작은 프로그램을 작성하기.</li>
<li>일단 프로그램이 작동하면, 일관된 부분을 찾아서 함수로 캡슐화하고 이름을 지정하기</li>
<li>함수에 적절한 매개 변수를 추가하여 함수를 일반화하기</li>
<li>프로그램 기능이 원하는만큼 나올 때까지 1-3단계를 반복하기</li>
<li>리팩토링을 통해 프로그램을 개선하기 (캡슐화와 일반화 다시 점검)</li>
</ol>
<p>이 프로세스에는 몇 가지 단점이 있기 때문에, 이후 단점에 대해 알아보고 대안을 논의할 것이다. 하지만 프로그램을 함수로 설정하는 방법을 모르는 경우에는 유용하게 사용할 수 있는 방법이다.</p>
<h3 id="독스트링-Docstring"><a href="#독스트링-Docstring" class="headerlink" title="독스트링(Docstring)"></a>독스트링(Docstring)</h3><p>독스트링(Docstring)의 ‘Doc’은 ‘documentation’의 줄임말이며, 이는 함수 앞에 인터페이스를 설명하는 설명을 의미한다. 아래 예시를 보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">polyline(t, n, len, angle)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Draws n line segments with the given length and</span></span><br><span class="line"><span class="string">angle (in degrees) between them.  t is a turtle.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">function</span> polyline(t, n, len, angle)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        forward(t, len)</span><br><span class="line">        turn(t, -angle)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>위의 예시와 같은 문법(<code>“””</code>)을 사용하여 함수 앞에 작성하며, 이후 REPL에서 <code>?</code>를 입력하고 함수의 이름을 치면 문서를 확인할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">help?&gt; polyline</span><br><span class="line">search:</span><br><span class="line"></span><br><span class="line">  polyline(t, n, len, angle)</span><br><span class="line"></span><br><span class="line">  Draws n line segments with the given length and angle (<span class="keyword">in</span> degrees) between them. t is a turtle.</span><br></pre></td></tr></table></figure>

<p>독스트링에는 해당 함수를 사용하기 위한 필수적인 정보가 포함되어 있다. 따라서 팀 단위로 개발을 하는 경우에는 만든 함수에 독스트링을 붙여 다른 사람들도 쉽게 사용할 수 있도록 하는 것이 좋다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>인터페이스는 함수와 사용자 사이의 계약과 같다. 사용자는 특정 매개 변수를 제공하고 함수는 특정 작업을 수행한다.<br>예를 들어 <code>polyline()</code>에서는 4개의 인수가 필요하다. t는 <code>Turtle()</code>이어야 하며 <code>n</code>은 정수여야 하고, <code>len</code>은 양수여야 한다. <code>angle</code>은 각도로 인식되어야 하며, 도 단위로 설정되어 있다.</p>
<p>이런 요구사항들은 함수가 실행되기 전에 <code>true</code>로 간주되기 때문에 전제조건(preconditions)이라고 한다. 반대로 함수 작동 끝에 생성되는 결과 등을 사후 조건(postconditions)라고 한다.</p>
<p>전제 조건의 오류는 사용자의 책임이다. 사용자들이 전제 조건을 어겨서 함수가 제대로 작동하지 않는다면 이는 사용자측에 버그가 있는 것이다. (함수에는 버그가 없다.)</p>
<p>하지만 만약 전제 조건은 알맞게 작성했는데 사후 조건이 이상하다면, 이것은 함수에 버그가 있는 것이다. 따라서 해당 함수의 전제 조건과 사후 조건을 명확하게 아는 것은 디버깅에 많은 도움을 준다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://hyeonji-ryu.github.io/2020/02/29/Chapter-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hyeonji Ryu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AI & ML">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/Chapter-3/" class="post-title-link" itemprop="url">2. 함수</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-29 22:11:41" itemprop="dateCreated datePublished" datetime="2020-02-29T22:11:41+09:00">2020-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-03 22:11:51" itemprop="dateModified" datetime="2020-03-03T22:11:51+09:00">2020-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Think-Julia/" itemprop="url" rel="index">
                    <span itemprop="name">Think Julia</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap03" target="_blank" rel="noopener">Functions</a>를 한글로 요약 정리한 글입니다.</p>
<!-- excerpt -->

<h2 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h2><p>프로그래밍에서 함수는 특정 계산을 수행하는 일련의 명령문이다. 함수를 정의할 때에는 이름과 명령문의 순서를 정하며, 이후 해당 이름을 통해서 함수를 호출할 수 있다.</p>
<h3 id="함수-호출"><a href="#함수-호출" class="headerlink" title="함수 호출"></a>함수 호출</h3><p>우리는 이미 함수를 호출해 본 경험이 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<p>이 함수의 이름은 <code>println()</code>이다. 또한 괄호 안에 들어가는 표현식은 함수의 인수(argument)라고 부른다.<br>함수가 작동하는 과정은 일반적으로 인수를 받은 후 결과를 반환한다고 설명하며, 이런 결과를 반환 값이라고 한다.</p>
<p>줄리아는 데이터 타입을 바꿔주는 함수도 제공한다. 예로 <code>parse()</code>는 숫자로 구성된 문자열을 인수로 받은 후, 정수나 소수로 변환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; parse(<span class="built_in">Int64</span>, <span class="string">"32"</span>)</span><br><span class="line"><span class="number">32</span></span><br><span class="line">julia&gt; parse(<span class="built_in">Float64</span>, <span class="string">"3.14159"</span>)</span><br><span class="line"><span class="number">3.14159</span></span><br><span class="line">julia&gt; parse(<span class="built_in">Int64</span>, <span class="string">"Hello"</span>)</span><br><span class="line">ERROR: <span class="built_in">ArgumentError</span>: invalid base <span class="number">10</span> digit <span class="string">'H'</span> <span class="keyword">in</span> <span class="string">"Hello"</span></span><br></pre></td></tr></table></figure>

<p>또한 <code>trunc()</code>는 소수를 인수로 받아 나머지들을 제거한 후, 남은 정수만을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; trunc(<span class="built_in">Int64</span>, <span class="number">3.99999</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">julia&gt; trunc(<span class="built_in">Int64</span>, -<span class="number">2.3</span>)</span><br><span class="line">-<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><code>float()</code>는 정수를 소수로 변환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; float(<span class="number">32</span>)</span><br><span class="line"><span class="number">32.0</span></span><br></pre></td></tr></table></figure>

<p>마지막으로, <code>string()</code>는 인수들을 모두 문자로 변환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; string(<span class="number">32</span>)</span><br><span class="line"><span class="string">"32"</span></span><br><span class="line">julia&gt; string(<span class="number">3.14159</span>)</span><br><span class="line"><span class="string">"3.14159"</span></span><br></pre></td></tr></table></figure>

<h3 id="수학-함수"><a href="#수학-함수" class="headerlink" title="수학 함수"></a>수학 함수</h3><p>줄리아는 대부분의 기본적인 수학 함수들이 내장되어 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ratio = signal_power / noise_power</span><br><span class="line">decibels = <span class="number">10</span> * log10(ratio)</span><br></pre></td></tr></table></figure>

<p>위의 예시에서는 <code>log10</code>을 사용하여 신호와 잡음의 비율을 데시벨 단위로 계산한다. (신호 변수인 <code>signal_power</code>과 잡음 변수인<code>noise_power</code>가 정의되었다는 전제 하에) 또한 자연로그를 계산하는 <code>log</code> 또한 제공된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">radians = <span class="number">0.7</span></span><br><span class="line">height = sin(radians)</span><br></pre></td></tr></table></figure>

<p>다음의 예시는 해당 <code>radians</code>을 <code>sin()</code>에 적용한다. 위의 예시에서 볼 수 있듯이 줄리아는 <code>sin()</code> 및 기타 삼각 함수 (cos, tan 등) 또한 제공한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; degrees = <span class="number">45</span></span><br><span class="line"><span class="number">45</span></span><br><span class="line">julia&gt; radians = degrees / <span class="number">180</span> * <span class="literal">π</span></span><br><span class="line"><span class="number">0.7853981633974483</span></span><br><span class="line">julia&gt; sin(radians)</span><br><span class="line"><span class="number">0.7071067811865475</span></span><br></pre></td></tr></table></figure>

<p>각도(degree)를 통해 <code>radians</code>을 구하기 위해서는 각도를 180으로 나누고 <code>π</code>를 곱해야 한다. 줄리아에서는 <code>π</code>도 바로 사용할 수 있으며, 소수점 16자리까지 정확하다.</p>
<h3 id="컴포지션-composition"><a href="#컴포지션-composition" class="headerlink" title="컴포지션(composition)"></a>컴포지션(composition)</h3><p>지금까지 우리는 변수, 표현식, 명령문과 같은 프로그램의 요소들이 어떻게 결합하는지에 대해서 이야기하고자 한다.<br>프로그래밍 언어의 가장 유용한 특징 중 하나는 작은 요소들을 가져와서 프로그램을 구성할 수 있다는 것이다. 예를 들어 함수의 인수로 산술연산자를 포함한 모든 종류의 표현식들을 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = sin(degrees / <span class="number">360</span> * <span class="number">2</span> * <span class="literal">π</span>)</span><br><span class="line">x = exp(log(x+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>할당문의 왼쪽은 무조건 변수 이름이 와야 한다. 이 한 가지의 규칙만 어기지 않는다면, 표현식 대부분에 값을 넣을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; minutes = hours * <span class="number">60</span> <span class="comment"># right</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line">julia&gt; hours * <span class="number">60</span> = minutes <span class="comment"># wrong!</span></span><br><span class="line">ERROR: syntax: <span class="string">"60"</span> is not a valid <span class="keyword">function</span> argument name</span><br></pre></td></tr></table></figure>

<h3 id="새로운-함수-만들기"><a href="#새로운-함수-만들기" class="headerlink" title="새로운 함수 만들기"></a>새로운 함수 만들기</h3><p>지금까지 우리는 줄리아가 제공하는 함수들을 사용해왔다. 하지만 그외에도 새로운 함수를 만들어 사용할 수 있다. 새로운 함수를 만드는 방법은 새로운 함수의 이름을 설정하고 실행될 일련의 명령문들의 순서를 설정하는 것이다. 예를 들면 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> printlyrics()</span><br><span class="line">    println(<span class="string">"I'm a lumberjack, and I'm okay."</span>)</span><br><span class="line">    println(<span class="string">"I sleep all night and I work all day."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>function</code>은 함수를 정의하는 키워드이다. 위의 예시에서 함수의 이름은 <code>printlyrics</code>이다. 함수 이름에 대한 규칙은 변수 이름 만드는 규칙과 동일하다. (거의 모든 유니코드는 사용가능하지만 숫자를 이름의 첫 번째 문자로 사용할 수는 없다. 키워드 이름은 사용할 수 없다.)<br>이름 뒤의 빈 괄호는 함수가 인수를 가지지 않는다는 것을 나타낸다.<br>지금까지 설명한 함수의 첫 번째 줄은 헤더(header)라고 부르며, 그 외 나머지는 본문(body)라고 부른다.<br>본문에는 여러 명령문들이 포함되어 있으며, 함수는 키워드 <code>end</code>로 종료된다.<br>또한 가독성을 위해서 본문은 들여 쓰기로 작성해야 한다.</p>
<p>대화식 모드에서 함수를 정의한다면 헤더부터 본문까지 한 줄씩 작성하면 된다. 본문 작성이 끝나고 난 후에는 <code>end</code>를 입력하여 함수 정의를 끝내주어야 한다. 새로 만든 함수를 사용하는 방법은 기존에 있던 함수와 같이 이름을 사용하여 호출하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; printlyrics()</span><br><span class="line"><span class="literal">I</span>'m a lumberjack, and <span class="literal">I</span>'m okay.</span><br><span class="line"><span class="literal">I</span> sleep all night and <span class="literal">I</span> work all day.</span><br></pre></td></tr></table></figure>

<p>새로 만든 함수는 다른 함수 본문에 넣어서 사용할 수도 있다. 아래의 예시를 보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> repeatlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>repeatlyrics()</code>는 앞서 만들었던 <code>printlyrics()</code>를 두 번 실행하도록 정의하였다.<br> 이후 <code>repeatlyrics()</code>를 호출한다면 다음과 같은 결과를 얻을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; repeatlyrics()</span><br><span class="line"><span class="literal">I</span>'m a lumberjack, and <span class="literal">I</span>'m okay.</span><br><span class="line"><span class="literal">I</span> sleep all night and <span class="literal">I</span> work all day.</span><br><span class="line"><span class="literal">I</span>'m a lumberjack, and <span class="literal">I</span>'m okay.</span><br><span class="line"><span class="literal">I</span> sleep all night and <span class="literal">I</span> work all day.</span><br></pre></td></tr></table></figure>

<h3 id="함수-정의와-사용"><a href="#함수-정의와-사용" class="headerlink" title="함수 정의와 사용"></a>함수 정의와 사용</h3><p>앞 장에서 만들었던 함수 정의와 사용 코드를 결합한 전체 프로그램은 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> printlyrics()</span><br><span class="line">    println(<span class="string">"I'm a lumberjack, and I'm okay."</span>)</span><br><span class="line">    println(<span class="string">"I sleep all night and I work all day."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> repeatlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">repeatlyrics()</span><br></pre></td></tr></table></figure>

<p>위의 프로그램은 <code>repeatlyrics()</code>와 <code>printlyrics()</code>를 정의한다. 함수를 정의하는 코드는 오로지 함수 객체를 만드는 역할만 하며, 함수가 호출되기 전까지는 함수 본문의 코드가 진행되지 않는다. 따라서 특정 함수를 사용하고 싶다면, 함수를 먼저 정의한 후에 함수를 호출해야 한다.</p>
<h3 id="실행-과정"><a href="#실행-과정" class="headerlink" title="실행 과정"></a>실행 과정</h3><p>함수의 정의와 사용을 올바르게 사용하기 위해서는 실행 과정을 정확히 알고 있어야 한다.<br>실행은 항상 첫 번째 문장에서 시작하며, 명령문은 위에서 아래로 한 번씩만 작동한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> printlyrics()</span><br><span class="line">    println(<span class="string">"I'm a lumberjack, and I'm okay."</span>)</span><br><span class="line">    println(<span class="string">"I sleep all night and I work all day."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> repeatlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">repeatlyrics()</span><br></pre></td></tr></table></figure>

<p>이 예시를 통해 실행과정을 본다면, 줄리아는 먼저 <code>printlyrics()</code>를 정의한다. 그 후 <code>repeatlyrics()</code>를 정의한 후 호출한다. 호출된  <code>repeatlyrics()</code>는 위에 정의된 본문으로 돌아가 <code>printlyrics()</code>를 호출하는 명령문을 수행한다. 다음으로 호출된 <code>printlyrics()</code>는 해당 함수의 정의된 본문으로 돌아가 명령문을 수행한다. 그 결과가 <code>repeatlyrics()</code>를 호출한 결과로 도출되는 것이다.</p>
<h3 id="매개-변수와-인수"><a href="#매개-변수와-인수" class="headerlink" title="매개 변수와 인수"></a>매개 변수와 인수</h3><p>몇 몇의 함수들은 인수를 필요로 한다. 예를 들어 <code>sin()</code>를 호출하기 위해서는 숫자 한 개를 인수로 입력해야 하며, <code>parse()</code>의 경우 숫자 유형과 문자열 두 개를 인수로 입력해야 한다.</p>
<p>함수 내부에서 인수는 매개 변수라는 변수에 할당된다. 다음 예시는 인수를 취하는 함수에 대한 정의이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> printtwice(bruce)</span><br><span class="line">    println(bruce)</span><br><span class="line">    println(bruce)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>이 함수는 인수를 <code>bruce</code>라는 매개 변수에 지정하였기 때문에 함수가 호출되면 매개 변수 값을 두 번 인쇄한다.<br>또한 위의 함수는 인수에 어떤 값이 들어가든 인쇄한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; printtwice(<span class="string">"Spam"</span>)</span><br><span class="line">Spam</span><br><span class="line">Spam</span><br><span class="line">julia&gt; printtwice(<span class="number">42</span>)</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line">julia&gt; printtwice(<span class="literal">π</span>)</span><br><span class="line"><span class="literal">π</span> = <span class="number">3.1415926535897</span>...</span><br><span class="line"><span class="literal">π</span> = <span class="number">3.1415926535897</span>...</span><br></pre></td></tr></table></figure>

<p><code>printtwice()</code>에 내장되어 있는 <code>println()</code>는 모든 표현식들을 인수로 받으므로 <code>printtwice()</code> 또한 모든 표현식들을 인수로 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; printtwice(<span class="string">"Spam "</span>^<span class="number">4</span>)</span><br><span class="line">Spam Spam Spam Spam</span><br><span class="line">Spam Spam Spam Spam</span><br><span class="line">julia&gt; printtwice(cos(<span class="literal">π</span>))</span><br><span class="line">-<span class="number">1.0</span></span><br><span class="line">-<span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<p>인수는 함수가 호출되기 전에 우선적으로 값을 도출된다. 따라서 위의 예시에서 인수로 쓰인 표현식들은 먼저 값으로 정리 된 후 함수에 적용된다. <code>&quot;Spam &quot;^4</code>인수의 경우, 먼저 <code>Spam Spam Spam Spam</code>으로 도출된 다음에 함수의 인자로 적용된다.</p>
<p>또한 변수도 함수의 인자로 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; michael = <span class="string">"Eric, the half a bee."</span></span><br><span class="line"><span class="string">"Eric, the half a bee."</span></span><br><span class="line">julia&gt; printtwice(michael)</span><br><span class="line">Eric, the half a bee.</span><br><span class="line">Eric, the half a bee.</span><br></pre></td></tr></table></figure>

<h3 id="함수-내부-변수"><a href="#함수-내부-변수" class="headerlink" title="함수 내부 변수"></a>함수 내부 변수</h3><p>함수 내부 변수(local)는 함수 정의 안에서 만들어진 변수를 의미한다. 예를 들면,</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> cattwice(part1, part2)</span><br><span class="line">    concat = part1 * part2</span><br><span class="line">    printtwice(concat)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>위의 함수는 두 개의 인수를 사용하여 곱한 다음에 그 결과를 두 번 인쇄한다. 이 함수에서 <code>conat</code>은 함수 내부에서 만들어진 내부 변수이다.<br>위의 함수를 사용한 예시는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; line1 = <span class="string">"Bing tiddle "</span></span><br><span class="line"><span class="string">"Bing tiddle "</span></span><br><span class="line">julia&gt; line2 = <span class="string">"tiddle bang."</span></span><br><span class="line"><span class="string">"tiddle bang."</span></span><br><span class="line">julia&gt; cattwice(line1, line2)</span><br><span class="line">Bing tiddle tiddle bang.</span><br><span class="line">Bing tiddle tiddle bang.</span><br></pre></td></tr></table></figure>

<p>위의 실행에서 <code>cattwice()</code>가 종료되는 순간 내부 변수 <code>conat</code>은 삭제된다. 그렇기 때문에  <code>conat</code>을 인쇄하려고 하면 아래와 같은 오류를 만날 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; println(concat)</span><br><span class="line">ERROR: <span class="built_in">UndefVarError</span>: concat not defined</span><br></pre></td></tr></table></figure>

<p>매개 변수 또한 내부 변수이다. 즉, <code>printtwice()</code> 정의에 사용된 매개 변수 <code>bruce</code> 또한 인쇄할 수 없다.</p>
<h3 id="스택-다이어그램"><a href="#스택-다이어그램" class="headerlink" title="스택 다이어그램"></a>스택 다이어그램</h3><p>어디에서 어떤 변수를 사용했는지 추척하려면 스택 다이어그램을 그리는 것이 유용하다. 스택 다이어그램에는 각 변수의 값과 그 값이 속한 함수도 표시된다.<br>각 함수는 프레임 단위로 그리며, 프레임 안에는 함수의 매개 변수와 내부 변수를 쓴다.</p>
<p>예시는 다음과 같다.</p>
<p>fig31</p>
<p>프레임은 함수가 호출되는 순서대로 배열한다. 위의 예에서는 <code>Main</code>이 <code>cattwice()</code>를 호출하며, <code>cattwice()</code>는 <code>printtwice()</code>를 호출한다. 함수 외부에서 변수를 만들면, 이는 <code>Main</code>에 속한다.</p>
<p>각 매개 변수는 해당 인수와 동일한 값을 나타낸다. 따라서 <code>part1</code>은 <code>line1</code>과 같고 <code>part2</code>는  <code>line2</code>와 같으며, <code>bruce</code>는 <code>conat</code>과 같다.</p>
<p>함수 호출 도중에 오류가 발생가면 줄리아는 해당 오류의 위치를 알려 준다.<br>예를 들어,  <code>printtwice()</code>에서 <code>concat</code>에 액세스하려고하면 <code>UndefVarError</code>가 발생한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ERROR: <span class="built_in">UndefVarError</span>: concat not defined</span><br><span class="line">Stacktrace:</span><br><span class="line"> [<span class="number">1</span>] printtwice at ./REPL[<span class="number">1</span>]:<span class="number">2</span> [inlined]</span><br><span class="line"> [<span class="number">2</span>] cattwice(::<span class="built_in">String</span>, ::<span class="built_in">String</span>) at ./REPL[<span class="number">2</span>]:<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>위처럼 함수 목록들을 통해 오류가 발생한 프로그램 파일과 함수를 알려주는 것을 스택 추적이라고 한다<br>스택 추척의 함수 목록 순서는 스택 다이어그램의 프레임 순서와 반대이다.</p>
<h3 id="유익한-함수와-빈-함수"><a href="#유익한-함수와-빈-함수" class="headerlink" title="유익한 함수와 빈 함수"></a>유익한 함수와 빈 함수</h3><p>우리가 사용하는 어떤 함수는 결괏값을 반환하지만 어떤 함수는 결과를 반환하지 않는다. 우리는 전자를 유익한 함수(fruitful function)이라고 하며, 후자를 빈 함수(void function)이라고 한다.</p>
<p>예로 유익한 함수를 먼저 본다면,</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">golden</span> = (sqrt(<span class="number">5</span>) + <span class="number">1</span>) / <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>위의 예시의 <code>sqrt()</code>는 유익한 함수로서 반환 값을 가지고 있기 때문에 바로 계산이 가능하다.<br>대화식 모드에서 함수를 호출하면, 다음과 같은 결과를 도출한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; sqrt(<span class="number">5</span>)</span><br><span class="line"><span class="number">2.23606797749979</span></span><br></pre></td></tr></table></figure>

<p>하지만 스크립트 모드에서는 위의 예시처럼 함수를 호출하면 반환 값은 손실된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqrt(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>위의 스크립트는 아래의 값은 산출만 한다. (저장하지 않는다.)</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.23606797749979</span></span><br></pre></td></tr></table></figure>

<p>따라서  스크립트 모드에서는 그다지 유익한 함수로서 작동하지 않는다.</p>
<p>빈 함수는 화면에 값을 표시하거나 다른 영향을 줄 수는 있지만 반환 값은 없다. 아래의 예시를 보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; result = printtwice(<span class="string">"Bing"</span>)</span><br><span class="line">Bing</span><br><span class="line">Bing</span><br><span class="line">julia&gt; show(result)</span><br><span class="line"><span class="literal">nothing</span></span><br></pre></td></tr></table></figure>

<p>위의 예시는 변수 <code>result</code>에 함수의 값을 할당하였지만, 밑에 결과를 보면 아무것도 없는 것을 확인할 수 있다.  두번째 코드의 결과인 <code>nothing</code>은 그 자체로 특수한 데이터 타입이며,  문자열인 <code>”nothing”</code>과는 구분된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; typeof(<span class="literal">nothing</span>)</span><br><span class="line">Nothing</span><br></pre></td></tr></table></figure>

<h3 id="왜-함수인가"><a href="#왜-함수인가" class="headerlink" title="왜 함수인가"></a>왜 함수인가</h3><p>프로그램을 만드는데 있어 함수가 왜 유용한지 궁금할 것이다. 이에 대한 몇 가지 이유를 보자.</p>
<ul>
<li>함수는 명령문들을 묶어서 사용할 수 있으므로, 이후 프로그램을 쉽게 파악하고 디버깅을 할 수 있다.</li>
<li>함수는 반복적인 코드들을 대체하여 프로그램 코드를 더 짧게 만들어준다.</li>
<li>한번에 긴 프로그램을 설계하는 것보다 함수 단위로 나누어 설계하고 조립하는 것이 더 쉽다.</li>
<li>잘 설계된 함수는 여러 프로그램에서 사용할 수 있다. (재사용 가능)</li>
<li>줄리아에서는 함수들이 성능을 크게 향상시킬 수 있다.</li>
</ul>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>디버깅은 가장 중요한 기술 중 하나이다. 그 이유는 프로그램 진행과정을 완벽히 알고 있어야 가능한 기술이기 때문이다. 프로그램에 문제가 생긴다면 개발자는 프로그램의 진행과정에서 문제와 관련된 단서를 찾고, 해결방안을 모색해야 한다. 이런 과정들은 매우 어렵고 힘들지만, 꼭 필요한 능력이다.</p>
<p>어떤 사람들에게는 프로그래밍과 디버깅은 동일하다. 즉, 프로그래밍은 원하는 작업이 수행될 때까지 코드들을 점검하고 디버깅하는 과정이기 때문이다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://hyeonji-ryu.github.io/2020/02/28/chapter-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hyeonji Ryu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AI & ML">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/28/chapter-2/" class="post-title-link" itemprop="url">1. 변수 , 표현식과 명령문</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-28 14:58:12" itemprop="dateCreated datePublished" datetime="2020-02-28T14:58:12+09:00">2020-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-03 22:11:51" itemprop="dateModified" datetime="2020-03-03T22:11:51+09:00">2020-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Think-Julia/" itemprop="url" rel="index">
                    <span itemprop="name">Think Julia</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap02" target="_blank" rel="noopener">Variables, Expressions and Statements</a>를 한글로 요약 정리한 글입니다.</p>
<!-- excerpt -->

<hr>
<h2 id="변수-표현식과-명령문"><a href="#변수-표현식과-명령문" class="headerlink" title="변수 , 표현식과 명령문"></a>변수 , 표현식과 명령문</h2><p>프로그래밍 언어의 가장 큰 특징 중 하나는 변수를 설정할 수 있다는 것이다.  변수(variables)란 값(values)을 나타내는 이름으로서, 개발자가 특정 변수에 직접 값을 할당하여 사용할 수 있다.</p>
<h3 id="할당문"><a href="#할당문" class="headerlink" title="할당문"></a>할당문</h3><p>할당문이란 새로운 변수를 만들고, 그 변수에 값을 주는 코드를 말한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; message = <span class="string">"And now for something completely different"</span></span><br><span class="line"><span class="string">"And now for something completely different"</span></span><br><span class="line">julia&gt; n = <span class="number">17</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line">julia&gt; π_val = <span class="number">3.141592653589793</span></span><br><span class="line"><span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure>

<p>위의 예시는 3개의 할당문을 보여준 것이다. 첫 번째 코드는 <code>message</code>라는 변수를 만들어 등호 뒤의 문자열을 할당한다. 두 번째 코드는 정수 <code>17</code>을 변수 <code>n</code>에 할당하며, 세 번째는 π의 근사값을 변수 <code>π_val</code>에 할당한다.</p>
<h3 id="변수-이름"><a href="#변수-이름" class="headerlink" title="변수 이름"></a>변수 이름</h3><p>변수 이름은 길이에 제약 없이 설정할 수 있으며, 프로그래머들은 일반적으로 변수 이름에 특정 의미(변수의 목적 등)를 담아 사용한다. 변수 이름은 거의 모든 유니코드 글자들을 포함하지만, 숫자를 이름의 시작으로는 사용할 수 없다. 또한 대문자를 사용하는 것이 문제가 되지는 않지만 주로 소문자를 이용하여 변수 이름을 만든다.</p>
<p>밑줄문자(_)도 변수 이름에 사용할 수 있다. 이 문자는 your_name 이나 airspeed_of_unladen_swallow 와 같이 여러 단어가 연결된 이름에 단어들을 구분하는 구분자로서 사용된다.</p>
<p>만약 위의 내용을 어긴 변수 이름을 사용하여 변수를 만든다면, 문법 에러(syntax error)가 나올 것이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="number">76</span>trombones = <span class="string">"big parade"</span></span><br><span class="line">ERROR: syntax: <span class="string">"76"</span> is not a valid <span class="keyword">function</span> argument name</span><br><span class="line">julia&gt; more@ = <span class="number">1000000</span></span><br><span class="line">ERROR: syntax: extra token <span class="string">"@"</span> after <span class="keyword">end</span> of expression</span><br><span class="line">julia&gt; <span class="keyword">struct</span> = <span class="string">"Advanced Theoretical Zymurgy"</span></span><br><span class="line">ERROR: syntax: unexpected <span class="string">"="</span></span><br></pre></td></tr></table></figure>

<p><code>76trombones</code>는 숫자로 시작했기 때문에 변수 이름으로 사용할 수 없으며, <code>more@</code>는 마지막 @기호로 인해서 변수 이름으로 사용할 수 없다. 그렇다면 <code>struct</code>는 뭐가 문제일까?</p>
<p>사실 <code>struct</code>은 줄리아의 키워드이다. REPL에서는 프로그램의 구조를 이해하기 위해서 몇 가지의 키워드를 사용하는데, 이 키워드 또한 변수 이름으로 사용할 수 없다. 줄리아는 아래의 그림과 같은 키워드들을 가지고 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract type</span>     <span class="keyword">baremodule</span>     <span class="keyword">begin</span>       <span class="keyword">break</span>         <span class="keyword">catch</span></span><br><span class="line"><span class="keyword">const</span>             <span class="keyword">continue</span>       <span class="keyword">do</span>          <span class="keyword">else</span>          <span class="keyword">elseif</span></span><br><span class="line"><span class="keyword">end</span>               <span class="keyword">export</span>         <span class="keyword">finally</span>     <span class="keyword">for</span>           <span class="keyword">function</span></span><br><span class="line"><span class="keyword">global</span>            <span class="keyword">if</span>             <span class="keyword">import</span>      <span class="keyword">importall</span>     <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span>               <span class="keyword">local</span>          <span class="keyword">macro</span>       <span class="keyword">module</span>        <span class="keyword">mutable struct</span></span><br><span class="line"><span class="keyword">primitive type</span>    <span class="keyword">quote</span>          <span class="keyword">return</span>      <span class="keyword">try</span>           <span class="keyword">using</span></span><br><span class="line"><span class="keyword">struct</span>            <span class="keyword">where</span>          <span class="keyword">while</span></span><br></pre></td></tr></table></figure>

<p>위의 키워드들을 모두 외울 필요는 없다. 만약 키워드로 변수 이름을 설정하려고 해도 대부분의 개발 환경에서는 키워드들을 다른 색깔로 보여주기 때문에 키워드임을 알 수 있다.</p>
<h3 id="표현식과-명령문들"><a href="#표현식과-명령문들" class="headerlink" title="표현식과 명령문들"></a>표현식과 명령문들</h3><p>표현식(expression)은 값, 변수 및 연산자들의 조합이다. 값이나 변수 그자체는 모두 표현식으로 간주되기 때문에 아래의 코드들은 모두 표현식이라고 볼 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="number">42</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line">julia&gt; n</span><br><span class="line"><span class="number">17</span></span><br><span class="line">julia&gt; n + <span class="number">25</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>위의 세 번째 코드와 같은 표현식을 작동시키면, REPL은 변수인 <code>n</code>의 값을 찾아서 연산을 진행한다. <code>n</code>의 값은 17이기 때문에 <code>n + 25</code>의 표현식 값은 12+25인 42이다.</p>
<p>명령문(statement)은 변수를 작성하거나 변수를 보여주는 등의 특정 효과를 가지는 코드를 말한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; n = <span class="number">17</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line">julia&gt; println(n)</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>

<p>첫 번째 코드는 변수 <code>n</code>에 17이라는 값을 할당하는 명령문이며, 두 번째 코드는 변수 <code>n</code>의 값을 보여주는 함수를 가진 명령문이다.</p>
<p>명령문을 입력하면, REPL이 명령문이 요청하는대로 수행한다.</p>
<h3 id="스크립트-모드"><a href="#스크립트-모드" class="headerlink" title="스크립트 모드"></a>스크립트 모드</h3><p>지금까지는 REPL에 코드를 한 줄씩 직접 입력하여 실행하는 대화식 모드를 사용해왔다. 하지만 이 방법은 긴 코드를 작업하는 경우에는 매우 불편할 것이다.  그렇기에 대안으로서 스크립트 모드를 사용하고자 한다.  <strong>스크립트 모드</strong>란 코드들을 파일에 저장한 후, 줄리아를 실행하여 한번에 작동시키는 것이다. 줄리아의 스크립트 파일은 <code>.ji</code>이라는 확장자명을 가진다.</p>
<p>줄리아는 두 모드를 모두 제공하기 때문에 스크립트에 배치하기 전에 대화식 모드에서 코드를 테스트 해볼 수 있다.</p>
<p>하지만 두 모드 사이에는 혼동하기 쉬운 차이점이 있다.<br>예를 들어 만약 줄리아를 계산기로 사용하여 아래 코드와 같이 입력하면,</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; miles = <span class="number">26.2</span></span><br><span class="line"><span class="number">26.2</span></span><br><span class="line">julia&gt; miles * <span class="number">1.61</span></span><br><span class="line"><span class="number">42.182</span></span><br></pre></td></tr></table></figure>

<p>첫 번째 코드에서는 변수 <code>miles</code>에 값을 할당하고 보여준다. 그리고 두 번째는 표현식이기 때문에 REPL은 변수<code>miles</code>의 값을 찾아 계산을 한 뒤에 결괏값을 보여 준다.<br>그러나 위의 코드를 스크립트로 입력하여 작동시키면, 어떠한 결괏값도 나오지 않는다. 그 이유는 스크립트 모드에서는 표현식 그 자체가 결과를 보여주는 기능을 가지고 있지 않기 때문이다. 즉, 아래의 코드와 같이 입력하지 않으면 값을 표시하지 않는다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">miles = <span class="number">26.2</span></span><br><span class="line">println(miles * <span class="number">1.61</span>)</span><br></pre></td></tr></table></figure>

<p>이런 규칙은 초반에 헷갈릴 수 있다.</p>
<p>스크립트는 보통 일련의 명령문들을 포함한다. 명령문이 둘 이상의 요청을 가진 경우에는 보통 명령문 하나당 하나의 요청만 실행된다.<br>예로, 아래의 코드를 스크립트 모드로 작동시킨다면,</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="number">1</span>)</span><br><span class="line">x = <span class="number">2</span></span><br><span class="line">println(x)</span><br></pre></td></tr></table></figure>

<p>결과는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>두번째 줄 코드인 할당문은 2라는 결과를 도출하지 않았다. 할당문은 단지 변수에 값은 할당해주는 한 가지 역할만 한 것이다.</p>
<h3 id="연산자-우선순위"><a href="#연산자-우선순위" class="headerlink" title="연산자 우선순위"></a>연산자 우선순위</h3><p>만약 표현식이 많은 연산자들은 포함하고 있다면, 그 결괏값은 연산자 우선순위에 따라서 결정된다. 줄리아는 수학연산자의 규칙을 따른다. 약어인 PEMDAS는 규칙을 기억하는 유용한 방법이다.</p>
<ul>
<li>괄호(Parentheses)가장 높은 우선순위를 가지며 원하는 순서를 표현하는데 사용할 수 있다.</li>
<li>지수(Exponentiation)가 그 다음으로 높은 우선순위를 가진다.</li>
<li>곱셈(Multiplication)과 나눗셈(Division)이 그 다음으로 작동된다.</li>
<li>마지막으로 덧셈(Addition)과 뺄셈(Subtraction)이 작동한다.</li>
<li>우선순위가 동일한 연산자의 경우 왼쪽에서 오른쪽으로 진행된다.</li>
</ul>
<h3 id="문자열-연산"><a href="#문자열-연산" class="headerlink" title="문자열 연산"></a>문자열 연산</h3><p>일반적으로 수학 연산자들은 문자열에 사용할 수 없다. 심지어 그 문자가 숫자처럼 보일지라도 데이터 타입이 문자열이라면 불가능하다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"2"</span> - <span class="string">"1"</span>    <span class="string">"eggs"</span> / <span class="string">"easy"</span>    <span class="string">"third"</span> + <span class="string">"a charm"</span></span><br></pre></td></tr></table></figure>

<p>그러나 예외로 <code>*</code>와 <code>^</code>는 사용할 수 있다.</p>
<p> <code>*</code> 연산자는 문자를 연결해준다. 즉, 문자열 2개의 끝과 끝을 연결하여 하나의 문자열로 만드는 것을 의미한다.<br>예로 아래의 코드를 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; first_str = <span class="string">"throat"</span></span><br><span class="line"><span class="string">"throat"</span></span><br><span class="line">julia&gt; second_str = <span class="string">"warbler"</span></span><br><span class="line"><span class="string">"warbler"</span></span><br><span class="line">julia&gt; first_str * second_str</span><br><span class="line"><span class="string">"throatwarbler"</span></span><br></pre></td></tr></table></figure>

<p><code>^</code>연산자는 해당 문자열을 반복한다. 예를 들어서 <code>”Spam”^3</code>는 <code>”SpamSpamSpam”</code>로 작동한다. 즉 문자열에서 <code>^</code>연산자는 지수와 유사하게 작동하는 것을 알 수 있다.</p>
<h3 id="주석"><a href="#주석" class="headerlink" title="주석"></a>주석</h3><p>프로그램이 커지고 복잡해지면, 코드를 보고 어떤 작업을 하는지 또는 왜 그 작업을 하는지 알아내기 어려울 때가 많다. 그렇기 때문에 프로그램을 수행함에 있어서 각각의 작업에 대한 설명을 메모해두는 것이 좋다. 이러한 메모를 주석(comment)라고 하며 <code>#</code>기호를 사용한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># compute the percentage of the hour that has elapsed</span></span><br><span class="line">percentage = (minute * <span class="number">100</span>) / <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>위의 경우는 주석이 한 줄을 차지하고 있다. 만약 코드와 같은 줄에 주석을 작성하고 싶다면 코드 끝에 쓰면 된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">percentage = (minute * <span class="number">100</span>) / <span class="number">60</span>   <span class="comment"># percentage of an hour</span></span><br></pre></td></tr></table></figure>

<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>프로그램에서는 세 가지 종류의 오류가 발생할 수 있다. 오류를 빠르게 파악하기 위해서는 이 세 가지 오류에 대해서 알아두는 편이 좋다.</p>
<p><strong>문법 오류(syntax error)</strong><br>문법은 프로그램 구조에 대한 규칙을 나타낸다. 예를 들어서 괄호는 쌍을 이뤄야 하므로 (1+2)는 올바르지만 8)은 문법 오류이다.<br>프로그램 어딘가에 문법오류가 있는 경우 줄리아는 오류 메시지를 도출하고 종료 되며 프로그램은 실행되지 않는다.<br>문법 오류를 추적하는 것은 많은 시간이 필요하지만, 경험이 쌓이면 오류를 빠르게 찾을 수 있다.</p>
<p><strong>런타임 오류(runtime error)</strong><br>런타임 오류는 프로그램이 실행되기 전까지는 나타나지 않는다. 그렇기 때문에 프로그램을 테스트 할 때 파악할 수 있으며, 대부분 인지하지 못한 예외적인 문제들이 이 오류에 포함된다.<br>간단한 프로그램에서 해당 오류는 드물다.</p>
<p><strong>의미 오류(semantic error)</strong><br>의미 오류는 개발자의 의도와는 다른 방향으로 프로그램이 작동되는 현상이다. 이는 문법오류와 같이 컴퓨터가 파악할 수 있는 오류가 아니기 때문에 오류 메시지가 나타나지 않는다.<br>그렇기에 해당 오류를 찾기 위해서는 프로그램의 출력을 보고 수행중인 작업에서 예측가능한 결과인지를 파악하여 역으로 찾는 수밖에 없다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://hyeonji-ryu.github.io/2020/02/27/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hyeonji Ryu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AI & ML">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/test/" class="post-title-link" itemprop="url">0. Github Page와 Hexo를 이용하여 블로그 만들기</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-27 18:18:23" itemprop="dateCreated datePublished" datetime="2020-02-27T18:18:23+09:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-03 22:11:51" itemprop="dateModified" datetime="2020-03-03T22:11:51+09:00">2020-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/about-Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">about Hexo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hexo 블로그를 만들기 위해서는 Github계정을 사용하는 것이 가장 편합니다. Github계정이 없는 분들은 <a href="https://github.com" target="_blank" rel="noopener">Github</a>에서 만들어 주세요! Github계정이 있는 분들이라면 바로 Hexo 블로그를 만들 수 있습니다.</p>
<p>Hexo 블로그를 만들기 위해서는 크게 2가지의 과정이 필요합니다.</p>
<h2 id="Github-repository-만들기"><a href="#Github-repository-만들기" class="headerlink" title="Github repository 만들기"></a>Github repository 만들기</h2><p>Github repository 만드는 방법은 다음과 같습니다.</p>
<ul>
<li><p>Github계정에 들어가면 상단바에서 <code>Repositories</code>를 클릭한 후, <code>New</code>를 눌러주세요</p>
</li>
<li><p>그 다음 <code>Repository name</code>에 <code>사용자이름.github.io</code>로 작성하고, <code>Public 모드</code>으로 설정한 다음 <code>create repository</code>를 눌러주세요</p>
</li>
<li><p><code>repository</code>생성이 완료되면, 터미널을 켜서 원하는 디렉토리에 아래의 코드를 입력해주세요</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/사용자이름/사용자이름.github.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>디렉토리를 설정하는 방법은 터미널에 <code>pwd</code>를 입력하여 현재 위치를 파악하고, <code>cd 이동하려는 위치 이름</code>을 입력하여 이동하면 됩니다. (Mac 기준)</p>
</li>
<li><p>해당 디렉토리에 <code>사용자이름.github.io</code> 파일이 생성되었다면, 아래의 코드를 입력해주세요.</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 사용자이름.github.io</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; index.html</span><br><span class="line">git add --all</span><br><span class="line">git commit -m <span class="string">"Initial commit"</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>완성입니다! 마지막으로 브라우저에서 <code>https://USERNAME.github.io</code>에 접속되는지 확인해보면 됩니다.</p>
<h2 id="Hexo-만들기"><a href="#Hexo-만들기" class="headerlink" title="Hexo 만들기"></a>Hexo 만들기</h2><p>Hexo 셋팅을 하는 것은 몇 줄의 코드면 끝납니다. 이제부터 아래의 코드를 순서대로 입력해주세요.</p>
<h3 id="설치-전-준비해야-할-것"><a href="#설치-전-준비해야-할-것" class="headerlink" title="설치 전 준비해야 할 것"></a>설치 전 준비해야 할 것</h3><p>Hexo를 설치하기 전에 아래의 요소들을 다운로드 해야 합니다. 이미 다운을 받았다면 넘어가도 좋습니다.<br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a><br><a href="https://git-scm.com" target="_blank" rel="noopener">Git</a></p>
<h3 id="Hexo-설치-코드"><a href="#Hexo-설치-코드" class="headerlink" title="Hexo 설치 코드"></a>Hexo 설치 코드</h3><p>설치를 시작하기에 앞서 터미널에서 Hexo파일을 저장할 디렉토리를 먼저 설정해주셔야 합니다.<br>디렉토리를 설정하는 방법은 <code>Github repository 만들기</code>에 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init myBlog <span class="comment">#`myBlog`라는 파일을 만들기</span></span><br><span class="line"><span class="built_in">cd</span> myBlog <span class="comment">#myBlog로 디렉토리 설정</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>설치가 완료되었습니다.</p>
<h3 id="블로그-기본-설정"><a href="#블로그-기본-설정" class="headerlink" title="블로그 기본 설정"></a>블로그 기본 설정</h3><p>Hexo를 설치하면서 생성한 폴더를 오픈합니다. 그 다음 블로그의 기본적인 설정을 바꾸기 위해서 <code>_config.yml</code>를 열어줍니다.<br>텍스트 파일로 오픈해도 되지만 저의 경우는 <a href="https://code.visualstudio.com" target="_blank" rel="noopener">Visual studio code</a>를 통해서 파일을 열었습니다.<br>해당 파일에서 아래와 같은 부분을 수정하고 저장하면 됩니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># site 정보 수정</span></span><br><span class="line">title: AI&amp;ML <span class="comment"># 블로그 이름</span></span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">author: Hyeonji Ryu <span class="comment"># 사용자 이름</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 정보 수정</span></span><br><span class="line">url: https://사용자이름.github.io <span class="comment"># 이 부분 수정</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/사용자이름/사용자이름.github.io.git</span><br></pre></td></tr></table></figure>

<h3 id="테스트-및-배포하기"><a href="#테스트-및-배포하기" class="headerlink" title="테스트 및 배포하기"></a>테스트 및 배포하기</h3><p>테스트를 위해서 터미널에 아래의 코드를 입력해주세요.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 테스트</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>서버가 작동된 후에는 <code>http://localhost:4000</code>에서 변경사항이 적용된 블로그를 미리 볼 수 있습니다.<br>테스트도 완료했다면 Github repository에서 배포해주시면 블로그 완성입니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 해당 리소스 생성</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 배포하기</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://hyeonji-ryu.github.io/2020/02/27/Think-Julia-Chapter-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hyeonji Ryu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AI & ML">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/Think-Julia-Chapter-1/" class="post-title-link" itemprop="url">0. Why Julia?</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-27 16:25:49" itemprop="dateCreated datePublished" datetime="2020-02-27T16:25:49+09:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-03 22:11:51" itemprop="dateModified" datetime="2020-03-03T22:11:51+09:00">2020-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Think-Julia/" itemprop="url" rel="index">
                    <span itemprop="name">Think Julia</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#_why_julia" target="_blank" rel="noopener">Why Julia?</a>를 한글로 요약 정리한 글입니다.</p>
<!-- excerpt -->

<hr>
<h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>Julia(이하 줄리아)는 2012년에 개발되었으며, 무료로 사용할 수 있는 오픈소스 프로그래밍 언어 중 하나이다. 사실 프로그래밍 언어를 선택하는 것은 부차적인 문제지만, 이 언어는 선택할만한 가치가 있다. 다음으로 해당 언어의 장점에 대해서 알아보자.</p>
<ul>
<li>줄리아는 높은 성능을 위해 개발된 프로그래밍 언어이다.</li>
<li>줄리아는 다른 데이터 타입에 대한 함수나 메서드도 동적으로 사용 가능한 다중 디스패치(multiple dispatch)를 사용한다.<br>(다중 디스패치는 이후 17장에서 자세히 다룰 예정입니다.)</li>
<li>줄리아는 상호작용하기 쉬운 동적 타입의 언어이다.</li>
<li>줄리아는 배우기 쉬운 수준의 문법을 가진다.</li>
<li>줄리아는 데이터 타입이 정의된 언어(typed programming language)이기 때문에, 사용자의 코드를 더욱 깔끔하고 견고하게 만들어준다.</li>
<li>줄리아는 확장된 표준 라이브러리들이 있으며, 수많은 다른 패키지들도 사용할 수 있다.</li>
</ul>
<p>특히 줄리아는 “두 개의 언어 문제(two language problem)”를 해결하기 때문에 매우 독특한 프로그래밍 언어이다.</p>
<p><strong>두 개의 언어 문제란?</strong> R과 Python과 같은 고수준 언어들은 성능(속도 등)이 떨어지기 때문에, 결국 실용화하기 위에서는 C나 C++로 다시 코드를 작성해야 하는 문제를 말한다.</p>
<p>줄리아는 고성능 코드를 작성하기 위해서 다른 프로그래밍 언어가 필요하지 않다. 즉, 줄리아는 병목현상을 자동으로 최적화해줌으로써 프로그래머들의 어려움을 덜어준다.</p>
<h2 id="프로그램의-방식"><a href="#프로그램의-방식" class="headerlink" title="프로그램의 방식"></a>프로그램의 방식</h2><p>이 책은 독자들이 ‘컴퓨터 사이언티스트’처럼 생각할 수 있도록 안내한다. 그들처럼 생각하는 방식은 수학, 공학, 자연과학 등의 특징들을 결합하는 것이다. 구체적인 방식을 확인해보자. 먼저 컴퓨터 사이언티스트들은 수학자처럼 공식을 사용하여 아이디어(구체적인 계산들)를 표현한다. 그 이후 엔지니어와 마찬가지로 필요한 부품을 시스템에 조립하고 여러 대안들의 장단점을 평가하여 해당 아이디어를 설계한다. 마지막으로 과학자처럼 그들은 복잡한 시스템들의 작동을 관찰하고, 가설을 형성하며 검증한다.</p>
<p>컴퓨터 사이언티스트에게 가장 중요한 능력은 바로 “문제해결(problem solving)” 이다. 문제해결이란 문제를 형식화하고 창의적으로 생각하여 문제에 대한 정확하고 명확한 해결방안을 표현할 수 있는 능력을 말한다. 결론적으로 프로그램을 배우는 과정은 문제해결기술을 연습하는 데 매우 훌륭한 기회라는 것이다. 이것이 이번 챕터의 제목을 “프로그램의 방식”이라고 정한 이유이다.</p>
<h3 id="프로그램이란"><a href="#프로그램이란" class="headerlink" title="프로그램이란"></a>프로그램이란</h3><p>프로그램은 계산을 수행하는 방법을 구체화하는 연속적인 명령이다. 계산은 방정식을 풀거나 다항식의 근을 찾는 것과 같이 수학적인 의미도 있지만, 동시에 문서에서 텍스트를 검색하거나 이미지 처리와 같은 상징적인 의미도 가지고 있다. 명령문 코드의 세부적인 요소들은 언어마다 다르지만, 몇 개의 기본 명령은 모든 언어에서 똑같이 나타난다.</p>
<ul>
<li>Input : 파일이나 인터넷, 다른 디바이스 등에서 데이터를 가져오는 것</li>
<li>Output: 데이터를 스크린에 띄우거나 파일을 저장하는 것, 네트워크를 통해 보내는 것 등을 의미</li>
<li>Math: 덧셈이나 곱셈처럼 기본적인 수학 작동들을 수행하는 것.</li>
<li>Conditional execution: 특정 환경들을 확인하고 알맞은 코드를 적용하는 것.</li>
<li>Repetition: 약간의 변화를 주고 작업을 반복하는 것</li>
</ul>
<p>믿거나 말거나 이것이 프로그램의 거의 전부이다 당신이 사용해왔던 모든 프로그램은 얼마나 복잡한지와는 상관없이 위와 같은 명령들로 만들어졌다.<br>따라서 프로그래밍은 크고 복잡한 기본 명령들을 충분히 수행될 할 수 있을만한 하위 작업들로 나누어 가는 과정으로 생각할 수 있다.</p>
<h3 id="줄리아-시작하기"><a href="#줄리아-시작하기" class="headerlink" title="줄리아 시작하기"></a>줄리아 시작하기</h3><p>줄리아를 배우기 전에, 먼저 해당 소프트웨어를 설치해야 한다. 만약 당신이 컴퓨터의 OS체제를 알고 있다면, 홈페이지에 들어가 알맞은 소프트웨어를 다운로드 받으면 된다.</p>
<p>Julia의 REPL(Read-Eval-Print-Loop)는 Julia 코드를 읽고 실행하는 프로그램이다. 해당 창에 Enter키를 입력하면 아래와 같은 그림이 나타난다.</p>
<p><img src="https://github.com/Hyeonji-Ryu/Hyeonji-Ryu.github.io/blob/master/2020/01/15/2020-02-25.png" alt="julia intro"></p>
<p>해당 그림의 마지막 줄에 있는 <code>Julia&gt;</code>는 명령을 입력하는 프롬프트(prompt)이며, 이곳에 코드를 입력하면 결괏값(Output)을 받을 수 있다.</p>
<h3 id="첫-번째-프로그램"><a href="#첫-번째-프로그램" class="headerlink" title="첫 번째 프로그램"></a>첫 번째 프로그램</h3><p>첫 번째 프로그램으로 우리가 작성할 코드는 “Hello, World!” 이다. 코드는 아래 그림과 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<p>위 그림은 <code>print</code>코드의 예시이다. 여기서 <code>print</code>코드는 종이에 글씨를 복사하는 것이 아니라, 단지 입력한 코드에 대한 결괏값을 스크린에 보여주는 것을 의미한다. 인용구 기호(“”)는 글자의 시작과 끝에 사용하며, 결괏값에는 나타나지 않는다. 또한 괄호는 <code>println</code>이 함수라는 것을 알려준다. 함수에 대해서는 3장에서 배울 것이다.</p>
<h3 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a>산술 연산자</h3><p>“Hello, world!” 다음으로는 사칙연산이다. 줄리아는 덧셈이나 곱셈과 같은 기본적인 연산자들을 제공한다. 연산자 기호들은 <code>+</code>는 덧셈, <code>-</code>는 뺄셈, <code>*</code>는 곱셈, <code>/</code>는 나눗셈이다. 해당 기호들을 사용한 예시는 아래의 그림과 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="number">40</span>+<span class="number">2</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="number">43</span>-<span class="number">1</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="number">6</span>*<span class="number">7</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="number">84</span>/<span class="number">2</span></span><br><span class="line"><span class="number">42.0</span></span><br></pre></td></tr></table></figure>

<p>위의 계산식에서 유일하게 나눗셈만 답이 소수점으로 나오는데, 그 이유는 바로 다음 글인 데이터 타입에서 설명할 것이다.</p>
<p>마지막으로 연산자 <code>^</code>는 거듭제곱에 대한 기호이다. 즉, 앞의 수를 뒤의 수만큼 제곱하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="number">6</span>^<span class="number">2</span>+<span class="number">6</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="number">2</span>^<span class="number">5</span>+<span class="number">10</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>

<h3 id="값-그리고-데이터-타입들"><a href="#값-그리고-데이터-타입들" class="headerlink" title="값 그리고 데이터 타입들"></a>값 그리고 데이터 타입들</h3><p>값(value)은 프로그램이 일할 때 사용하는 가장 기본적인 문자나 숫자를 말한다. 예로 우리가 이미 본 “Hello, World!”나 42.0, 2 등이 있다.</p>
<p>위에서 제시한 3개의 값은 모두 다른 데이터 타입을 가지고 있다. 각각의 데이터 타입을 살펴보면2는 정수(integer)이며, 42.0은 소수(floating-point number), “Hello, World!”는 문자(string)이다. 위의 데이터 타입을 영어로 기재한 이유는 코드에서 영어의 축약으로 사용되기에 영어로 알아두는 것이 더 편리하기 때문이다.</p>
<p>만약에 해당 값이 어떤 데이터 타입인지 모르겠다면, REPL에 아래의 코드를 입력해보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; typeof(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">Int64</span></span><br><span class="line"></span><br><span class="line">julia&gt; typeof(<span class="number">42.0</span>)</span><br><span class="line"><span class="built_in">Float64</span></span><br><span class="line"></span><br><span class="line">julia&gt; typeof(<span class="string">"Hello, World!"</span>)</span><br><span class="line"><span class="built_in">String</span></span><br></pre></td></tr></table></figure>

<p>정수는 <code>int64</code>로 표시되며, 소수는 <code>float64</code>로 표현된다. 또한 문자의 경우는<code>string</code>로 표시된다.</p>
<p>그렇다면 값 “2”나 “42.0” 의 데이터 타입은 어떨까? 두 값은 숫자처럼 보이지만 인용구를 사용했기 때문에 문자로 인식된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; typeof(<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">String</span></span><br><span class="line"></span><br><span class="line">julia&gt; typeof(<span class="string">"42.0"</span>)</span><br><span class="line"><span class="built_in">String</span></span><br></pre></td></tr></table></figure>

<p>큰 정수를 값으로 사용할 때 자연스럽게 1,000,000와 같이 콤마를 넣어 수를 사용한다면, 줄리아에서는 이를 정수로 인식하지 못한다. 줄리아는 콤마를 연속된 정수들을 분리하는 기호로서 인식한다. 그렇기 때문에 만약 위와 같은 효과를 주고 싶다면 1_000_000 와 같이 언더바를 사용해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(<span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span>)</span><br><span class="line">ERROR: <span class="built_in">ArgumentError</span>: typeof: too many arguments (expected <span class="number">1</span>)</span><br><span class="line">Stacktrace:</span><br><span class="line"> [<span class="number">1</span>] top-level scope at none:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="number">1_000_000</span></span><br><span class="line"><span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">julia&gt; typeof(<span class="number">1_000_000</span>)</span><br><span class="line"><span class="built_in">Int64</span></span><br></pre></td></tr></table></figure>

<h3 id="형식-언어와-자연어"><a href="#형식-언어와-자연어" class="headerlink" title="형식 언어와 자연어"></a>형식 언어와 자연어</h3><p>자연어는 영어, 스페인어, 한국어와 같이 사람들이 사용하는 언어를 말한다. 이런 언어들은 특정 사람들로부터 인위적으로 발명된 것이 아니라 자연스럽게 진화된 형태이다.</p>
<p>형식 언어는 특정 필요에 의해서 사람들이 고안한 언어들을 의미한다. 예를 들어, 수학자들이 사용하는 표기법은 숫자와 기호 사이의 관계를 나타내는 데 적합한 형식 언어이며, 화학자들은 형식 언어를 사용하여 분자의 화학구조를 나타낸다. 이와 같이 프로그래밍 언어 또한 계산을 표현하도록 설계된 형식 언어이다.</p>
<p>형식 언어는 엄격한 문법을 가진다. 예를 들어서 3+3=6은 올바른 구문이지만, 3+=3$6은 올바르지 않다. 또한</p>
<p>문법은 크게 토큰과 구조로 구성되어 있는데, 토큰은 단어나 숫자, 화학 원소와 같은 언어의 기본 요소이며 구조는 토큰 간의 올바른 연결이 전제된 문장을 의미한다.</p>
<p>즉, 올바른 문법을 사용했는지 확인하려면,</p>
<p>적절한 토큰을 사용하였는가?</p>
<p>올바른 연결로 적절한 구조를 설정였는가?</p>
<p>위의 두 질문을 잊지 말자.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>프로그래머들은 실수를 하며, 각가지의 이유로 인해 버그(bug)라고 불리는 프로그래밍 에러가 발생한다. 이런 버그들을 추적하는 과정을 디버깅이라고 한다.</p>
<p>디버깅을 할 때 어려운 버그를 만난다면, 컴퓨터에 대한 분노로 인해 개발자를 그만두고 싶을 수 있다. 하지만 디버깅을 배우는 것은 어렵지만 프로그래밍 이외의 많은 활동에도 유용한 기술이기에 포기하지 않기를 바란다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hyeonji Ryu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">카테고리</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">태그</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hyeonji Ryu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
