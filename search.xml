<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>6. 신경망 구현 - 순전파</title>
    <url>/2020/04/04/Deeplearning-6/</url>
    <content><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.<br><a id="more"></a></p>
<h2 id="순전파란"><a href="#순전파란" class="headerlink" title="순전파란"></a>순전파란</h2>]]></content>
      <categories>
        <category>Deep learning with Julia</category>
      </categories>
      <tags>
        <tag>딥러닝</tag>
        <tag>머신러닝</tag>
        <tag>Deeplearning</tag>
        <tag>줄리아</tag>
        <tag>신경망</tag>
        <tag>순전파</tag>
      </tags>
  </entry>
  <entry>
    <title>5. 인공신경망 구현 - 수학식 풀이</title>
    <url>/2020/04/01/Deeplearning-5/</url>
    <content><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.<br><a id="more"></a></p>
<h2 id="인공신경망이란"><a href="#인공신경망이란" class="headerlink" title="인공신경망이란"></a>인공신경망이란</h2><script type="math/tex; mode=display">Layer=(X*W)+B</script><p>위 수식은 각 층을 계산하는 식이며, 입력 데이터의 값들인 배열 $X$에 가중치 $W$를 곱한 후 편향 $B$를 더한다. 이 식은 신경망이 작동하는 방식에서 가져온 알고리즘이다. 생물학에서의 신경망은 수많은 뉴런(신경 세포)이 연결되어 있으며, 이들은 전기 신호를 전달한다. 각각의 뉴런들은 수상돌기를 통해 들어오는 전기 신호를 받고 세포체에서 종합한 후 축삭돌기를 통해 전기 신호를 다른 뉴런으로 내보낸다. 이때 축삭돌기 끝 부분인 시냅스에서 전기 신호에 따라 신경전달물질을 분비하여 다른 뉴런의 시냅스로 전달하는데 이런 과정을 신경이라고 부르는 것이다.</p>
<p><img src="\../images/36.png" alt="신경 세포 구조"></p>
<p>그렇다면 뉴런들은 왜 전기 신호들을 전달하는 것일까? 이유는 간단하다. 우리 몸에서 필요한 생활 기능들을 ‘적절’하게 조절하기 위해서이다. 뉴런은 수상돌기에서 전기 신호를 생산하라는 흥분성 신호와 전기 신호를 생산하지 말라는 억제성 신호를 받아들인다. 그후 세포체에서 이를 종합하여 다른 뉴런으로 해당 전기 신호를 보낼지 말지 결정한다. 이런 뉴런의 원리를 바탕으로 살펴봤을 때 가중치를 곱하는 것은 뉴런에서 각각의 고유한 흥분성과 억제성 신호를 받아들이는 과정을 표현했다고 볼 수 있다.<br>물론 실제 생물학에서의 뉴런은 세포체에서 전기 신호를 보내거나(1), 보내지 않거나(0)라는 계단 함수의 개념으로 작동한다는 차이점이 있지만, 가중치의 원리는 동일하다. 또한 편향은 뉴런이 가지고 있는 ‘임계값’을 표현한 것이다. 세포체는 받은 전기 신호가 어느 임계값 이상이 되어야 전기 신호를 내보내는 데, 이를 나타낸 것이다.</p>
<p>따라서 인공신경망의 원리를 한번에 설명한다면, 입력 신호에 가중치를 곱하면서 적절한 전기 신호로 변환하여 받은 후, 편향(임계값)이 넘으면 전기 신호를 출력한다고 정리된다. 4층으로 구성된 인공신경망 계산 과정을 도식화하면 다음과 같다.</p>
<p><img src="\../images/37.png" alt="인공신경망 계산 과정"></p>
<h2 id="인공신경망-수학식-풀이"><a href="#인공신경망-수학식-풀이" class="headerlink" title="인공신경망 수학식 풀이"></a>인공신경망 수학식 풀이</h2><p>인공신경망을 코드로 구현하기에 앞서 수학식으로 풀이해보려고 한다. 이 과정이 필요한 이유는 컴퓨터가 신경망 모델을 어떻게 진행하는지 명확히 파악하고, 이해해야 하기 때문이다. 따라서 위의 인공신경망 도식을 수식으로 풀이해보자. (참고로 위의 인공신경망 도식은 4층 신경망이다.)</p>
<script type="math/tex; mode=display">X:
\begin{bmatrix}
 x_1 & x_2 \\
 \end{bmatrix}\quad
W_1:
\begin{bmatrix}
 w1_{11} & w1_{12} \\
 w1_{21} & w1_{22} \\
 \end{bmatrix}\quad
W_2:
\begin{bmatrix}
 w2_{11} & w2_{12} & w2_{13}\\
 w2_{21} & w2_{22} & w2_{23}\\
 \end{bmatrix}</script><script type="math/tex; mode=display">B_1:
\begin{bmatrix}
b1_1 & b1_2
 \end{bmatrix}\quad
 B_2:
\begin{bmatrix}
 b2_1 & b2_2 & b2_3
 \end{bmatrix}</script><p>먼저 입력값인 $X$와 가중치 $W_1, W_2$, 편향 $b_1, b_2$를 설정한다. 예시이기 때문에 입력층, 은닉층, 출력층의 노드 개수를 임의로 설정하였다. (실제로는 훨씬 많은 노드들이 사용된다.)</p>
<script type="math/tex; mode=display">Z1 = XW_1+B_1</script><script type="math/tex; mode=display">Z1=
\begin{bmatrix}
 x_1 & x_2 \\
 \end{bmatrix}
\times
\begin{bmatrix}
 w1_{11} & w1_{12} \\
 w1_{21} & w1_{22} \\
 \end{bmatrix}
+
\begin{bmatrix}
b1_1 & b1_2
 \end{bmatrix}\\</script><script type="math/tex; mode=display">=
\begin{bmatrix}
x_1w1_{11}+x_2w1_{21}+b1_1 & x_1w1_{12}+x_2w1_{22}+b1_2
\end{bmatrix}</script><p>먼저 입력값에 첫 번째 가중치인 $W_1$을 곱하고 첫 번째 편향인 $B_1$ 더한다. 입력값과 가중치, 편향 모두 배열이기에 이 계산은 배열 단위로 이루어진다. 즉, 행렬곱과 행렬덧셈이 사용되는 것이다. 이 과정은 입력값이 첫 번째 활성화 함수 $h(x)$로 넘어가기 전에 이루어진다.</p>
<script type="math/tex; mode=display">A1 = \cfrac{1}{1+e^{-Z1}}</script><script type="math/tex; mode=display">A1 =
\begin{bmatrix}
\cfrac{1}{1+e^{-Z1_1}} & \cfrac{1}{1+e^{-Z1_2}}
\end{bmatrix}</script><p>그 다음, 위의 $Z_1$을 활성화 함수에 대입하면 된다. 여기서 $Z_1$은 행렬인데 위의 수식을 $Z_1$의 요소에 각각 적용한다. 참고로 위 식에서 사용된 활성화 함수는 시그모이드 함수이다. 이 과정은 입력값이 첫 번째 은닉층에 도착한 것이다.</p>
<script type="math/tex; mode=display">Z2 = \bigg(\cfrac{1}{1+e^{-Z1)}}\bigg)\times W_2+b_2</script><script type="math/tex; mode=display">=
\begin{bmatrix}
\frac{w2_{11}}{1+e^{-Z1_1}}+\frac{w2_{21}}{1+e^{-Z1_2}}+b2_1 & \frac{w2_{12}}{1+e^{-Z1_1}}+\frac{w2_{22}}{1+e^{-Z1_2}}+b2_2 & \frac{w2_{13}}{1+e^{-Z1_1}}+\frac{w2_{23}}{1+e^{-Z1_2}}+b2_3
\end{bmatrix}</script><p>$A1$의 값은 행렬로 반환된다. $A1$을 다시 두 번째 은닉층으로 보내기 위해 두 번째 가중치인 $W_2$를 곱하고 두 번째 편향인 $b_2$를 더한다. 여기서도 행렬곱과 행렬덧셈이 사용된다. 행렬 단위로 계산되는 수식은 $Z1$과 동일하다.</p>
<script type="math/tex; mode=display">A2 = \cfrac{1}{1+e^{-Z2}}</script><script type="math/tex; mode=display">A2 =
\begin{bmatrix}
\cfrac{1}{1+e^{-Z2_1}} & \cfrac{1}{1+e^{-Z2_2}} & \cfrac{1}{1+e^{-Z2_3}}
\end{bmatrix}</script><p>두 번째 은닉층을 계산해야 한다. 가중치와 편향을 계산한 입력값을 다시 활성화 함수에 변수로 대입한다. 두 번째 은닉층의 활성화 함수도 시그모이드 함수를 사용하였다. 행렬 단위로 적용되는 수식은 $A1$과 동일하다.</p>
<script type="math/tex; mode=display">\hat{y_k}=\cfrac{e^{a_k}}{\sum_{i=1}^n e^{a_i}}</script><script type="math/tex; mode=display">\hat{y}=
\begin{bmatrix}
\cfrac{e^{A2_1}}{\sum_{i=1}^3 e^{A2_i}} & \cfrac{e^{A2_2}}{\sum_{i=1}^3 e^{A2_i}} & \cfrac{e^{A2_3}}{\sum_{i=1}^3 e^{A2_i}}
\end{bmatrix}</script><p>은닉층 계산 이후 마지막으로 출력층 활성화 함수인 소프트맥스 함수를 적용하여 예측값 $\hat{y}$을 얻었다.</p>
<p>위의 식을 토대로 우리는 예측값을 아래와 같은 식로 정의할 수 있다.</p>
<script type="math/tex; mode=display">\hat{y}=\sigma(h(h(XW_1+B_1)\times W_2+B_2))</script><p>위의 식을 살펴보면 $Z1$인 $XW_1+B_1$을 활성화 함수 $h(x)$에 대입하고, 활성화 함수의 결과 값을 다시 $Z2$의 입력값으로 받는다. 그렇게 $Z2$를 계산한 후 이를 다시 활성화 함수 $h(x)$에 대입한다. 그리고 마지막으로 출력층의 활성화 함수인 $\sigma(x)$에 대입하여 나온 값이 예측값 $\hat{y}$이다.</p>
<h2 id="인공신경망-학습-과정-수학식-풀이"><a href="#인공신경망-학습-과정-수학식-풀이" class="headerlink" title="인공신경망 학습 과정 수학식 풀이"></a>인공신경망 학습 과정 수학식 풀이</h2><p>위에서는 하나의 신경망을 예시로 들어 신경망이 어떻게 작동하는지 수학식으로 정리하였다. 지금부터는 인공신경망을 학습하는 과정이 어떻게 진행되는지 수학식으로 정리할 것이다. 인공신경망은 실제 사용되기 전에 훈련 데이터셋을 통해 학습시킨다. 여기서 ‘학습’이란 뜻은 신경망에 적절한 가중치와 편향을 찾는 과정을 의미한다. 우리는 <a href="https://hyeonji-ryu.github.io/2020/03/31/Deeplearning-4/#more">이전 글</a>에서 신경망 학습 알고리즘 중 하나인 경사하강법을 살펴보았다. 따라서 지금부터 경사하강법 알고리즘을 사용하여 위에서 풀이한 신경망 모델을 학습하는 과정을 수학식으로 풀이해보고자 한다.</p>
<ol>
<li>먼저 학습을 하기 위해서는 학습 때 사용할 훈련 데이터셋과 무작위 값으로 구성된 가중치, 편향이 필요하다. 이를 준비한 후 예측값을 도출한다.</li>
</ol>
<script type="math/tex; mode=display">\hat{y}=\sigma(h(h(XW_1+B_1)\times W_2+B_2))</script><ol>
<li>도출된 예측값과 정답을 비교해야 한다. 손실 함수를 사용하여 오차값을 구한다. 이 예시에서는 손실 함수 중 하나인 ‘평균 제곱 오차’를 사용할 것이다.</li>
</ol>
<script type="math/tex; mode=display">E=\frac{1}{n}\sum_{i=1}^n (\hat{y}-t_i)^2</script><ol>
<li>기존의 오차값을 확인한 후, 오차값을 줄이기 위해 경사하강법 알고리즘을 사용한다. 경사하강법 알고리즘은 손실함수와 각각의 가중치와 편향들을 편미분하여 기울기를 구한 후, 기존의 가중치와 편향을 갱신하였다. 그렇다면 위의 손실함수 수식을 해체해야 한다. 가중치와 편향을 기준으로 편미분하기 위해서는 손실함수의 식에서 $W$와 $B$를 찾아야 하기 때문이다. 가중치와 편향이 배열인 경우에는 편미분이 각각의 요소 단위로 진행된다. 아래의 배열은 손실함수와 가중치가 어떻게 편미분이 진행되는지 예시를 보여준다.</li>
</ol>
<script type="math/tex; mode=display">\frac{\partial E}{\partial W} =
\begin{bmatrix}
 \frac{\partial E}{\partial w_{11}} & \frac{\partial E}{\partial w_{12}} & \frac{\partial E}{\partial w_{13}}\\
 \frac{\partial E}{\partial w_{21}} & \frac{\partial E}{\partial w_{22}} & \frac{\partial E}{\partial w_{23}}\\
 \end{bmatrix}</script><p>지금부터 아래의 식에 사용되는 $w<em>{ij}$와 $b</em>{ij}$는 배열 형태인 $W$와 $B$의 요소라는 점을 강조한다.</p>
<script type="math/tex; mode=display">E = \frac{1}{n}\sum_{i=1}^n (\hat{y}-t_i)^2 \\
= \frac{1}{n}\sum_{i=1}^n (\hat{y}^2 + 2\hat{y}t_i + t_i^2)\\
= \frac{1}{n}\sum_{i=1}^n \{(\sigma(h(h(XW_1+B_1)\times W_2+B_2)))^2 + 2\times (\sigma(h(h(XW_1+B_1)\times W_2+B_2)))\times t_i + t_i^2\}</script><p>위의 식에서 $\hat{y}$는 여러 활성화 함수들의 합성 함수로 구성되어 있다. 보기만 해도 복잡하고 머리가 아프다. 하지만 이 식 안에서 $w<em>{ij}$, $b</em>{ij}$와 같은 값들을 도출해야 한다. 하나의 요소를 정해서 식을 해체하는 방법이 더 빠를 것 같기에 우리는 W1_{11}와 손실함수의 편미분 값을 찾아보자.</p>
<p>목표: $\frac{\partial E}{\partial W1_{11}}$을 식으로 풀이하기</p>
]]></content>
      <categories>
        <category>Deep learning with Julia</category>
      </categories>
      <tags>
        <tag>딥러닝</tag>
        <tag>머신러닝</tag>
        <tag>Deeplearning</tag>
        <tag>줄리아</tag>
        <tag>신경망</tag>
        <tag>순전파</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 경사하강법</title>
    <url>/2020/03/31/Deeplearning-4/</url>
    <content><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.<br><a id="more"></a></p>
<p>앞 포스팅에서 우리는 손실 함수에 대해서 살펴보았다. 손실 함수는 신경망을 평가하는 판단지표로서 사용되며, 손실 함수의 값을 줄이는 방향으로 신경망을 학습시킨다고 하였다. 다른 말로, 좋은 신경망 모델은 손실 함수 값이 작아야 한다. 그렇다면 이쯤에서 “어떻게 손실 함수의 값을 줄일 수 있을까?”라는 의문이 들 것이다. 이것이 바로 최적화의 문제이다. 이번 글에서는 손실 함수를 최소화하는 경사하강법에 대해서 살펴볼 것이다.</p>
<h2 id="경사하강법이란"><a href="#경사하강법이란" class="headerlink" title="경사하강법이란"></a>경사하강법이란</h2><p>경사하강법은 신경망 학습에서 손실함수의 값을 최소화하는 가중치와 편향을 찾는 최적화 알고리즘이다. 신경망 모델의 학습 과정을 순서대로 나열하면 다음과 같다.</p>
<ol>
<li>임의의 값을 가진 가중치와 편향을 생성한다.</li>
<li>신경망 계산을 한다.</li>
<li>손실 함수로 출력층의 결과인 예측값과 정답을 비교한다.</li>
<li>예측값과 정답의 격차를 줄이기 위해 가중치와 편향을 조정한다.</li>
<li>2~4의 과정을 반복하여 손실 함수의 값을 줄인다.</li>
</ol>
<p>위의 순서 중에서 경사하강법은 4, 5번 과정을 진행하는 알고리즘이다. 그렇다면 경사하강법의 작동 원리는 무엇인가? 바로 미분이다. 경사하강법은 손실 함수의 미분값(기울기)을 도출하여 가중치와 편향에서 빼주는 방식으로 적절한 가중치와 편향을 찾는다.</p>
<h2 id="미분"><a href="#미분" class="headerlink" title="미분"></a>미분</h2><p>최소화된 가중치와 미분을 찾는 방법은 바로 손실 함수 수식의 “기울기”이다. 손실 함수 그래프에서 가장 아래에 있는 점을 찾기 위해서는 임의의 점에서 기울기를 구해 이동할 방향을 잡아야 한다. 그렇다면 기울기를 구하는 방법은 무엇인가? 바로 미분이다.</p>
<p>미분은 순간변화량을 나타내며, 수식은 다음과 같다.</p>
<script type="math/tex; mode=display">f'(x)=\frac{df(x)}{dx}=\lim_{h\to0} \frac{f(x+h)-f(x)}{h}</script><p>위 수식은 $f(x)$에서 $x$가 아주 작은 값인 $h$만큼 이동했을 때의 변화량을 구하는 식이며, 이는 $x$의 이동이 $f(x)$를 얼마나 변화시키는지를 나타낸다.</p>
<p>하지만 위의 식을 컴퓨터에서 구현하는 것은 반올림오차 문제때문에 기술적으로 어렵다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; h = <span class="number">1e-50</span></span><br><span class="line">Julia&gt; x = <span class="number">3</span></span><br><span class="line">Julia&gt; f(x) = x^<span class="number">2</span></span><br><span class="line">Julia&gt; (f(x+h) - f(x)) / h</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p>수학적 원리로는 아주 미세한 값의 차이가 나지만, 컴퓨터는 이를 0으로 처리해버린다. 이런 문제로 보통 $h$의 값을 $10^{-4}$로 사용한다. 또한 위의 코드는 $(x+h)$와 $x$사이의 기울기이기에 약간의 오차가 발생한다. 이런 오차를 줄이기 위해서 사용하는 방식이 <strong>중앙 차분</strong>이다.</p>
<script type="math/tex; mode=display">f'(x)=\frac{dy}{dx}=\lim_{h\to0} \frac{f(x+h)-f(x-h)}{2h}</script><p>중앙 차분이란 $f(x+h)$에서 $f(x-h)$의 값을 뺀 후 $2h$로 나누는데, 이는 $(x+h)$와 $(x-h)$ 사이의 기울기를 구함으로써 보다 정확한 값을 얻을 수 있다. 아래의 코드는 기존의 미분 공식과 중앙차분을 적용한 값의 비교이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; (f(x+h) - f(x))/ h</span><br><span class="line"><span class="number">6.000100000012053</span></span><br><span class="line">Julia&gt; (f(x+h) - f(x-h))/ <span class="number">2</span>h</span><br><span class="line"><span class="number">6.000000000012661</span></span><br></pre></td></tr></table></figure>
<p>$f(x)=x^2$이기 때문에 이를 미분하면 $f’(x)=2x$이다. 즉, $x$가 3일 때 $f’(x)$는 6인 것이다. 이를 바탕으로 위의 코드를 보면 약간의 차이로 중앙 차분이 적용된 미분 공식이 6에 가까운 것을 확인할 수 있다.</p>
<p>위의 미분 공식으로 코드로 구현하면 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> derivative(f,x)</span><br><span class="line">    h=<span class="number">10</span>^-<span class="number">4</span></span><br><span class="line">    <span class="keyword">return</span> (f(x+h)-f(x-h))/<span class="number">2</span>h</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="편미분"><a href="#편미분" class="headerlink" title="편미분"></a>편미분</h2><p>미분 파트에서는 $f(x)=x^2$과 같은 변수가 1개인 경우만을 살펴보았다. 하지만 대부분의 손실 함수들은 신경망 디자인에 따라서 변수의 개수가 변동하는 다변수 함수이다. 따라서 실제 사용되는 손실 함수들을 미분해야 하며, 그 방법을 편미분이라고 한다.</p>
<p>편미분이란 변수가 2개 이상인 수식에서 각각의 변수들을 기준으로 미분하는 것을 말한다. 다음 식을 편미분해보자.</p>
<script type="math/tex; mode=display">f(x,y)=x^2+2xy+y^2</script><p>위 식에서 편미분 $\frac{\partial f}{\partial x}$ 와 $\frac{\partial f}{\partial y}$를 수식으로 나타내면 아래와 같다.</p>
<p>$\frac{\partial f}{\partial x} = 2x+2y$</p>
<p>$\frac{\partial f}{\partial y} = 2y+2x$</p>
<p>편미분은 각각의 변수를 기준으로 하여 나머지 변수는 상수화하여 미분을 진행하면 된다. 위에서 편미분 $\frac{\partial f}{\partial x}$은 $x$만을 변수로 하고 $y$를 상수화 하였으며, 편미분 $\frac{\partial f}{\partial y}$은 $y$만을 변수로 하여 $x$을 상수화하였다.</p>
<p>위의 수식들을 코드로 구현해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; x = <span class="number">5</span></span><br><span class="line">Julia&gt; y = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>먼저 필요한 변수들을 임의로 정의한다. 편미분 $\frac{\partial f}{\partial x}$부터 비교하면 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; f(x) = x^<span class="number">2</span>+<span class="number">2</span>*x*y+y^<span class="number">2</span></span><br><span class="line">Julia&gt; derivative(f,x)       <span class="comment"># 미분 함수 사용</span></span><br><span class="line"><span class="number">25.999999999868347</span></span><br><span class="line">Julia&gt; <span class="number">2</span>*x+<span class="number">2</span>*y               <span class="comment"># 편미분 수식 직접 입력</span></span><br><span class="line"><span class="number">26</span></span><br></pre></td></tr></table></figure>
<p>코드 결과에서 두 개의 미분 값이 거의 유사함을 확인할 수 있다. 다음으로 편향을 기준으로 하는 편미분 $\frac{\partial f}{\partial y}$도 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; f(y) = x^<span class="number">2</span>+<span class="number">2</span>*x*y+y^<span class="number">2</span></span><br><span class="line">Julia&gt; derivative(f,y)      <span class="comment"># 미분 함수 사용</span></span><br><span class="line"><span class="number">25.999999999868347</span></span><br><span class="line">Julia&gt; <span class="number">2</span>*y+<span class="number">2</span>*x        <span class="comment"># 편미분 수식 직접 입력</span></span><br><span class="line"><span class="number">26</span></span><br></pre></td></tr></table></figure>
<h2 id="기울기"><a href="#기울기" class="headerlink" title="기울기"></a>기울기</h2><p>지금까지 우리는 경사하강법에서 사용되는 미분에 대해 알아보았다. 손실 함수는 보통 변수가 2개 이상이기 때문에 편미분을 통해 각각의 변수 값들을 구하며, 이전 파트에서 변수 하나씩의 값을 구하였다. 하지만 실제 신경망에서 작동하는 기울기(미분값)은 한번에 도출되어야 한다. 따라서 다변수 함수를 한번에 미분해주는 코드를 구현하고자 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> numerical_gradient(f, x)</span><br><span class="line">    h=<span class="number">10</span>^-<span class="number">4</span></span><br><span class="line">    grad=zeros(<span class="number">1</span>,length(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>:length(x))</span><br><span class="line">        origin=x[i]</span><br><span class="line">        x[i]+=h</span><br><span class="line">        fx1=f(x)</span><br><span class="line">        x[i]-=<span class="number">2</span>*h</span><br><span class="line">        fx2=f(x)</span><br><span class="line">        grad[i]=(fx1-fx2)/<span class="number">2</span>h</span><br><span class="line">        x[i]=origin</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span>  grad</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이제 위의 예시를 다시 사용하여 값이 잘 도출되는지 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; g = [<span class="number">5.0</span> <span class="number">8.0</span>]   <span class="comment"># 다변수</span></span><br><span class="line">Julia&gt; f(g) = g[<span class="number">1</span>]^<span class="number">2</span>+<span class="number">2</span>*g[<span class="number">1</span>]*g[<span class="number">2</span>]+g[<span class="number">2</span>]^<span class="number">2</span> <span class="comment"># 함수 수식</span></span><br></pre></td></tr></table></figure>
<p>편미분 파트의 예시와는 다르게 두 개의 변수를 한번에 계산하기 위해 배열화하였다. 또한 함수 수식에서 각 변수들의 기호를 배열 <code>g</code>의 인덱스로 변경하였다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; numerical_gradient(f, g)</span><br><span class="line"><span class="number">1</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"><span class="number">26.0</span>  <span class="number">26.0</span></span><br></pre></td></tr></table></figure>
<p>각자 편미분한 값과 같은 결과가 출력된다.</p>
<h3 id="경사하강법"><a href="#경사하강법" class="headerlink" title="경사하강법"></a>경사하강법</h3><p>이제 기울기를 통해 변수들을 최적화하는 알고리즘인 경사하강법을 살펴볼 것이다. ‘경사하강법(gradient_descent)’은 함수의 미분을 통해 얻은 기울기를 사용해 기존 변수 값을 갱신하여 오차를 점점 줄여나가는 알고리즘이다. 먼저 경사하강법의 수식을 살펴보자.</p>
<script type="math/tex; mode=display">W=W-\eta \frac{\partial f}{\partial W}</script><script type="math/tex; mode=display">B=B-\eta \frac{\partial f}{\partial B}</script><p>위 식에서 기호 $\eta$는 학습률을 나타낸다. <strong>학습률(learning rate)</strong>이란 기울기를 어느 정도 반영할 것인가를 나타낸다. 보통 학습률은 미리 정하며, $0.01$이나 $0.001$ 등을 사용한다. 위의 수식을 한 문장으로 정리한다면 다음과 같다.</p>
<p>“이전 변수에서 학습률을 곱한 기울기(편미분)를 뺀 결과가 새로운 변수이며, 이를 여러 번 반복하여 오차를 0으로 만드는 적절한 변수를 반한한다.”</p>
<p>경사하강법의 코드는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> gradient_descent(f,x,lr,step_num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:step_num</span><br><span class="line">        grad = numerical_gradient(f, x)</span><br><span class="line">        x -= grad.*lr</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위 코드는 매개 변수로 함수 공식인 <code>f</code>, 변수의 초기 값인 <code>x</code>, 학습률인 <code>lr</code>,반복 횟수인 <code>step_num</code>을 받는다. 이제 위에서 사용했던 예시를 가지고 경사하강법을 실행해보자. 신경망 학습에서 경사하강법 결과에 대한 이해는 필수적이기에 이번 예시는 신경망에서의 경사하강법이라고 전제하고 설명할 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; g = [<span class="number">5.0</span> <span class="number">8.0</span>]   <span class="comment"># 다변수 (가중치 또는 편향)</span></span><br><span class="line">Julia&gt; f(g) = g[<span class="number">1</span>]^<span class="number">2</span>+<span class="number">2</span>*g[<span class="number">1</span>]*g[<span class="number">2</span>]+g[<span class="number">2</span>]^<span class="number">2</span> <span class="comment"># 함수 수식 (손실 함수)</span></span><br></pre></td></tr></table></figure>
<p>위의 식을 바탕으로 오차를 계산하면 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; f(g)</span><br><span class="line"><span class="number">169.0</span></span><br></pre></td></tr></table></figure>
<p>오차가 <code>169</code>로 도출되었다. 손실 함수의 값이 매우 큰 상태이다. 즉, 아주 좋지 못한 신경망이다. 이제 경사하강법으로 최적화된 가중치와 편향을 찾아보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; gradient_descent(f,g,<span class="number">0.01</span>,<span class="number">100</span>)</span><br><span class="line"><span class="number">1</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line">-<span class="number">1.39034</span>  <span class="number">1.60966</span></span><br></pre></td></tr></table></figure>
<p>경사하강법의 결과가 나왔다. 확실히 $5$과 $8$보다는 매우 작은 값이 출력되었다. 손실 함수 수식에 해당 결과를 대입함으로써 정말 최적화된 값인지 확인해보고자 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; g = [-<span class="number">1.39034</span>  <span class="number">1.60966</span>]</span><br><span class="line"><span class="number">1</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> -<span class="number">1.39034</span>  <span class="number">1.60966</span></span><br><span class="line"></span><br><span class="line">Julia&gt; f(g)</span><br><span class="line"><span class="number">0.0481012623999999</span></span><br></pre></td></tr></table></figure>
<p>오차값이 거의 0에 도달하였다. 최적화에 성공한 것이다. 신경망은 이런 경사하강법을 통해서 적절한 가중치와 편향을 찾는다. 이제는 신경망을 구현하기 위한 모든 재료들을 살펴보았다. 다음 포스트에서는 지금까지 만들었던 함수들을 바탕으로 신경망을 직접 구현해보자.</p>
]]></content>
      <categories>
        <category>Deep learning with Julia</category>
      </categories>
      <tags>
        <tag>딥러닝</tag>
        <tag>머신러닝</tag>
        <tag>Deeplearning</tag>
        <tag>경사하강법</tag>
        <tag>미분</tag>
        <tag>편미분</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 손실 함수</title>
    <url>/2020/03/30/Deeplearning-3/</url>
    <content><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.<br><a id="more"></a></p>
<h2 id="손실-함수란"><a href="#손실-함수란" class="headerlink" title="손실 함수란"></a>손실 함수란</h2><p>신경망을 사용하기 위해서는 그 전에 학습을 통해 올바른 기준을 생성해주어야 한다. 이런 과정을 ‘신경망 학습’이라고 한다. 신경망 학습에서는 훈련 데이터를 사용하며, 이를 통해 신경망이 실전 문제에서도 적절하게 접근할 수 있도록 하는 가중치를 찾는다. 그렇다면 신경망 학습이 잘 이루어지고 있는지 어떻게 알 수 있을까? 여기서 ‘손실 함수’가 사용된다. 손실 함수(loss function)는 신경망을 평가하는 평가지표로서 사용되며, 오답률을 나타낸다. 즉, 손실 함수의 값이 0에 가까울수록 좋은 신경망이라는 것이다. 보통 손실 함수는 정답과 신경망이 도출한 출력 값을 비교하여 나타낸다.</p>
<p>일반적으로 사용하는 손실 함수로는 평균 제곱 오차와 교차 엔트로피 오차가 있다.</p>
<h3 id="평균-제곱-오차"><a href="#평균-제곱-오차" class="headerlink" title="평균 제곱 오차"></a>평균 제곱 오차</h3><p>‘평균 제곱 오차(Mean Squared Error, MSE)’는 출력 값에서 정답을 뺀 결과를 제곱하여 더한 값들을 비교한다. 수식은 아래와 같다.</p>
<script type="math/tex; mode=display">E=\frac{1}{n}\sum_{i=1}^n (y_i-t_i)^2</script><p>위의 수식에서 $y_i$는 출력 값, $t_i$는 정답이며 $n$은 원소의 개수이다. 출력 값에서 정답을 뺀 오차를 제곱하여 $n$으로 나눠줌으로써 평균을 손실 함수의 값으로 제공한다.</p>
<p>위의 수식을 코드로 구현하면 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> mean_squared_error(y,t)</span><br><span class="line">    error = (y-t).^<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> sum(error) / length(y)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>좀 더 정확한 이해를 위해 예시를 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; t = [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="comment"># 정답 레이블</span></span><br><span class="line">Julia&gt; y1 = [<span class="number">0.1</span> <span class="number">0.05</span> <span class="number">0.6</span> <span class="number">0.0</span> <span class="number">0.05</span> <span class="number">0.1</span> <span class="number">0.0</span> <span class="number">0.1</span> <span class="number">0.0</span> <span class="number">0.0</span>] <span class="comment"># 출력 값 with 정답</span></span><br><span class="line">Julia&gt; y2 = [<span class="number">0.1</span> <span class="number">0.05</span> <span class="number">0.1</span> <span class="number">0.0</span> <span class="number">0.05</span> <span class="number">0.1</span> <span class="number">0.0</span> <span class="number">0.6</span> <span class="number">0.0</span> <span class="number">0.0</span>] <span class="comment"># 출력 값 with 오답</span></span><br></pre></td></tr></table></figure>
<p>먼저 정답 배열인 <code>t</code>와 출력 배열인 <code>y1</code>, <code>y2</code>를 세팅해준다. 해당 예시는 예측값이며 <code>y1</code>, <code>y2</code>는 소프트맥스 함수의 결과이다. <code>y1</code>은 정답을 맞춘 출력 값이고, <code>y2</code>는 오답인 출력 값이다. 그렇다면 출력 값 <code>y1</code>, <code>y2</code>을 사용하여 오차 값을 구해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; mean_squared_error(y1,t)</span><br><span class="line"><span class="number">0.019500000000000007</span></span><br><span class="line"></span><br><span class="line">Julia&gt; mean_squared_error(y2,t)</span><br><span class="line"><span class="number">0.11949999999999998</span></span><br></pre></td></tr></table></figure>
<p>정답에 높은 확률을 할당한 결과 값 <code>y1</code>은 오차로 $0.0195$이며, 오답에 높은 확률을 할당한 결과 값 <code>y2</code>는 오차로 $0.1194$가 나왔다. 즉, <code>y1</code>이 <code>y2</code>보다 더 잘 예측했음을 알 수 있다.</p>
<h3 id="교차-엔트로피-오차"><a href="#교차-엔트로피-오차" class="headerlink" title="교차 엔트로피 오차"></a>교차 엔트로피 오차</h3><p>‘교차 엔트로피 오차(Cross Entropy Error, CEE)’는 자연로그를 이용한 함수이다. 수식은 아래와 같다.</p>
<script type="math/tex; mode=display">E=-\sum_{i=1}^n (t_i\times\ln y_i)</script><p>위의 식은 정답 레이블 <code>t</code>와 출력 값을 곱한다. 여기서 정답 레이블은 오답과 정답을 <code>0</code>과 <code>1</code>로 표현한 것이기 때문에 오답인 경우는 출력 값과 <code>0</code>이 곱해진다. 즉, 정답 위치와 같은 출력 값만 자연로그 값이 제공되며 나머지는 $0$으로 반환된다. 위의 수식에서는 2가지의 의문이 제기될 수 있다.</p>
<p>첫 번째 의문은 “하나의 값을 제외한 나머지가 0임에도 불구하고 왜 $\sum$(시그마)를 사용하는가?”이다. 그 이유는 배열을 하나의 값으로 반환하기 위해서이다. $t_i*\ln y_i$식을 계산하면 아래와 같은 결과가 도출된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; delta = <span class="number">1e-7</span></span><br><span class="line">Julia&gt; -log.(y1.+ delta).* t</span><br><span class="line"><span class="number">1</span>×<span class="number">10</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.510825</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p>이 결과에서 0이 아닌 값만 도출하는 것은 쉬워보이지만, 정답 레이블에서 1의 위치가 계속 변하기 때문에 기술적으로 복잡하다. 그렇기 때문에 하나의 값을 도출하기 위해서 모두 더한 것이다. 한 값을 제외하고 전부 0이기 때문에 이는 배열에서 스칼라로 변한 것뿐 수학적인 문제는 없다.</p>
<p>두 번째 의문은 “왜 자연로그를 이용하는가?”이다. 먼저 자연로그 그래프를 살펴보자.</p>
<p><img src="/images/35.png" alt="자연로그"></p>
<p>위의 그래프에서는 $x$축이 1일 때 $y$축이 0이며, $x$축이 1 미만일 때에는 $-e$에 가까운 값으로 향한다. 즉, 0부터 1 사이의 수들은 전부 음수로 반환되는 것이다. 이런 원리를 이용하여 정답레이블 1에 위치한 소프트맥스 함수의 확률 값이 1에 가까울수록 작은 수로 변환되며, 이를 통해서 판단지표의 역할을 하는 것이다. 음수로 나오는 결과를 양수로 변환하기 위해서 $log$ 앞에 $-$ 를 곱한다.</p>
<p>해당 수식을 코드로 구현하면 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> cross_entropy_error(y, t)</span><br><span class="line">    delta = <span class="number">1e-7</span></span><br><span class="line">    <span class="keyword">return</span> -sum(log.(y.+ delta)).* t</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 정의에서 <code>delta</code> 또한 기술적인 이유로 포함되었다. 그래프에서도 확인할 수 있듯이 자연로그는 $x$축이 0인 경우의 $y$값이 마이너스 무한대이다. 따라서 $log_e 0$은 <code>-inf</code>이기 때문에 계산 오류가 바로 발생한다. 이를 막기 위해 아주 작은 값인 $1e-7$을 더해주는 것이다. $1e-7$은 지수 표기법으로 $0.0000001$을 의미한다.</p>
<p>지금부터 예시에 교차 엔트로피 오차를 적용해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; t = [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="comment"># 정답 레이블</span></span><br><span class="line">Julia&gt; y1 = [<span class="number">0.1</span> <span class="number">0.05</span> <span class="number">0.6</span> <span class="number">0.0</span> <span class="number">0.05</span> <span class="number">0.1</span> <span class="number">0.0</span> <span class="number">0.1</span> <span class="number">0.0</span> <span class="number">0.0</span>] <span class="comment"># 출력 값 with 정답</span></span><br><span class="line">Julia&gt; y2 = [<span class="number">0.1</span> <span class="number">0.05</span> <span class="number">0.1</span> <span class="number">0.0</span> <span class="number">0.05</span> <span class="number">0.1</span> <span class="number">0.0</span> <span class="number">0.6</span> <span class="number">0.0</span> <span class="number">0.0</span>] <span class="comment"># 출력 값 with 오답</span></span><br></pre></td></tr></table></figure>
<p>예시 데이터셋은 평균 제곱 오차에서 사용했던 것을 그대로 사용할 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; cross_entropy_error(y1,t)</span><br><span class="line"><span class="number">0.510825457099338</span></span><br><span class="line"></span><br><span class="line">Julia&gt; cross_entropy_error(y2,t)</span><br><span class="line"><span class="number">2.302584092994546</span></span><br></pre></td></tr></table></figure>
<p>위의 결과를 보면 잘 예측한 <code>y1</code>이 잘못 예측한 <code>y2</code>보다 더 작은 것을 확인할 수 있다. 이처럼 손실 함수는 오차를 계산하여 오차율을 나타내며, 값이 0에 가까울수록 오차가 없다고 판단한다. 즉, 손실 함수의 값이 0에 가까울수록 해당 신경망은 잘 학습되었다고 평가되는 것이다.</p>
]]></content>
      <categories>
        <category>Deep learning with Julia</category>
      </categories>
      <tags>
        <tag>딥러닝</tag>
        <tag>머신러닝</tag>
        <tag>Deeplearning</tag>
        <tag>줄리아</tag>
        <tag>loss</tag>
        <tag>손실함수</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 활성화 함수</title>
    <url>/2020/03/29/Deeplearning-2/</url>
    <content><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.<br><a id="more"></a></p>
<h2 id="활성화-함수"><a href="#활성화-함수" class="headerlink" title="활성화 함수"></a>활성화 함수</h2><p>활성화 함수란 신경망 노드에 위치해 있는 함수로서 입력값들을 출력 신호의 여부로 변환해주는 함수이다. 보통 은닉층에서 사용하는 활성화 함수와 출력층에서 사용하는 활성화 함수로 나눠져 있으며, $h(x)$로 표기한다.</p>
<h3 id="은닉층에서-사용하는-활성화-함수"><a href="#은닉층에서-사용하는-활성화-함수" class="headerlink" title="은닉층에서 사용하는 활성화 함수"></a>은닉층에서 사용하는 활성화 함수</h3><p>은닉층에서 사용되는 기본적인 활성화 함수로는 3가지 정도가 있다.</p>
<h4 id="계단-함수"><a href="#계단-함수" class="headerlink" title="계단 함수"></a>계단 함수</h4><p>계단 함수는 입력값이 $0$이하이면 $0$, $0$을 초과하면 $1$로 변환해주는 함수이다. 수식으로는 다음과 같다.</p>
<script type="math/tex; mode=display">
h(x) =
 \begin{cases}
0 & \text{(x≤0) $$}\\
1 & \text{(x>0) $$}\\
\end{cases}</script><p>아래는 위 수식의 코드 구현이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> step_function(x)</span><br><span class="line">    <span class="keyword">if</span> x&lt;=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이를 그래프로 나타내보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; <span class="keyword">using</span> Plots</span><br><span class="line">Julia&gt; x = range(-<span class="number">5.0</span>, <span class="number">5.0</span>, step = <span class="number">0.1</span>)</span><br><span class="line">Julia&gt; y = step_function.(x)</span><br><span class="line">Julia&gt; plot(x,y)</span><br></pre></td></tr></table></figure>
<p><img src="/images/33.png" alt="계단 함수"></p>
<p>그래프에서 보면 $0$을 기준으로 $0$ 또는 $1$을 반환하는 것을 확인할 수 있다. 위의 함수는 연속적인 값이 아닌 이진수를 결과로 반환한다.</p>
<p><strong>Tip</strong><br>위의 코드를 보면 <code>step_function.(x)</code>에 도트 연산자를 확인할 수 있다. 도트 연산자는 배열 단위의 입력 값에 함수나 연산자를 각 요소별로 적용해준다.</p>
<h4 id="시그모이드-함수"><a href="#시그모이드-함수" class="headerlink" title="시그모이드 함수"></a>시그모이드 함수</h4><p>시그모이드 함수는 입력값들을 $0$과 $1$사이의 수로 변환해주는 함수이다. 수식은 아래와 같다.</p>
<script type="math/tex; mode=display">h(x)=\frac{1}{1+e^{-x}}</script><p>위의 식을 코드로 구현해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> sigmoid(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span>+exp(-x))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>그래프를 그려보면 $0$과 $1$ 사이의 소수들로 구성된 것을 볼 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; <span class="keyword">using</span> Plots</span><br><span class="line">Julia&gt; x = range(-<span class="number">5.0</span>, <span class="number">5.0</span>, step = <span class="number">0.1</span>)</span><br><span class="line">Julia&gt; y = sigmoid.(x)</span><br><span class="line">Julia&gt; plot(x,y)</span><br></pre></td></tr></table></figure>
<p><img src="/images/32.png" alt="시그모이드 함수"></p>
<p>시그모이드 함수는 $0$과 $1$의 사이에서 연속적인 값을 반환하며, $0$을 중간값인 $0.5$로 설정한다. 따라서 계단 함수와 달리 각 신호의 강도를 표현할 수 있다.</p>
<h4 id="ReLU-함수"><a href="#ReLU-함수" class="headerlink" title="ReLU 함수"></a>ReLU 함수</h4><p>ReLU 함수는 음수를 모두 $0$으로 바꾸고 양수는 그대로 출력하는 함수이다. 수식은 다음과 같다.</p>
<script type="math/tex; mode=display">
h(x) =
 \begin{cases}
0 & \text{(x≤0)$$}\\
x & \text{(x>0) $$}\\
\end{cases}</script><p>위 수식을 코드로 구현해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> relu(x)</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/34.png" alt="ReLU 함수"></p>
<p>위의 그래프를 통해 음수는 모두 $0$으로 처리되며, 양수는 값이 그대로 출력되는 것을 확인할 수 있다.</p>
<h4 id="세-가지-함수-비교"><a href="#세-가지-함수-비교" class="headerlink" title="세 가지 함수 비교"></a>세 가지 함수 비교</h4><p>지금까지 은닉층에서 사용하는 활성화 함수들을 살펴보았다. 이제는 배열에 직접 적용해봄으로서 각 함수들을 비교해보고자 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; x = [-<span class="number">1</span> -<span class="number">2</span> -<span class="number">3</span>;<span class="number">0</span> <span class="number">3</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>위의 코드는 예시로 적용해 볼 $2\times3$ 배열이다. 계단 함수와 시그모이드 함수, ReLU 함수 순서로 적용해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; step_function.(x)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>계단 함수는 음수와 $0$은 모두 ‘$0$’으로 바꾸고 양수들을 ‘$1$’로 출력하였다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; sigmoid.(x)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">0.268941</span>  <span class="number">0.119203</span>  <span class="number">0.0474259</span></span><br><span class="line"> <span class="number">0.5</span>       <span class="number">0.952574</span>  <span class="number">0.999089</span></span><br></pre></td></tr></table></figure>
<p>시그모이드 함수는 각 배열 요소들을 $0$부터 $1$까지의 수로 변환하여 출력하였다. 요소 중 하나인 $0$은 중간값 0.5로 설정된 것을 볼 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; relu.(x)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">3</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>ReLU 함수의 경우 음수는 모두 $0$으로 바꾸고 양수는 그대로 출력한 것을 확인할 수 있다.</p>
<h3 id="출력층에서-사용하는-활성화-함수"><a href="#출력층에서-사용하는-활성화-함수" class="headerlink" title="출력층에서 사용하는 활성화 함수"></a>출력층에서 사용하는 활성화 함수</h3><p>출력층에서 사용되는 활성화 함수는 목적에 따라 달라진다. 일반적으로 회귀에는 항등 함수, 분류에는 소프트맥스 함수가 쓰인다.</p>
<h4 id="항등-함수"><a href="#항등-함수" class="headerlink" title="항등 함수"></a>항등 함수</h4><p>항등 함수는 입력값을 그대로 출력한다. 수식과 코드는 아래와 같다.</p>
<script type="math/tex; mode=display">σ(x)=x</script><figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity_function(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="소프트맥스-함수"><a href="#소프트맥스-함수" class="headerlink" title="소프트맥스 함수"></a>소프트맥스 함수</h4><p>소프트맥스 함수는 0과 1사이의 값을 비율로 출력하기 때문에 “확률”로 해석할 수 있다. 이런 이유로 분류 신경망에서 소프트맥스 함수를 사용한다. 예를 들어, 꽃 사진 하나를 분석하여 어떤 꽃인지 분류하는 신경망을 구현 중이라면 소프트맥스 함수는 (장미 70%, 진달래 21%, 붓꽃 9%) 이런 식으로 결과를 제공한다. 수식은 다음와 같다.</p>
<script type="math/tex; mode=display">y_k=\frac{e^{a_k}}{\sum_{i=1}^n e^{a_i}}</script><p>이 수식에서 $y_k$는 출력층의 $k$번째 노드이며, 분자의 $a_k$는 $k$번째 입력 값이다. 또한 분모에서 $n$은 총 출력층의 개수이며, 분모 전체는 출력된 값의 전체 합을 의미한다. 이를 코드로 구현하면 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> softmax(x)</span><br><span class="line">    c = maximum(x)</span><br><span class="line">    exp.(x.-c)/sum(exp.(x.-c))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위 코드에서 입력 신호의 최대값을 빼는 이유는 오버플로(overflow) 문제를 막기 위함이다. 오버플로(overflow)란 결과값이 컴퓨터가 표현할 수 있는 값을 넘어갔을 때 발생하는 문제이며, 최대값을 빼주면 에러를 막을 수 있다.</p>
<h4 id="두-가지-함수-비교"><a href="#두-가지-함수-비교" class="headerlink" title="두 가지 함수 비교"></a>두 가지 함수 비교</h4><p>지금까지 출력층에서 사용하는 항등 함수와 소프트맥스 함수를 살펴보았다. 이제는 예시에 직접 적용해보면서 각 함수들의 결과들을 비교해보고자 한다. 예시로 사용할 배열은 은닉층 활성화 함수들 비교했던 <code>x</code>를 그대로 사용하기로 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; x = [-<span class="number">1</span> -<span class="number">2</span> -<span class="number">3</span>;<span class="number">0</span> <span class="number">3</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>먼저 항등 함수부터 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; identity_function(x)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> -<span class="number">1</span>  -<span class="number">2</span>  -<span class="number">3</span></span><br><span class="line">  <span class="number">0</span>   <span class="number">3</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>입력값을 그대로 반환하는 것을 알 수 있다. 그 다음으로는 소프트맥스 함수를 적용해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; softmax(x)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">0.000328971</span>  <span class="number">0.000121022</span>  <span class="number">4.45214e-5</span></span><br><span class="line"> <span class="number">0.000894237</span>  <span class="number">0.0179612</span>    <span class="number">0.98065</span></span><br></pre></td></tr></table></figure>
<p>$0$과 $1$ 사이의 값들로 변환되어 출력하는 것을 확인할 수 있다. 여기서 소프트맥스가 제대로 구현되었는지 확인하려면 모든 요소들을 더해서 $1$이 나오면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; sum(softmax(x))</span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>요소들의 합이 $1$임을 확인할 수 있다.</p>
]]></content>
      <categories>
        <category>Deep learning with Julia</category>
      </categories>
      <tags>
        <tag>딥러닝</tag>
        <tag>머신러닝</tag>
        <tag>Deeplearning</tag>
        <tag>줄리아</tag>
        <tag>sigmoid</tag>
        <tag>시그모이드</tag>
        <tag>softmax</tag>
        <tag>소프트맥스</tag>
        <tag>렐루</tag>
        <tag>ReLU</tag>
      </tags>
  </entry>
  <entry>
    <title>1. 행렬과 벡터의 곱</title>
    <url>/2020/03/26/Deeplearning-1/</url>
    <content><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.<br><a id="more"></a></p>
<h2 id="벡터란"><a href="#벡터란" class="headerlink" title="벡터란"></a>벡터란</h2><p>벡터(Vector)는 ‘크기’와 ‘방향’을 모두 나타낸다. 예를 들어, 자동차가 시속 5마일로 달린다고 해보자. 여기서 5마일은 단순히 크기일뿐 방향을 나타내고 있지 않으므로 벡터라고 할 수 없다. 벡터로 나타내기 위해서는 5마일에 동쪽으로 향하는 ‘크기’와 ‘방향’까지 포함된 개념이어야 한다.</p>
<p>벡터의 기호는 $\overrightarrow{a}$이며, 아래와 같은 ‘열벡터’가 기본 형태이다.</p>
<script type="math/tex; mode=display">\overrightarrow{a}=
\begin{bmatrix}
X \\
Y \\
\end{bmatrix}</script><p>벡터의 성분 개수와 차원은 동일하기 때문에 위의 열벡터는 성분 <code>x</code>와 <code>y</code> 를 가진 2차원 벡터이다.</p>
<p>행벡터는 기본형인 열벡터를 ‘전치’한 형태이다. 여기서 전치란 주대각선(Main diagonal)을 대칭한 것이며, 보통 행렬에서 많이 사용된다.</p>
<script type="math/tex; mode=display">\overrightarrow{a}^T=
\begin{bmatrix}
X&Y
\end{bmatrix}</script><p>행렬의 경우 아래의 행렬과 벡터의 곱에서 더 자세하게 설명할 것이다.</p>
<h2 id="벡터의-내적"><a href="#벡터의-내적" class="headerlink" title="벡터의 내적"></a>벡터의 내적</h2><p>벡터의 곱셈은 크게 ‘외적(Cross product)’과 ‘내적(Dot product)’ 2가지의 방법이 사용되며, 우리는 그 중 딥러닝에서 사용하는 내적에 대해 살펴볼 것이다.</p>
<p>내적을 수학식으로 표현하면 아래와 같다.</p>
<p>$\overrightarrow{a}\cdot\overrightarrow{b}=\sum_{i=1}^n a_ib_i=a_1b_1+a_2b_2+a_3b_3+\cdots+a_nb_n$</p>
<p>열벡터 A와 B를 내적하면 같은 위치에 있는 성분끼리 곱한 수들을 더한다. 즉, 열벡터 당 하나의 스칼라가 값으로 나오는 것이다.</p>
<script type="math/tex; mode=display">\overrightarrow{a}=\begin{bmatrix}a_1\\a_2\\a_3\\\vdots\\a_n\end{bmatrix}\quad
\overrightarrow{b}=\begin{bmatrix}b_1\\b_2\\b_3\\\vdots\\b_n\end{bmatrix}\quad
\overrightarrow{a}\cdot\overrightarrow{b}=a_1b_1+a_2b_2+a_3b_3\cdots a_nb_n</script><p>이와 같은 과정을 벡터의 내적이라고 한다.</p>
<h2 id="행렬과-벡터의-곱"><a href="#행렬과-벡터의-곱" class="headerlink" title="행렬과 벡터의 곱"></a>행렬과 벡터의 곱</h2><p>행렬이란 $m \times n$의 2차원 배열이다. 여기서 $m$은 행의 개수이고 $n$은 열의 개수이다. 아래는 $m \times n$의 행렬을 시각화한 것이다.</p>
<script type="math/tex; mode=display">A=
\begin{bmatrix}
a_{11} & \cdots & a_{1n} \\
\vdots & \ddots & \vdots \\
a_{m1} & \cdots & a_{mn}
\end{bmatrix}</script><p>그렇다면 위와 같은 행렬을 벡터와 곱하는 것이 가능할까?</p>
<p><strong>NOTE</strong><br> 앞의 질문에 대답하기 전에 행렬과 벡터의 관계를 명확히 하려고 한다. 앞서 백터를 설명하는 섹션에서 봤던 열벡터 $\overrightarrow{a}$는 $2 \times 1$ 행렬이라고 할 수 있으며, $\overrightarrow{a}^T$는 $1 \times 2$ 행렬이라고 할 수 있다.<br> 즉, 열벡터와 행벡터 모두 행렬로서 바라볼 수 있으며 그 반대도 가능하다.</p>
<p>행렬과 벡터를 곱하는 방법은 2가지가 있다.</p>
<h3 id="행-단위를-행벡터로-가정하여-내적한다"><a href="#행-단위를-행벡터로-가정하여-내적한다" class="headerlink" title="행 단위를 행벡터로 가정하여 내적한다"></a>행 단위를 행벡터로 가정하여 내적한다</h3><script type="math/tex; mode=display">A\overrightarrow{x}=
 \begin{bmatrix}
 a_{11} & a_{12} & \cdots & a_{1n} \\
 a_{21} & a_{22} & \cdots & \vdots \\
 \vdots & \cdots & \ddots & \vdots \\
 a_{m1} & \cdots & \cdots & a_{mn}
 \end{bmatrix}
 \cdot
 \begin{bmatrix}
 x_1\\
 x_2\\
 \vdots\\
 x_n\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n \\
 a_{12}x_1 + a_{22}x_2 + \cdots\cdots\cdot\ \vdots\ \\
 \ \vdots\ \\
 a_{m1}x_1 + \cdots\cdots\cdots\cdot + a_{mn}x_n
 \end{bmatrix}
 =\overrightarrow{b}</script><p> 위의 공식은 행렬 A의 각 행을 행벡터로 인식하여 $A$와 $\overrightarrow{x}$가 내적한다. 즉, 전치행렬 $A^T$의 열들을 벡터로 내적하는 것과 같다. 그렇기에 $\overrightarrow{x}$의 길이는 행렬 A의 열 개수인 $n$이어야 하며, 결과값인 $\overrightarrow{b}$는 길이가 $m$이다.</p>
<script type="math/tex; mode=display">A\overrightarrow{x}= A(m \times n) \cdot \overrightarrow{x}(n \times 1) = \overrightarrow{b}(m \times 1)</script><p>직접 숫자를 넣어 예시를 풀어보자.</p>
<script type="math/tex; mode=display">A\overrightarrow{x}=
 \begin{bmatrix}
 3 & 1 & 0 & 3 \\
 2 & 4 & 7 & 0 \\
 -1 & 2 & 3 & 4 \\
 \end{bmatrix}
 \cdot
 \begin{bmatrix}
 1\\
 2\\
 3\\
 4\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 3\times1+1\times2+0\times3+3\times4 \\
 2\times1+4\times2+7\times3+0\times4 \\
 -1\times1+2\times2+3\times3+4\times4\quad
 \end{bmatrix}
 =
 \begin{bmatrix}
 17\\
 31\\
 28\\
 \end{bmatrix}</script><p>위의 예시를 살펴보면 행렬 A의 각각의 행벡터와 $\overrightarrow{x}$를 내적하여 나온 스칼라 값이 결과값인 것을 확인할 수 있다. 결국 위의 식을 정리한다면 다음와 같다.</p>
<script type="math/tex; mode=display">A\overrightarrow{x}=
 \begin{bmatrix}
 \ \overrightarrow{a_1^T}\ \\
 \ \overrightarrow{a_2^T}\ \\
 \ \vdots\ \\
 \ \overrightarrow{a_n^T}\ \\
 \end{bmatrix}
 \cdot
 \overrightarrow{x}
 \ =
 \begin{bmatrix}
 \ \overrightarrow{a_1} \cdot\overrightarrow{x}\\
 \ \overrightarrow{a_2} \cdot\overrightarrow{x}\\
 \ \vdots\\
 \ \overrightarrow{a_n} \cdot\overrightarrow{x}\\
 \end{bmatrix}</script><h3 id="행렬을-열벡터의-모음으로-가정하여-내적한-후-각-행들을-더해준다"><a href="#행렬을-열벡터의-모음으로-가정하여-내적한-후-각-행들을-더해준다" class="headerlink" title="행렬을 열벡터의 모음으로 가정하여 내적한 후, 각 행들을 더해준다"></a>행렬을 열벡터의 모음으로 가정하여 내적한 후, 각 행들을 더해준다</h3><p>다음으로는 ‘열벡터’ 개념만으로 행렬 벡터 곱을 이해하는 방법이다. 어떤 방법을 사용하든 결과는 동일하지만 진행되는 논리구조는 다르다. 둘 중 어느 방법을 사용해도 상관없지만 개인적으로는 이 방법이 더 편하다고 생각한다. 먼저 아래의 행렬을 각각의 열벡터의 모음이라고 생각해보자.</p>
<script type="math/tex; mode=display">\begin{matrix}
 \overrightarrow{v_1}\ & \overrightarrow{v_2}\ & \cdots & \overrightarrow{v_n}
 \end{matrix}</script><script type="math/tex; mode=display">\begin{bmatrix}
 a_{11} & a_{12} & \cdots & a_{1n} \\
 a_{21} & a_{22} & \cdots & \vdots \\
 \vdots & \cdots & \ddots & \vdots \\
 a_{m1} & \cdots & \cdots & a_{mn}
 \end{bmatrix}</script><p>위의 도식처럼 행렬 A의 각 열들은 $v_1$, $v_2$, $\cdots$ $v_n$인 열벡터로 분리되었다. $v$의 개수는 행렬 A의 열 개수와 동일하며, 여기서는 n을 4라고 가정하자. 그 다음 $\overrightarrow{v}$ 백터들을 각각 $\overrightarrow{x}$와 내적한 후, 결과로 나온 값들을 행 단위로 더해주면 된다.</p>
<script type="math/tex; mode=display">A\overrightarrow{x}=\begin{bmatrix}
 \overrightarrow{v_1}\\
 \overrightarrow{v_2}\\
 \overrightarrow{v_3}\\
 \overrightarrow{v_4}\\
 \end{bmatrix}
 \begin{bmatrix}
 x_1\\
 x_2\\
 x_3\\
 x_4\\
 \end{bmatrix}
 =
 \begin{matrix}[x_1\overrightarrow{v_1}+x_2\overrightarrow{v_2}+x_3\overrightarrow{v_3}+x_4\overrightarrow{v_4}]\end{matrix}</script><p>따라서 $A\overrightarrow{x}$는 $\overrightarrow{v}$ 벡터들에 $\overrightarrow{x}$의 스칼라(상수)를 곱해준 것이다. 이는 $\overrightarrow{v}$ 벡터들의 값들을 <strong>가중</strong>해준다는 의미와 같다. 마지막으로 $\overrightarrow{x}$의 스칼라(상수)를 곱해진 $\overrightarrow{v}$ 백터들을 행 단위로 더해주면 된다.</p>
<p>이제는 원리는 파악했으니 아래의 문제를 풀어보도록 하자.</p>
<script type="math/tex; mode=display">A\overrightarrow{x}=
 \begin{bmatrix}
 3 & 1 & 0 & 3 \\
 2 & 4 & 7 & 0 \\
 -1 & 2 & 3 & 4 \\
 \end{bmatrix}
 \cdot
 \begin{bmatrix}
 1\\
 2\\
 3\\
 4\\
 \end{bmatrix}</script><p>보다시피 위의 문제와 동일하다. 다만 답이 어떻게 도출되는지 과정의 차이를 집중적으로 살펴볼 것이다.</p>
<script type="math/tex; mode=display">\begin{matrix}
 \overrightarrow{v_1}\ &\overrightarrow{v_2}\ & \overrightarrow{v_3}\ & \overrightarrow{v_4}
 \end{matrix}</script><script type="math/tex; mode=display">\begin{bmatrix}
 3\\
 2\\
 -1\\
 \end{bmatrix}
  \begin{bmatrix}
 1\\
 4\\
 2\\
 \end{bmatrix}
  \begin{bmatrix}
 0\\
 7\\
 3\\
 \end{bmatrix}
  \begin{bmatrix}
 3\\
 0\\
 4\\
 \end{bmatrix}</script><script type="math/tex; mode=display">\begin{matrix}[x_1\overrightarrow{v_1}+x_2\overrightarrow{v_2}+x_3\overrightarrow{v_3}+x_4\overrightarrow{v_4}]\end{matrix}</script><p>위의 도식처럼 열벡터 단위로 분리한 후, 아래의 공식에 대입한다.</p>
<script type="math/tex; mode=display">\begin{bmatrix}
3\times1+1\times2+0\times3+3\times4 \\
 2\times1+4\times2+7\times3+0\times4 \\
 -1\times1+2\times2+3\times3+4\times4\quad
 \end{bmatrix}
 =
 \begin{bmatrix}
 3 & 2 & 0 & 12 \\
 2 & 8 & 21 & 0 \\
 -1 & 4 & 9 & 16 \\
 \end{bmatrix}</script><p>위의 결과를 행 단위로 더해준다.</p>
<script type="math/tex; mode=display">\begin{bmatrix}
 3 + 2 + 0 + 12 \\
 2 + 8 + 21 + 0 \\
 -1 + 4 + 9 + 16 \\
 \end{bmatrix}
 =
 \begin{bmatrix}
 17 \\
 31 \\
 28 \\
 \end{bmatrix}</script><p>보다시피 첫 번째 방법과 결과는 같다. 위의 예시들은 모두 행렬과 열벡터 한 개를 내적하였다. 만약 행렬과 열벡터 여러 개를 한 번에 내적하고 싶다면 어떻게 해야 하는가? 벡터를 하나씩 행렬과 내적한 결과를 순서대로 나열하면 될 것이다. 이를 한번에 진행해주는 연산방법을 ‘행렬곱’이라고 한다.</p>
<h2 id="행렬곱"><a href="#행렬곱" class="headerlink" title="행렬곱"></a>행렬곱</h2><p>행렬곱은 여러 개의 벡터를 한번에 행렬과 곱하는 것과 동일한 결과를 제공한다. 즉, 위에서 봤던 행렬과 벡터의 곱을 여러 번 진행한 것이라고 볼 수 있다. 만약 행렬 A와 행렬 B를 곱하여 행렬 C를 도출한다고 가정해보자.</p>
<script type="math/tex; mode=display">C = A*B \rightarrow c_{mn}=a_m^T \cdot b_n</script><p>행렬 C의 요소 $c_{mn}$는 행렬 A의 $m$번째 행과 행렬 B의  $n$번째 열을 내적한 값이다. 이를 도식으로 나타내면 다음과 같다.</p>
<script type="math/tex; mode=display">\begin{bmatrix}
 a_{11} & a_{12} & \cdots & a_{1n} \\
 a_{21} & a_{22} & \cdots & \vdots \\
 \vdots & \cdots & \ddots & \vdots \\
 a_{m1} & \cdots & \cdots & a_{mn}
 \end{bmatrix}
 \begin{bmatrix}
 b_{11} & b_{12} & \cdots & b_{1n} \\
 b_{21} & b_{22} & \cdots & \vdots \\
 \vdots & \cdots & \ddots & \vdots \\
 b_{m1} & \cdots & \cdots & b_{mn}
 \end{bmatrix}</script><script type="math/tex; mode=display">=
 \begin{bmatrix}
 (a_{11}b_{11}+a_{12}b_{21}\cdots+a_{1n}b_{m1}) &  \cdots & (a_{11}b_{m1}+a_{12}b_{m2}\cdots+a_{1n}b_{mn}) \\
 (a_{21}b_{11}+a_{22}b_{21}\cdots+a_{2n}b_{m1}) &  \cdots & (a_{21}b_{m1}+a_{22}b_{m2}\cdots+a_{2n}b_{mn}) \\
 \vdots &  & \vdots \\
 (a_{m1}b_{11}+a_{m2}b_{21}\cdots+a_{mn}b_{m1}) & \cdots & (a_{m1}b_{m1}+a_{m2}b_{m2}\cdots+a_{mn}b_{mn})
 \end{bmatrix}</script><p>행렬곱에서는 행렬 두 개가 계산되는 것이므로 결과 또한 행렬의 형태를 가진다.</p>
<script type="math/tex; mode=display">A*B= A(m \times n)*(n \times o) = C(m \times o)</script><p>이제 예시를 풀어보자.</p>
<script type="math/tex; mode=display">\begin{bmatrix}
 1 & 4 \\
 2 & 5 \\
 3 & 6 \\
 \end{bmatrix}
*
 \begin{bmatrix}
 1 & 2 & 3\\
 4 & 5 & 6\\
 \end{bmatrix}</script><p>위의 행렬들은 $3\times2$와 $2\times3$이므로 결과값 행렬은 $3\times3$행렬이어야 한다.</p>
<script type="math/tex; mode=display">\begin{bmatrix}
 (1\times1+4\times4) & (1\times2+4\times5) & (1\times3+4\times6) \\
 (2\times1+5\times4) & (2\times2+5\times5) & (2\times3+5\times6) \\
 (3\times1+6\times4) & (3\times2+6\times5) & (3\times3+6\times6) \\
 \end{bmatrix}</script><script type="math/tex; mode=display">=</script><script type="math/tex; mode=display">\begin{bmatrix}
 17 & 22 & 27 \\
 22 & 29 & 36 \\
 27 & 36 & 45 \\
 \end{bmatrix}</script><p>문제의 답으로 $3\times3$ 행렬이 나온 것을 확인할 수 있다. 이런 행렬곱은 신경망 계산에서 벡터의 단위로 내적 계산을 한번에 하기 위해 사용된다.</p>
<h2 id="줄리아에서의-곱셈"><a href="#줄리아에서의-곱셈" class="headerlink" title="줄리아에서의 곱셈"></a>줄리아에서의 곱셈</h2><p>줄리아에서 내적을 사용하기 위해서는 아래의 코드를 입력하여 해당 패키지를 다운로드해야 한다. <code>LinearAlgebra</code> 사용법에 대해 자세히 알고 싶다면 <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/" target="_blank" rel="noopener">이 링크</a>에서 확인할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; <span class="keyword">import</span> Pkg</span><br><span class="line">Julia&gt; Pkg.add(<span class="string">"LinearAlgebra"</span>)</span><br><span class="line">Julia&gt; <span class="keyword">using</span> LinearAlgebra</span><br></pre></td></tr></table></figure>
<p>준비가 끝났다면 줄리아에서 내적을 어떻게 계산하는지 살펴보자. 줄리아에서 함수 <code>dot()</code>은 두 개의 백터를 내적한다. 아래의 예시를 통해 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; a = ones(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">Julia&gt; a</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">Julia&gt; b = a'</span><br><span class="line">Julia&gt; b</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>×<span class="number">1</span> Adjoint&#123;<span class="built_in">Float64</span>,<span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;&#125;:</span><br><span class="line"> <span class="number">1.0</span></span><br><span class="line"> <span class="number">1.0</span></span><br><span class="line"> <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">Julia&gt; dot(a,b)</span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 $1\times3$ 행렬인 a와, a의 전치행렬인 b를 생성하고 두 벡터를 내적한다. 그 결과로는 3이 도출되었다. 그렇다면 모든 신경망 계산에 <code>dot()</code>만을 사용하면 되는 것일까? 그렇지 않다. <code>dot()</code>은 모든 배열들을 하나의 벡터로 벡터화하는 문제가 있다. 아래의 예시를 통해서 알아보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; a = ones(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Julia&gt; a</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">Julia&gt; b = a'</span><br><span class="line">Julia&gt; b</span><br><span class="line"><span class="number">3</span>×<span class="number">2</span> Adjoint&#123;<span class="built_in">Float64</span>,<span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;&#125;:</span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">Julia&gt; dot(a,b)</span><br><span class="line"><span class="number">6.0</span></span><br></pre></td></tr></table></figure>
<p>위의 예시는 $2\times3$ 행렬인 a와 a의 전치행렬을 생성한다는 점에서 같지만, 각 변수들이 2차원 배열인 매트릭스(Matrix)라는 점에서 다르다. 즉, 첫 번째 예시는 1차 배열을 다루기 때문에 벡터화되어도 상관없는 반면 두 번째 예시는 2차원 배열이기 때문에 행과 열을 보존하여 내적을 해야 하는 것이다. 따라서 이는 행렬곱을 사용하여 처리해주어야 한다. 행렬곱 연산자는 <code>*(a,b)</code>이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; a = ones(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Julia&gt; b = a'</span><br><span class="line">Julia&gt; *(a,b)</span><br><span class="line"><span class="number">2</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line"> <span class="number">3.0</span>  <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<h2 id="신경망-계산"><a href="#신경망-계산" class="headerlink" title="신경망 계산"></a>신경망 계산</h2><p>신경망은 입력층, 은닉층, 출력층으로 구분되며 가중치와 편향을 사용하여 계산한다. 이제 신경망에서 사용되는 계산법을 모두 배웠으므로 위의 지식을 바탕으로 신경망이 어떻게 작동하는지 알아보자. 아래의 그림은 신경망 구조의 예시이다. 참고로 아래의 그림은 하나의 예시일 뿐이며, 각 층 변수의 개수는 가변적으로 설정할 수 있다.</p>
<p><img src="/images/31.png" alt="신경망 구조"></p>
<p>위의 그림은 3층 신경망 구조이다. 다른 문헌에서는 가중치가 적용된 층만 포함하여 ‘2층 신경망’이라고 정의하기도 한다. 하지만 이 시리즈에서는 ‘층(layer)’의 개수에 따라서 신경망의 이름을 정의할 것이다.</p>
<p>위 그림에서 동그라미는 각 층의 성분으로 <strong>노드</strong>라고 하며, 노드끼리 연결된 화살표는 가중치인 <strong>엣지</strong>라고 한다. 지금부터는 위 신경망 구조를 코드로 구현하여 ‘행렬과 벡터 곱’, ‘행렬곱’을 사용해볼 것이다.</p>
<p>먼저 위 구조를 분해해보도록 하자.</p>
<p>입력층($1\times4$ 행렬), 은닉층($1\times2$ 행렬), 출력층($1\times3$ 행렬)은 다음과 같다.</p>
<p>입력층: $X=[x_1,x_2,x_3,x_4]\quad$<br>은닉층: $H=[h_1,h_2]\quad$<br>출력층: $Y=[y_1,y_2,y_3]\quad$</p>
<p>신경망을 계산하기 위해서는 가중치와 편향이 필요하다. 가중치는 각 층 사이에서 곱해지는 행렬이며, 편향은 각 층의 계산마다 더해지는 상수이다. 가중치와 편향에 대한 정의는 4장인 경사하강법에서 자세히 다룰 것이다.</p>
<p>각 층은 가중치인 $W$를 곱하고 편향 $B$를 더하여 다음 층으로 넘어간다. 이를 수학식으로 표현하면 아래와 같다.</p>
<p>$H=(X*W)+B$</p>
<p>위의 신경망 구조에서 가중치와 편향은 총 2개가 필요하다. 먼저 가중치부터 살펴본다면, 첫 번째 가중치는 입력층과 은닉층 사이에 있으므로 $4\times2$ 행렬이어야 한다. 또한 두 번째는 은닉층과 출력층 사이에 있으므로 $2\times3$ 행렬이다.</p>
<script type="math/tex; mode=display">가중치 행렬 1:
\begin{bmatrix}
 w_{11} & w_{12} \\
 w_{21} & w_{22} \\
 w_{31} & w_{32} \\
 w_{41} & w_{42}
 \end{bmatrix}\quad
가중치 행렬 2:
\begin{bmatrix}
 w_{11} & w_{12} & w_{13}\\
 w_{21} & w_{22} & w_{23}\\
 \end{bmatrix}</script><p>다음은 편향이다. 편향은 각 층과 가중치가 곱해진 결과에 더하므로 입력층에서 은닉층 사이의 첫 번째 편향은 $1\times2$ 행렬이며, 두 번째 편향은 $1\times3$ 행렬이다.</p>
<script type="math/tex; mode=display">편향1:
\begin{bmatrix}
b_1 & b_2
 \end{bmatrix}\quad
편향 2:
\begin{bmatrix}
 b_1 & b_2 & b_3
 \end{bmatrix}</script><p>입력층에서 은닉층까지의 계산을 순서대로 나타내면 아래의 수학식과 같다.</p>
<script type="math/tex; mode=display">h_1=w_{11}x_1+w_{21}x_2+w_{31}x_3+w_{41}x_4+b_1\\
h_2=w_{12}x_1+w_{22}x_2+w_{32}x_3+w_{42}x_4+b_2</script><p>다음은 은닉층에서 출력층의 계산을 수학식으로 작성한 것이다.</p>
<script type="math/tex; mode=display">y_1=w_{11}x_1+w_{21}x_2+b_1\\
y_2=w_{12}x_1+w_{22}x_2+b_2\\
y_3=w_{13}x_1+w_{23}x_2+b_3</script><p>이제 준비가 완료되었다. 위의 수학식들을 코드로 구현해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; X = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">Julia&gt; W1 = [<span class="number">1</span> <span class="number">2</span>; <span class="number">3</span> <span class="number">4</span>;<span class="number">5</span> <span class="number">6</span>;<span class="number">7</span> <span class="number">8</span>]</span><br><span class="line">Julia&gt; W2 = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">Julia&gt; B1 = [<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">Julia&gt; B2 = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>먼저 입력층 행렬과 가중치 행렬, 편향을 할당해준다. 그 후 위의 수학공식을 구현하여 은닉층을 구현해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; H = *(X,W1)+B1</span><br><span class="line"><span class="number">51</span>  <span class="number">62</span></span><br></pre></td></tr></table></figure>
<p>은닉층은 입력층의 값에 가중치 W1을 곱한 후, 편향 B1을 더하였다. 마지막으로 출력층을 구현하면 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; Y = *(H,W2)+B2</span><br><span class="line"><span class="number">300</span>  <span class="number">414</span>  <span class="number">528</span></span><br></pre></td></tr></table></figure>
<p>사실 신경망을 구현하는 것은 위의 설명보다 더 복잡하다. 하지만 위의 원리를 이해하지 못한다면 신경망 자체를 파악할 수 없다.<br>다음 글에서는 신경망에 쓰이는 활성화 함수들을 살펴보고 줄리아로 구현할 것이다.</p>
]]></content>
      <categories>
        <category>Deep learning with Julia</category>
      </categories>
      <tags>
        <tag>딥러닝</tag>
        <tag>머신러닝</tag>
        <tag>Deeplearning</tag>
        <tag>줄리아</tag>
        <tag>벡터</tag>
        <tag>내적</tag>
      </tags>
  </entry>
  <entry>
    <title>0. 줄리아로 딥러닝 구현하기</title>
    <url>/2020/03/25/Deeplearning-0/</url>
    <content><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.<br><a id="more"></a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>이 시리즈는 줄리아를 사용하여 딥러닝의 알고리즘을 이해하고 구현하는 것을 목표로 한다. 특히 신경망에서 사용되는 수학적 지식이나 수식들에 대한 설명을 덧붙이면서 딥러닝을 잘 모르는 초보자들도 이해할 수 있도록 하였다.</p>
<p> 목차는 아래와 같다.</p>
<ol>
<li><p>행렬과 벡터의 곱</p>
</li>
<li><p>활성화 함수</p>
</li>
<li><p>손실 함수</p>
</li>
<li><p>경사하강법</p>
</li>
<li><p>인공신경망 구현 - 수학식 풀이</p>
</li>
<li><p>인공신경망 구현 - 순전파</p>
</li>
<li><p>인공신경망 구현 - 역전파</p>
</li>
</ol>
<h2 id="줄리아-사용법"><a href="#줄리아-사용법" class="headerlink" title="줄리아 사용법"></a>줄리아 사용법</h2><p>위 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)를 사용한다. 그렇다면 왜 파이썬이 아니라 줄리아로 구현하는가? 그 이유는 간단하다. 머신러닝을 구현하는 데 있어 줄리아는 오로지 내장 함수만을 사용하여 모든 구현이 가능하다. 만약 줄리아 언어 자체를 배우고 싶다면 블로그 내에 <a href="https://hyeonji-ryu.github.io/categories/Think-Julia/">“Think Julia”</a>을 정리한 시리즈가 있다.</p>
<h3 id="배열-생성하기"><a href="#배열-생성하기" class="headerlink" title="배열 생성하기"></a>배열 생성하기</h3><p>신경망의 데이터들은 모두 배열로 구성되어 있기 떄문에 배열을 필수적으로 생성해야 한다. 따라서 본격적으로 딥러닝을 구현하기 전에 줄리아에서는 어떻게 배열을 생성하는지에 대해 다뤄볼 것이다.</p>
<p>줄리아의 큰 장점 중 하나는 파이썬이나 R과는 다르게 1차원부터 n차원까지의 배열을 한 가지의 자료형으로 표현한다는 것이다. 그렇기에 우리는 차원의 구분없이 간단한 코드로 여러 차원의 배열을 생성할 수 있다. 줄리아에서 2차원 배열을 구현하는 방법은 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"><span class="number">1</span>×<span class="number">6</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Julia&gt; [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>줄리아는 배열에 <code>;</code>를 추가하면 2차원 배열을 반환한다. 위의 예시는 직접 데이터를 입력하는 경우이다. 만약 데이터가 랜덤 값인 배열을 생성하고 싶다면 어떻게 해야 하는가? 지금부터는 다양한 배열들을 구현하는 함수들을 살펴볼 것이다.</p>
<h4 id="모든-요소가-1인-배열"><a href="#모든-요소가-1인-배열" class="headerlink" title="모든 요소가 1인 배열"></a>모든 요소가 1인 배열</h4><p>아래의 코드는 모든 요소가 1인 2차원 배열을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; ones(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">3</span>×<span class="number">5</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>결과에서 알 수 있듯이 요소는 모두 소수형태인 1로 반환되며, 2차원 배열을 생성하는 방법은 <code>ones(row,column)</code>순서이다.<br>3차원 배열을 만드는 코드는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; ones(<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span>×<span class="number">5</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">3</span>&#125;:</span><br><span class="line">[:, :, <span class="number">1</span>] =</span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">2</span>] =</span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"> <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>위의 배열은 3차원 배열이며, 이를 생성하는 방법은 <code>ones(row,column,third dimention)</code> 순서이다. 예시를 보면서 파악했을 수도 있지만 매개 변수의 개수가 차원의 크기와 동일하다. 즉, <code>ones(3,5,2,3)</code>은 4차원 배열을 반환한다.</p>
<h4 id="모든-요소가-0인-배열"><a href="#모든-요소가-0인-배열" class="headerlink" title="모든 요소가 0인 배열"></a>모든 요소가 0인 배열</h4><p>아래의 코드는 모든 요소가 0인 2차원 배열을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; zeros(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line"> <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p><code>zeros()</code>와 <code>ones()</code>는 요소의 값만 다를 뿐 문법은 같다. 즉, <code>zeros(2,3,2)</code>는 3차원 배열을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; zeros(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">3</span>&#125;:</span><br><span class="line">[:, :, <span class="number">1</span>] =</span><br><span class="line"> <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line"> <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">2</span>] =</span><br><span class="line"> <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line"> <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<h4 id="모든-요소가-정수n인-배열"><a href="#모든-요소가-정수n인-배열" class="headerlink" title="모든 요소가 정수n인 배열"></a>모든 요소가 정수n인 배열</h4><p>0과 1이 아닌 정수 n을 값으로 하는 배열을 만들고 싶다면 <code>fill()</code>을 사용하면 된다. 예시는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; fill(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">3</span>×<span class="number">4</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>위 배열은 요소가 2인 2차원 배열이다. 즉, 첫 번째 매개 변수가 요소의 값이고 뒤의 매개 변수들이 행과 열인 것이다. 3차원 배열을 만드는 법은 다른 함수들과 같이 매개 변수를 추가하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; fill(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span>×<span class="number">4</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">3</span>&#125;:</span><br><span class="line">[:, :, <span class="number">1</span>] =</span><br><span class="line"> <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">2</span>] =</span><br><span class="line"> <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="랜덤-배열-만들기"><a href="#랜덤-배열-만들기" class="headerlink" title="랜덤 배열 만들기"></a>랜덤 배열 만들기</h3><p>앞에서는 하나의 값을 요소로 하는 배열들을 생성하였다. 지금부터는 하나의 값이 아니라 다양한 값을 랜덤으로 가지는 배열들을 만들어 볼 것이다.</p>
<h4 id="부동소수점-랜덤-배열"><a href="#부동소수점-랜덤-배열" class="headerlink" title="부동소수점 랜덤 배열"></a>부동소수점 랜덤 배열</h4><p>부동소수점을 요소로 가지는 랜덤 배열은 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;(undef, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">2.53205e-314</span>  <span class="number">2.53205e-314</span>  <span class="number">2.37106e-314</span></span><br><span class="line"> <span class="number">2.53203e-314</span>  <span class="number">2.37106e-314</span>  <span class="number">2.3099e-314</span></span><br></pre></td></tr></table></figure>
<p><code>{Float64,2}</code> 코드는 배열의 데이터 타입과 차원을 입력하고, <code>(undef, 2, 3)</code> 코드는 랜덤데이터와 행, 열을 입력한다. 그렇다면 3차원 배열을 만들기 위해서는 어떻게 해야 할까? 3차원 배열을 생성해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">3</span>&#125;(undef, <span class="number">2</span>, <span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">3</span>&#125;:</span><br><span class="line">[:, :, <span class="number">1</span>] =</span><br><span class="line"> <span class="number">2.52381e-314</span>  <span class="number">2.52381e-314</span>  <span class="number">5.0e-324</span></span><br><span class="line"> <span class="number">2.55284e-314</span>  <span class="number">2.52381e-314</span>  <span class="number">2.52381e-314</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">2</span>] =</span><br><span class="line"> <span class="number">2.52381e-314</span>  <span class="number">4.0e-323</span>  <span class="number">1.0e-323</span></span><br><span class="line"> <span class="number">2.52381e-314</span>  <span class="number">5.0e-323</span>  <span class="number">2.29607e-314</span></span><br></pre></td></tr></table></figure>
<h4 id="정수-랜덤-배열"><a href="#정수-랜덤-배열" class="headerlink" title="정수 랜덤 배열"></a>정수 랜덤 배열</h4><p>정수로 구성된 랜덤 배열은 간단하다. 부동소수점 랜덤 배열을 생성하는 위의 코드에서 데이터 타입만 변경해주면 된다. 2차원 배열은 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;(undef, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">5333990960</span>  <span class="number">5124673872</span>  <span class="number">4770</span></span><br><span class="line"> <span class="number">5333975168</span>  <span class="number">4799098432</span>    -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>3차원 배열 또한 차원 수를 변경하고, 매개 변수를 추가하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">3</span>&#125;(undef, <span class="number">2</span>, <span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">3</span>&#125;:</span><br><span class="line">[:, :, <span class="number">1</span>] =</span><br><span class="line"> <span class="number">5108433792</span>  <span class="number">5108433872</span>           <span class="number">1</span></span><br><span class="line"> <span class="number">5343445008</span>  <span class="number">5108433632</span>  <span class="number">5108433952</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">2</span>] =</span><br><span class="line"> <span class="number">5108434032</span>  <span class="number">12</span>           <span class="number">2</span></span><br><span class="line"> <span class="number">5108434112</span>  <span class="number">12</span>  <span class="number">4798283777</span></span><br></pre></td></tr></table></figure>
<h4 id="범위를-설정한-정수-랜덤-배열"><a href="#범위를-설정한-정수-랜덤-배열" class="headerlink" title="범위를 설정한 정수 랜덤 배열"></a>범위를 설정한 정수 랜덤 배열</h4><p>위의 예시들을 보면 1부터  5343445008까지 정말 큰 숫자들이 랜덤으로 선정되는 걸 확인할 수 있다. 5343445008와 같은 큰 숫자가 필요없거나 최대값을 설정해야 한다면, 아래의 함수를 사용하자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; rand(<span class="number">1</span>:<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">2</span>×<span class="number">4</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">8</span>  <span class="number">7</span>  <span class="number">10</span>  <span class="number">10</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">9</span>   <span class="number">1</span>  <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><code>rand()</code>는 첫 번째 매개 변수로 범위를 받고, 이후 행과 열을 받는다. 범위 안에서 요소의 값들이 결정되며 3차원 배열 또한 생성 가능하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; rand(<span class="number">1</span>:<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span>×<span class="number">4</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">3</span>&#125;:</span><br><span class="line">[:, :, <span class="number">1</span>] =</span><br><span class="line"> <span class="number">9</span>  <span class="number">7</span>  <span class="number">9</span>  <span class="number">8</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">7</span>  <span class="number">7</span>  <span class="number">7</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">2</span>] =</span><br><span class="line"> <span class="number">9</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">5</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">3</span>  <span class="number">3</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="배열-차원-변경하기"><a href="#배열-차원-변경하기" class="headerlink" title="배열 차원 변경하기"></a>배열 차원 변경하기</h3><p>어떤 배열을 다른 형태의 배열로 변경하고 싶다면 <code>reshape()</code>를 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; a = collect(<span class="number">1</span>:<span class="number">16</span>)</span><br><span class="line"><span class="number">16</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;:</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">4</span></span><br><span class="line">  ⋮</span><br><span class="line"> <span class="number">13</span></span><br><span class="line"> <span class="number">14</span></span><br><span class="line"> <span class="number">15</span></span><br><span class="line"> <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>위의 객체 <code>a</code>는 $16\times1$ 배열이다. 이 배열을 $4\times4$ 배열로 바꾸고 싶다면 아래와 같이 입력하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; reshape(a,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">4</span>×<span class="number">4</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">1</span>  <span class="number">5</span>   <span class="number">9</span>  <span class="number">13</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">6</span>  <span class="number">10</span>  <span class="number">14</span></span><br><span class="line"> <span class="number">3</span>  <span class="number">7</span>  <span class="number">11</span>  <span class="number">15</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">8</span>  <span class="number">12</span>  <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p><code>reshape(a,4,4)</code>은 앞에 첫 번째 매개 변수로 기존 배열을 받으며, 이후는 행과 열을 받는다. 데이터의 개수만 맞추면 모든 차원의 배열로 변경할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Julia&gt; reshape(a,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">2</span>×<span class="number">2</span>×<span class="number">4</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">3</span>&#125;:</span><br><span class="line">[:, :, <span class="number">1</span>] =</span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">2</span>] =</span><br><span class="line"> <span class="number">5</span>  <span class="number">7</span></span><br><span class="line"> <span class="number">6</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">3</span>] =</span><br><span class="line">  <span class="number">9</span>  <span class="number">11</span></span><br><span class="line"> <span class="number">10</span>  <span class="number">12</span></span><br><span class="line"></span><br><span class="line">[:, :, <span class="number">4</span>] =</span><br><span class="line"> <span class="number">13</span>  <span class="number">15</span></span><br><span class="line"> <span class="number">14</span>  <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>지금까지 신경망을 배우기 위한 기본적인 배열 처리 방법에 대해서 알아보았다. 이제는 본격적으로 신경망에 대해 알아보자.</p>
]]></content>
      <categories>
        <category>Deep learning with Julia</category>
      </categories>
      <tags>
        <tag>딥러닝</tag>
        <tag>머신러닝</tag>
        <tag>Deeplearning</tag>
        <tag>줄리아</tag>
      </tags>
  </entry>
  <entry>
    <title>20. 디버깅</title>
    <url>/2020/03/24/Think-Julia-Chapter-21/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap21" target="_blank" rel="noopener">Debugging</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="디버깅-Debugging"><a href="#디버깅-Debugging" class="headerlink" title="디버깅 (Debugging)"></a>디버깅 (Debugging)</h2><p>디버깅을 할 때, 보다 신속하게 오류를 추적하려면 여러 종류의 오류를 구분할 수 있어야 한다.</p>
<ul>
<li><p>소스 코드가 바이트 코드로 변환할 때 인터프리터가 ‘문법 오류(Syntax errors )’을 발견하여 프로그램 구조에 문제가 있음을 나타낸다. 예시로 함수 블록 끝에 <code>end</code> 키워드를 생햑하면 아래과 같은 메시지가 생성된다.<br><code>ERROR: LoadError: syntax: incomplete: function requires end.</code></p>
</li>
<li><p>프로그램이 실행되는 동안 문제가 발생하면 인터프리터가 ‘런타임 오류 (Runtime errors)’를 생성한다. 대부분의 런타임 오류 메시지에는 오류가 발생한 위치 및 실행중인 함수에 대한 정보가 초함된다. 예시로 무한재귀로 인해 결국 런타임 오류가 발생하는 경우를 볼 수 있다. <code>ERROR: StackOverflowError.</code></p>
</li>
<li><p>의미 오류(Semantic errors)는 오류 메시지를 생성하지 않고 실행되지만 프로그램이 올바르게 작동하지 않는 문제이다. 예로는 표현식이 예상한 순서대로 평가되지 않아서 잘못된 결과가 발생하는 등이 있다.</p>
</li>
</ul>
<p>디버깅의 첫 번째 단계는 처리중인 오류의 종류를 파악하는 것이다. 아래의 글은 오류 타입 별로 구성되어 있지만, 사실 몇몇 기술들은 둘 이상의 오류를 가진 경우도 있다.</p>
<h3 id="문법-오류-Syntax-Errors"><a href="#문법-오류-Syntax-Errors" class="headerlink" title="문법 오류 (Syntax Errors)"></a>문법 오류 (Syntax Errors)</h3><p>문법 오류는 대부분 쉽게 찾아서 수정할 수 있다. 하지만 가끔씩 오류 메시지는 도움을 주지 않는다. 대부분의 일반적인 메시지는 <code>ERROR: LoadError: syntax: incomplete: premature end of input</code> 이나 <code>ERROR: LoadError: syntax: unexpected &quot;=&quot;, neither of which</code>으로 어느 것도 유익한 정보를 주지 않는다.</p>
<p>반면, 메시지는 프로그램에서 문제가 발생한 위치를 알려준다. 줄리아는 문제를 발견한 위치를 전달하는데, 때때로 그 위치는 명확하지 않다. 이런 상황에서 실제 오류 위치는 대부분 오류 메시지가 알려준 위치보다 앞서 있는 경우가 많다.</p>
<p>프로그램을 점진적으로 개발하는 경우 오류의 위치를 잘 알고 있어야 한다. 이를 위해 추가되는 코드는 아래로 붙이는 것이 좋다.</p>
<p>책에서 코드를 복사하는 경우 본인의 코드를 책의 코드와 매우 신중하게 비교해야 한다. 되도록이면 모든 글자들을 전부 확인하는 것이 좋다. 동시에 책이 잘못되었을 수 있으므로 문법 오류처럼 보이는 것이 있다면 한번 더 확인해야 한다.</p>
<p>가장 일반적인 문법 오류들을 피하는 방법은 다음과 같다.</p>
<ul>
<li><p>변수 이름에 줄리아 키워드를 사용하지 않기</p>
</li>
<li><p>for문, while문, if문, 함수 블록을 포함하여 모든 복합 명령문 끝에 <code>end</code> 키워드가 있는지 확인하기</p>
</li>
<li><p>코드에 일치하는 인용 부호가 있는지 확인하기</p>
</li>
<li><p>삼중 따옴표(triple quotes)가 있는 문자열인 경우 문자열을 올바르게 종료했는지 확인해야 한다. 종료되지 않은 문자열은 프로그램 끝에서 유효하지 않은 토큰 오류를 발생시키거나 다음 문자열이 나올 때까지 이후 프로그램을 문자열로 인식한다. 두 번째의 경우에는 오류 메시지도 생성되지 않는다.</p>
</li>
<li><p>닫히지 않은 (,{,[ 등의 연산자들은 줄리아가 현재 명령문의 일부로 다음 행을 진행하도록 한다. 일반적으로 다음 행에서 오류가 발생한다.</p>
</li>
<li><p>조건부 내부에서 <code>==</code>대신에 <code>=</code>를 사용했는지 확인하기</p>
</li>
<li><p>코드에 ASCII 외의 다른 문자가 있는 경우 줄리아가 일반적으로 비 ASCII로 처리하지만 문제가 발생할 수 있다. 웹 페이지나 다른 소스에서 텍스트를 붙여 넣을 때는 주의해야 한다.</p>
</li>
</ul>
<p>아무것도 작동하지 않는다면, 아래로 넘어가자.</p>
<h4 id="코드를-계속-변경하지만-변하는-것이-없습니다"><a href="#코드를-계속-변경하지만-변하는-것이-없습니다" class="headerlink" title="코드를 계속 변경하지만 변하는 것이 없습니다"></a>코드를 계속 변경하지만 변하는 것이 없습니다</h4><p>REPL에 오류가 있다고 표시되지만 오류가 보이지 않는다면, REPL과 해당 개발자가 다른 코드를 보고 있을 가능성이 있다. 이럴 때는 프로그래밍 환경을 확인하여 편집중인 프로그램이 줄리아가 실행하려는 프로그램이 맞는지 확인해야 한다.</p>
<p>확실하지 않은 경우 프로그램을 시작할 때 명확하고 의도적인 구문 오류를 시도하고 다시 실행해보자. REPL에서 새 오류를 찾지 못하면 새 코드를 실행하지 않은 것이다.</p>
<p>몇 가지 주요 원인은 아래와 같다.</p>
<ul>
<li><p>파일을 편집하고 다시 실행하기 전에 변경 사항을 저장하는 것을 잊었다. 일부 프로그래밍 환경에서는 이 작업을 수행하지만 그렇지 않은 환경도 있다.</p>
</li>
<li><p>파일 이름을 변경했지만 여전히 이전 이름을 사용하여 실행중이다.</p>
</li>
<li><p>개발 환경의 무언가가 잘못 구성되었다.</p>
</li>
<li><p>모듈을 작성하고 사용하는 경우, 표준 줄리아 모듈 중 하나와 이름을 동일하게 지정하면 안된다.</p>
</li>
<li><p><code>using</code>을 사용하여 모듈을 가져오는 경우, 모듈에서 코드를 수정할 때 REPL을 다시 시작해야 한다. 모듈을 다시 가져오면 아무 작업도 수행되지 않는다.</p>
</li>
</ul>
<p>문제가 발생하여 진행 상황을 파악할 수 없는 경우 한 가지 방법은 “Hello, world”와 같은 새로운 프로그램으로 다시 시작하는 것이다. 이후 원래 프로그램의 조각을 새 프로그램에 점차적으로 추가하면 된다.</p>
<h3 id="런타임-오류-Runtime-Errors"><a href="#런타임-오류-Runtime-Errors" class="headerlink" title="런타임 오류 (Runtime Errors)"></a>런타임 오류 (Runtime Errors)</h3><p>프로그램이 문법상 올바른 경우 줄리아는 적어도 프로그램을 읽고 실행할 수 있다. 그렇다면 무엇이 더 잘못될 수 있을까?</p>
<h4 id="내-프로그램은-아무것도-하지-않습니다"><a href="#내-프로그램은-아무것도-하지-않습니다" class="headerlink" title="내 프로그램은 아무것도 하지 않습니다"></a>내 프로그램은 아무것도 하지 않습니다</h4><p>이 문제는 함수와 클래스로 구성된 파일이 실행을 시작하기 위해 함수를 호출하지 않는 경우가 가장 일반적이다. 만약 클래스와 함수를 제공하기 위한 모듈만 계획한다면 이것은 아마 의도적일 수 있다.</p>
<p>의도하지 않은 경우, 프로그램에 함수 호출이 있는지 확인하고 실행 흐름에 도달했는지 확인하라</p>
<h4 id="내-프로그램이-멈췄습니다"><a href="#내-프로그램이-멈췄습니다" class="headerlink" title="내 프로그램이 멈췄습니다"></a>내 프로그램이 멈췄습니다</h4><p>프로그램이 멈추고 아무 것도 하지 않는 것 같다면 “매달려(hang)” 있는 것이다. 그것은 무한 루프 또는 무한 재귀에 걸리는 것을 의미한다.</p>
<ul>
<li><p>문제가 있다고 생각되는 특정 루프가 있는 경우 루프 바로 시작점에 “루프 입력”, 종료점에 “루프 종료”라고 인쇄문을 추가하고 프로그램을 실행하라. 첫 번째 메시지만 받으면 무한 루프이며, 아래의 무한 루프 파트를 참고하라</p>
</li>
<li><p>대부분의 경우 무한 재귀로 인해 프로그램이 잠시 실행된 다음 <code>ERROR: LoadError: StackOverflowError</code> 오류가 발생한다. 이런 경우 아래의 무한 재귀를 참고하라.</p>
</li>
<li><p>이들 단계 중 어느 것도 작동하지 않는다면 다른 루프, 기타 재귀 함수 및 메서드 테스트를 시작하라.</p>
</li>
<li><p>그래도 문제가 해결되지 않는다면 프로그램의 실행 흐름을 이해 못한 것일 가능성이 높다. 아래의 실행 흐름 파트를 확인하라.</p>
</li>
</ul>
<h4 id="무한-루프"><a href="#무한-루프" class="headerlink" title="무한 루프"></a>무한 루프</h4><p>무한 루프를 가지고 있다고 생각하고 어떤 루프가 문제인건지 안다면 해당 루프 끝에 조건의 변수 값과 조건 값을 인쇄하는 출력문을 추가해보자.</p>
<p>예를 들면 아래의 코드와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span></span><br><span class="line">    <span class="comment"># do something to x</span></span><br><span class="line">    <span class="comment"># do something to y</span></span><br><span class="line">    <span class="meta">@debug</span> <span class="string">"variables"</span> x y</span><br><span class="line">    <span class="meta">@debug</span> <span class="string">"condition"</span> x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이제 프로그램을 디버그 모드로 작동하면, 루프가 작동할 때마다 변수 값과 상태를 볼 수 있다. 루프의 마지막 작동에서 상태는 <code>false</code>가 나와야 한다. 만약 루프가 계속 작동된다면 <code>x</code>와 <code>y</code>의 값을 볼 수 있으며, 왜 그 값들이 제대로 업데이트되지 않는지 찾을 수 있을 것이다.</p>
<h4 id="무한-재귀"><a href="#무한-재귀" class="headerlink" title="무한 재귀"></a>무한 재귀</h4><p>대부분의 경우, 무한 재귀는 프로그램이 잠시 실행되었다가 <code>ERROR: LoadError: StackOverflowError</code>와 같은 오류가 바로 발생한다.</p>
<p>만약 함수가 무한 재귀를 일으킨다고 의심되면 조건 코드를 확인해봐야 한다. 재귀 호출을 하지 않고 함수가 반환되도록 하는 조건이 있어야 한다. 그렇지 않은 경우 알고리즘을 다시 생각하고 조건 코드를 작성해야 한다.</p>
<p>조건이 명확함에도 프로그램이 멈추지 않는 경우에는 함수의 시작 부분에 매개 변수를 출력하는 출력문을 추가하자. 이후 프로그램을 실행하면 함수가 호출될 때마다 매개 변수 값이 출력된다. 조건문으로 이동하지 않는 이유에 대한 아이디어를 얻을 수도 있다.</p>
<h4 id="실행-흐름"><a href="#실행-흐름" class="headerlink" title="실행 흐름"></a>실행 흐름</h4><p>프로그램에서 실행 흐름이 어떻게 움직이는지 확실하지 않다면, “함수 시작 (함수 이름)” 이런 문구를 함수 시작 부분에 출력문으로 추가하자.</p>
<p>그러면 프로그램이 작동할 때, 각 함수들의 이름이 출력될 것이다.</p>
<h4 id="프로그램을-실행할-때-예외가-발생합니다"><a href="#프로그램을-실행할-때-예외가-발생합니다" class="headerlink" title="프로그램을 실행할 때 예외가 발생합니다"></a>프로그램을 실행할 때 예외가 발생합니다</h4><p>런타임동안 무언가 잘못되었다면 줄리아는 예외의 이름과 위치를 포함한 메시지를 출력한다.</p>
<p>stacktrace는 현재 실행중인 함수부터 호출되었던 함수들을 계속 식별한다. 즉, 각 호출이 발생한 파일의 줄 번호를 포함하여 현재 위치로 오는 과정의 함수 호출 순서를 추적하는 것이다.</p>
<p>첫 번째 단계는 오류가 발생한 프로그램의 위치를 확인하고 발생한 문제를 파악할 수 있는지 확인하는 것이다. 다음은 가장 일반적인 런타임 오류 중 일부이다.</p>
<ul>
<li><p>ArgumentError<br>함수 호출에 대한 인수 중 하나가 잘못된 경우</p>
</li>
<li><p>BoundsError<br>배열 인덱싱 작업이 범위를 벗어난 요소에 엑세스하려는 경우</p>
</li>
<li><p>DomainError<br>함수 또는 생성자에 대한 인수가 유효한 도메인 외부에 있는 경우</p>
</li>
<li><p>DivideError<br>분모 값이 0인 정수 나누기를 시도한 경우</p>
</li>
<li><p>EOFError<br>파일이나 스트림에서 더 이상 읽을 데이터가 없는 경우</p>
</li>
<li><p>InexactError<br>정확하게 데이터 타입으로 변환할 수 없는 경우</p>
</li>
<li><p>KeyError<br>AbstractDict(Dict) 또는 Set 등 인덱싱 작업이 불가능한 객체에 인덱스를 통해 요소에 접근하거나 삭제하려는 경우</p>
</li>
<li><p>MethodError<br>주어진 함수에 필요한 메서드가 존재하지 않은 경우</p>
</li>
<li><p>OutOfMemoryError<br>시스템이 올바르게 처리하기에는 너무 많은 메모리를 할당한 조작인 경우</p>
</li>
<li><p>OverflowError<br>표현식의 결과가 지정된 데이터 타입에 비해 너무 커서 랩어라운드(wraparound)를 발생시키는 경우</p>
</li>
<li><p>StackOverflowError<br>함수 호출이 호툴 스택의 크기를 넘어선 경우 (일반적으로 호출이 무한번 반복될 때 발생한다.)</p>
</li>
<li><p>StringIndexError<br>유효하지 않은 인덱스로 문자열에 접근하는 경우</p>
</li>
<li><p>SystemError<br>오류 코드와 함께 시스템 호툴에 실패한 경우</p>
</li>
<li><p>TypeError<br>데이터 타입이 이상하거나 또는 잘못된 데이터 타입을 인수로 가진 함수를 호출한 경우</p>
</li>
<li><p>UndefVarError<br>현재 범위에서의 심볼(symbol)이 정의되어 있지 않은 경우</p>
</li>
</ul>
<h4 id="프린트문을-너무-많이-추가해서-결과가-넘칩니다"><a href="#프린트문을-너무-많이-추가해서-결과가-넘칩니다" class="headerlink" title="프린트문을 너무 많이 추가해서 결과가 넘칩니다"></a>프린트문을 너무 많이 추가해서 결과가 넘칩니다</h4><p>디버깅에 프린트문을 사용할 때 발생하는 문제 중 하나는 출력에 묻힐 수도 있다는 점이다. 해결 방안으로는 출력을 단순화하거나 프로그램을 단순화하는 두 가지의 방법이 있다.</p>
<p>출력을 단순화하기 위해 도움이 되지 않는 인쇄 설명을 제거하거나 주석 처리하거나 이해하기 쉽도록 출력을 형식화 할 수 있다.</p>
<p>프로그램을 단순화하기 위해 할 수 있는 몇 가지가 있다. 먼저 프로그램이 진행중인 문제를 축소하라. 예를 들어 목록을 검색하는 경우에는 작은 목록을 검색하는 것이다. 프로그램이 사용자로부터 입력을 받는 경우 문제를 일으키는 가장 간단한 입력을 제공하면 된다.</p>
<p>둘째, 프로그램을 정리하라. 데드 코드를 제거하고 가능한 쉽게 읽을 수 있도록 프로그램을 재구성하라. 예를 들어 프로그램의 중첩된 부분에 문제가 있다고 생각된다면 간단한 구조로 해당 부분을 다시 작성하면 된다. 큰 함수가 의심되는 경우에는 작은 함수로 분할하여 별도로 테스트하면 된다.</p>
<p>작은 크기의 테스트 과정에서 종종 버그를 발견한다. 어떤 상황에서는 프로그램이 작동하지만 다른 상황에서는 작동하지 않는다는 것을 알게 되면 무슨 일이 일어나고 있는지에 대한 실마리를 얻을 수 있다.</p>
<p>마찬가지로 코드를 다시 작성하면 미묘한 버그를 찾는 데 도움이 될 수 있다. 프로그램에 영향을 미치지 않아야 한다고 생각되는 변화를 만들고 작동하면 버그를 찾을 수도 있다.</p>
<h3 id="의미-오류-Semantic-Errors"><a href="#의미-오류-Semantic-Errors" class="headerlink" title="의미 오류 (Semantic Errors)"></a>의미 오류 (Semantic Errors)</h3><p>어떤 면에서 의미 오류는 인터프리터가 오류에 대한 정보를 제공하지 않기 때문에 디버그하기 가장 어렵다. 오직 개발자만이 어떻게 프로그램이 진행되어야 하는지 알고 있다.</p>
<p>첫 번째 단계는 프로그램 텍스트와 현재 보고 있는 동작을 연결하는 것이다. 이를 위해서는 프로그램이 실제로 작동하고 있는 것에 대한 가설이 필요하다. 하지만 가설을 확인하기에는 프로그램 작동이 너무 빠르게 진행된다.</p>
<p>그래서 개발자들은 종종 프로그램을 인간과 같은 속도로 늦출 수 있기를 바란다. 잘 배치된 프린트문을 삽입하는 것이 디버거(debugger)를 셋팅하거나 중단 포인트를 삽입하는 것보다 더 빠르다.</p>
<h4 id="내-프로그램이-작동하지-않습니다"><a href="#내-프로그램이-작동하지-않습니다" class="headerlink" title="내 프로그램이 작동하지 않습니다"></a>내 프로그램이 작동하지 않습니다</h4><p>아래와 같은 질문을 스스로에게 해야한다.</p>
<ul>
<li><p>프로그램이 제대로 작동하지 않는 것 같은가? 해당 기능을 수행하는 코드 섹션을 찾아 필요할 때 실행되는지 확인하라.</p>
</li>
<li><p>일어나면 안되는 것들이 발생했는가? 프로그램에서 해당 기능을 수행한느 코드를 찾고 실행하지 않아야 할 때 실행 중인지 확인하라.</p>
</li>
<li><p>코드 섹션이 예상과 다른 결과를 도출하는가? 특히 줄리아 모듈의 함수 및 메서드와 관련된 코드인 경우 문제의 코드를 이해해야 한다. 호출한 함수에 대한 설명서를 읽은 후 간단한 테스트 사례를 작성하고 결과를 확인하여 시험해보라.</p>
</li>
</ul>
<p>프로그래밍을 하려면 프로그램 작동 방식에 대한 추상적 모델이 필요하다. 프로그램이 예상대로 되지 않는 이유 중에 종종 추상적 모델 자체가 잘못된 경우가 있다.</p>
<p>추상적 모델을 수저어하는 가장 좋은 방법은 프로그램을 구성요소로 나누고 각 구성요소를 독립적으로 테스트하는 것이다. 현실과 추상적 모델의 차이가 발견되면 문제를 해결할 수 있다.</p>
<p>물론 프로그램을 개발할 때 구성요소를 작성하고 테스트해야 한다. 문제가 발생하면 정확하지 않은 소량의 새 코드가 문제여야 한다.</p>
<h4 id="크고-거친-표현식을-사용해서-기대한-대로-작동하지-않습니다"><a href="#크고-거친-표현식을-사용해서-기대한-대로-작동하지-않습니다" class="headerlink" title="크고 거친 표현식을 사용해서 기대한 대로 작동하지 않습니다"></a>크고 거친 표현식을 사용해서 기대한 대로 작동하지 않습니다</h4><p>복잡한 표현식을 작성하는 것은 읽기 쉬우면 괜찮지만 디버깅하기 어려울 수 있다. 복잡한 표현을 임시 변수에 대한 할당으로 나누는 것이 더 좋을 수 있다.</p>
<p>예시는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">addcard(game.hands[i], popcard(game.hands[findneighbor(game, i)]))</span><br></pre></td></tr></table></figure>
<p>위의 코드를 아래와 같이 다시 작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">neighbor = findneighbor(game, i)</span><br><span class="line">pickedcard = popcard(game.hands[neighbor])</span><br><span class="line">addcard(game.hands[i], pickedcard)</span><br></pre></td></tr></table></figure>
<p>변수 이름은 추가적인 설명으로 제공되기 때문에 보다 쉽게 읽을 수 있으며, 중간 변수의 데이터 타입을 확인하고 해당 값을 표시할 수 있으므로 디버그하기가 더 쉽다.</p>
<p>큰 표현식으로 인해 발생할 수 있는 또 다른 문제는 평가 순서가 예상과 다를 수 있다는 점이다. 예를 들어 $\frac{x}{2π}$을 줄리아에서 작성하는 경우는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">y = x / <span class="number">2</span> * <span class="literal">π</span></span><br></pre></td></tr></table></figure>
<p>곱셈과 나눗셈은 같은 순서라서 왼쪽에서 오른쪽으로 평가되기 때문에 위의 코드는 정확하지 않다. 이 표현식은 $\frac{xπ}{2}$로 계산된다.</p>
<p>디버그하기 위한 좋은 표현식은 괄호를 추가해서 평가 순서를 정확하게 정해주는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">y = x / (<span class="number">2</span> * <span class="literal">π</span>)</span><br></pre></td></tr></table></figure>
<p>만약에 평가 순서를 확신할 수 없다면, 괄호를 사용하라. 프로그램 작동이 정확할뿐만 아니라 작업 순서를 외우지 않은 다른 사람들도 더 읽기 쉽다.</p>
<h4 id="함수는-있는데-기대했던-결과를-반환하지-않습니다"><a href="#함수는-있는데-기대했던-결과를-반환하지-않습니다" class="headerlink" title="함수는 있는데 기대했던 결과를 반환하지 않습니다"></a>함수는 있는데 기대했던 결과를 반환하지 않습니다</h4><p>복잡한 식의 반환문이 있는 경우 반환하기 전에 결과를 볼 기회가 없다. 다시 말하면, 임시 변수를 사용할수 있다는 것이다. 예를 들면 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> removematches(game.hands[i])</span><br></pre></td></tr></table></figure>
<p>위의 코드를 아래와 같이 바꿀 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">count = removematches(game.hands[i])</span><br><span class="line"><span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p>이제는 반환하기 전에 변수 <code>count</code>를 확인해볼 수 있다.</p>
<h4 id="디버깅하다가-막혀서-도움이-필요합니다"><a href="#디버깅하다가-막혀서-도움이-필요합니다" class="headerlink" title="디버깅하다가 막혀서 도움이 필요합니다"></a>디버깅하다가 막혀서 도움이 필요합니다</h4><p>먼저 몇 분정도 컴퓨터에서 벗어나라. 컴퓨터를 사용하다보면 아래와 같은 증상이 나타날 수 있다.</p>
<ul>
<li>좌절과 분노</li>
<li>미신적 신념과 마법적 사고</li>
<li>랜덤 워크 프로그래밍</li>
</ul>
<p>이런 증상으로 고통받고 있다면 일어나서 산책을 하는 것도 좋다. 침착할 때 프로그램에 대해 생각하라. 어떻게 작동하는가? 오류 발생하기 직전의 수정은 무엇이었나? 등등</p>
<p>때로는 버그를 찾는 데 시간이 걸린다. 컴퓨터에서 멀리 떨어져 있을 때 종종 버그를 찾게 된다. 버그를 찾는 가장 좋은 장소는 기차, 샤워시설, 잠들기 직전 등이 있다.</p>
<h4 id="진지하게-정말-도움이-필요합니다"><a href="#진지하게-정말-도움이-필요합니다" class="headerlink" title="진지하게 정말 도움이 필요합니다"></a>진지하게 정말 도움이 필요합니다</h4><p>최고의 프로그래머조차도 때때로 막힌다. 또한 프로그램에서 작업하면서 오류를 보지 못하는 경우도 종종 있다. 그래서 신선한 눈이 필요하다.</p>
<p>다른 사람을 데려 오기 전에 미리 준비하라. 프로그램은 가능한 단순해야 하며 오류를 발생시키는 가장 작은 입력에 대해 작업해야 한다. 적절한 장소에 프린트문이 있어야 하며, 간결하게 설명할 수 있을 정도로 문제를 잘 이해해야 한다.</p>
<p>도움을 받기 위해 누군가를 데려올 때 필요한 정보를 제공하라.</p>
<ul>
<li><p>오류 메시지가 있는 경우 오류 메시지는 무엇이며 어떤 부분을 나타내는가?</p>
</li>
<li><p>이 오류가 발생하기 전에 마지막으로 수행한 작업은 무엇이며, 마지막 코드 줄은 무엇인가? 테스트한 결과는 어떠한가?</p>
</li>
<li><p>지금까지 무엇을 시도했으며, 어떤 결과를 얻었나?</p>
</li>
</ul>
<p>버그를 발견하면 잠시 시간을 내어 버그를 더 빨리 찾을 수 있는 방법에 대해 생각하라. 다음에 비슷한 버그를 발견하면 더 빨리 해결할 수 있다.</p>
<p>목표는 단지 프로그램을 작동시키는 것이 아니라는 점을 기억하라. 목표는 프로그램 작동 방법을 배우는 것이다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>19. 베이스 및 표준 라이브러리</title>
    <url>/2020/03/24/Think-Julia-Chapter-20/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap20" target="_blank" rel="noopener">The Goodies: Base and Standard Library</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="베이스-및-표준-라이브러리-Base-and-Standard-Library"><a href="#베이스-및-표준-라이브러리-Base-and-Standard-Library" class="headerlink" title="베이스 및 표준 라이브러리 (Base and Standard Library)"></a>베이스 및 표준 라이브러리 (Base and Standard Library)</h2><p>줄리아는 기본 배터리가 포함되어 있다. 즉, 베이스(base) 모듈에는 가장 유용한 함수들, 데이터 타입 및 매크로가 포함된다. 이들은 모두 줄리아에서 바로 사용할 수 있다.</p>
<p>또한 줄리아는 표준 라이브러리에 많은 특수 모듈을 제공한다. 이를 사용하기 위해서는 먼저 라이브러리를 가져와야 한다.</p>
<ul>
<li><p><code>import Module</code>은 모듈을 가져오며, <code>Module.fn(x)</code>은 함수 <code>fn</code>을 호출한다.</p>
</li>
<li><p><code>using Module</code>은 모든 모듈 함수, 데이터 타입, 매크로를 가져온다.</p>
</li>
</ul>
<p>이 장은 공식적인 줄리아 문서를 대신하지는 않으며, 완벽한 것이 아니라 가능한 것에 대한 예시들을 제시할 것이다. 해당 예시에는 다른 곳에서 이미 소개된 함수들은 포함되지 않는다. 완벽한 전체 개요는 <a href="https://docs.julialang.org" target="_blank" rel="noopener">이 링크</a>에서 찾을 수 있다.</p>
<h3 id="성능-측정-Measuring-Performance"><a href="#성능-측정-Measuring-Performance" class="headerlink" title="성능 측정 (Measuring Performance)"></a>성능 측정 (Measuring Performance)</h3><p>우리는 몇몇 알고리즘이 다른 알고리즘보다 성능이 우수하다는 것을 알았다. 실제로 <a href="https://hyeonji-ryu.github.io/2020/03/10/Think-Julia-Chapter-11/">메모 파트</a>에 나온 <code>fibonnaci</code>는 <a href="https://hyeonji-ryu.github.io/2020/03/03/Think-Julia-Chapter-6/">연습해보기</a>의 <code>fib</code>보다 훨씬 빠르다. <code>@time</code>을 사용하면 성능 차이를 숫자로 표현할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fib(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">julia&gt; fibonacci(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">julia&gt; <span class="meta">@time</span> fib(<span class="number">40</span>)</span><br><span class="line">  <span class="number">0.567546</span> seconds (<span class="number">5</span> allocations: <span class="number">176</span> bytes)</span><br><span class="line"><span class="number">102334155</span></span><br><span class="line">julia&gt; <span class="meta">@time</span> fibonacci(<span class="number">40</span>)</span><br><span class="line">  <span class="number">0.000012</span> seconds (<span class="number">8</span> allocations: <span class="number">1.547</span> KiB)</span><br><span class="line"><span class="number">102334155</span></span><br></pre></td></tr></table></figure>
<p><code>@time</code>은 함수를 실행하는 데 걸린 시간, 할당 횟수 및 결과를 반환하기 전에 할당된 메모리를 출력한다. 메모 파트에서의 <code>fibonacci</code>는 훨씬 빠르지만 더 많은 메모리를 차지한다.</p>
<blockquote class="blockquote-center"><p>세상에 공짜는 없다! </p>
</blockquote>
<p><strong>TIP</strong><br>줄리아의 함수는 처음 실행될 때 컴파일된다. 따라서 두 알고리즘을 비교하려면 컴파일할 함수로 구현해야 하며, 처음 호출할 때는 성능 측정을 하면 안된다. 그렇지 않다면 컴파일 시간도 측정된다.<br>패키지 <a href="https://github.com/JuliaCI/BenchmarkTools.jl" target="_blank" rel="noopener"><code>BenchmarkTools</code></a>은 올바른 방법으로 벤치마킹하는 매크로 <code>@btime</code>을 제공한다.</p>
<h3 id="모음-및-데이터-구조-Collections-and-Data-Structures"><a href="#모음-및-데이터-구조-Collections-and-Data-Structures" class="headerlink" title="모음 및 데이터 구조 (Collections and Data Structures)"></a>모음 및 데이터 구조 (Collections and Data Structures)</h3><p><a href="https://hyeonji-ryu.github.io/2020/03/12/Think-Julia-Chapter-13/">딕셔너리 뺌셈 파트</a>에서 우리는 딕셔너리를 사용하여 문서에는 있지만 단어 배열에는 없는 단어를 찾았다. 해당 함수는 문서의 단어를 키로 포함한 <code>d1</code>과 단어 배열을 포함한 <code>d2</code>를 가져간다. 그후 <code>d2</code>에 없는 <code>d1</code>의 키를 포함한 딕셔너리를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> subtract(d1, d2)</span><br><span class="line">    res = <span class="built_in">Dict</span>()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys(d1)</span><br><span class="line">        <span class="keyword">if</span> key ∉ keys(d2)</span><br><span class="line">            res[key] = <span class="literal">nothing</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    res</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 딕셔너리에서 값은 사용하지 않기 때문에 <code>nothing</code>이먀, 결과적으로 저장 공간이 낭비된 것이다.</p>
<p>줄리아는 마치 딕셔너리에서 키만 수집한 모음과 같은 <code>셋(set)</code>이라고 불리는 다른 내장 데이터 타입을 제공한다. 셋에 요소를 추가하는 것은 빠르다. 그리고 셋은 일반적인 작동을 계산하는 함수와 연산자를 제공한다.</p>
<p>예를 들어 셋 뺄셈은 <code>setdiff()</code>라는 함수를 사용하면 가능하다. 그래서 아래의 코드처럼 <code>subtract()</code>을 재작성한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> subtract(d1, d2)</span><br><span class="line">    setdiff(d1, d2)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>결과는 딕셔너리를 대신한 셋 형태이다.</p>
<p>이 책의 몇 가지 예제는 셋을 사용하여 간결하고 효율적으로 실행할 수 있다. 다음은 딕셔너리를 사용하여 중복을 해결하는 솔루션이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> hasduplicates(t)</span><br><span class="line">    d = <span class="built_in">Dict</span>()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> t</span><br><span class="line">        <span class="keyword">if</span> x ∈ d</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        d[x] = <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>요소가 처음에 나타날 때는 딕셔너리에 추가된다. 만약 동일한 요소가 다시 나타나면 이 함수는 <code>true</code>을 반환한다.</p>
<p>셋을 사용하면 우리는 같은 함수를 아래와 같이 작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> hasduplicates(t)</span><br><span class="line">    length(<span class="built_in">Set</span>(t)) &lt; length(t)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>요소는 오직 셋에서 한번만 나타날 수 있기 때문에 <code>t</code>의 요소가 한번 이상으로 나타나면 셋은 <code>t</code>보다 더 작아질 것이다. 만약 중복이 없다면 셋은 <code>t</code>와 똑같은 사이즈일 것이다.</p>
<p>또한 <a href="https://hyeonji-ryu.github.io/2020/03/06/Think-Julia-Chapter-9/">워드 플레이 예제</a>에서도 셋을 사용할 수 있다. 예를 들어 루프가 포함된 <code>useonly</code>의 버전을 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> usesonly(word, available)</span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> word</span><br><span class="line">        <span class="keyword">if</span> letter ∉ available</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>useonly</code>는 <code>word</code>에 있는 모든 알파벳들이 <code>available</code>에 속해 있는지를 확인한다. 위의 함수를 아래와 같이 재작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> usesonly(word, available)</span><br><span class="line">    <span class="built_in">Set</span>(word) ⊆ <span class="built_in">Set</span>(available)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>⊆ (\subseteq TAB)</code> 연산자는 두 개의 <code>word</code>의 단어가 <code>available</code>와 같은지의 가능성을 포함하여 한 셋이 서브셋인지를 확인한다.</p>
<h3 id="수학-Mathematics"><a href="#수학-Mathematics" class="headerlink" title="수학 (Mathematics)"></a>수학 (Mathematics)</h3><p>복소수(Complex numbers)는 줄리아에서 제공된다. 글로벌 상수 <code>im</code>은 복소수 $i$이며, $-1$의 제곱근을 나타낸 것이다.</p>
<p>이제는 오일러의 등식(Euler’s identity)을 확인할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; ℯ^(<span class="literal">im</span>*<span class="literal">π</span>)+<span class="number">1</span></span><br><span class="line"><span class="number">0.0</span> + <span class="number">1.2246467991473532e-16</span><span class="literal">im</span></span><br></pre></td></tr></table></figure>
<p>기호 <code>ℯ (\euler TAB)</code>는 자연로그의 기초이다.</p>
<p>이제는 삼각함수의 식을 작성해보자.</p>
<script type="math/tex; mode=display">
\begin{equation}
cos(x)=\frac{e^{ix}+e^{-1x}}{2}
\end{equation}</script><p>우리는 x에 다른 값을 넣어서 위의 방정식을 테스트할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span><span class="literal">π</span></span><br><span class="line"><span class="number">0.0</span>:<span class="number">0.1</span>:<span class="number">6.2</span></span><br><span class="line">julia&gt; cos.(x) == <span class="number">0.5</span>*(ℯ.^(<span class="literal">im</span>*x)+ℯ.^(-<span class="literal">im</span>*x))</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 점 연산자의 다른 예시이다. 줄리아는 또한 숫자가 <code>2π</code>와 같은 계수로서 병치되는 것을 허용한다.</p>
<h3 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h3><p><a href="https://hyeonji-ryu.github.io/2020/03/05/Think-Julia-Chapter-8/">문자열 파트</a>와 <a href="https://hyeonji-ryu.github.io/2020/03/06/Think-Julia-Chapter-9/">워드 플레이 파트</a>에서는 우리는 문자열 객체에서 몇 가지 기본 검색을 진행하였다. 그러나 줄리아는 ‘Perl 호환 정규식(PCRE)’을 처리할 수 있으므로 문자열 객체에서 복잡한 채턴을 쉽게 찾을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> usesonly(word, available)</span><br><span class="line">  r = <span class="built_in">Regex</span>(<span class="string">"[^<span class="subst">$(available)</span>]"</span>)</span><br><span class="line">  !occursin(r, word)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>정규식(regex)은 <code>available</code> 문자열에 없는 문자를 찾고,  <code>occursin</code>은 패턴이 <code>word</code>에 있는 경우 <code>true</code>를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; usesonly(<span class="string">"banana"</span>, <span class="string">"abn"</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">julia&gt; usesonly(<span class="string">"bananas"</span>, <span class="string">"abn"</span>)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>정규식들은 <code>r</code>을 붙이면 일반적이지 않은 문자열로도 구성될 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; match(<span class="string">r"[^abn]"</span>, <span class="string">"banana"</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; m = match(<span class="string">r"[^abn]"</span>, <span class="string">"bananas"</span>)</span><br><span class="line"><span class="built_in">RegexMatch</span>(<span class="string">"s"</span>)</span><br></pre></td></tr></table></figure>
<p>위의 경우에는 문자열 보간이 허용되지 않는다. <code>match()</code>는 패턴을 찾지 못하면 아무것도 반환하지 않으며, 패턴을 찾으면 ‘regexmatch’ 객체를 반환한다.</p>
<p>정규식 객체에서 다음 정보를 추출할 수 있다.</p>
<ul>
<li>매치된 전체 서브문자열: <code>m.match</code></li>
<li>캡처된 서브문자열을 문자 배열화: <code>m.captures</code></li>
<li>전체 매치가 시작되는 오프셋: <code>m.offset</code></li>
<li>캡쳐된 서브문자열 오프셋의 배열: <code>m.offsets</code></li>
</ul>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; m.match</span><br><span class="line"><span class="string">"s"</span></span><br><span class="line">julia&gt; m.offset</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>정규식들은 매우 강력하며, <a href="http://perldoc.perl.org/perlre.html" target="_blank" rel="noopener">PERL 페이지</a>에서 다양한 세부 정보들을 제공한다.</p>
<h3 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h3><p><a href="https://hyeonji-ryu.github.io/2020/03/08/Think-Julia-Chapter-10/">배열 파트</a>에서는 배열 객체를 인덱스를 가진 1차원 컨테이너를 사용하여 해당 요소를 처리하였다. 하지만 줄리아에서 배열은 다차원 컬렉션이다.</p>
<p>2 x 3 제로 행렬을 만들어보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; z = zeros(<span class="built_in">Float64</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line"> <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">julia&gt; typeof(z)</span><br><span class="line"><span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<p>이 매트릭스의 데이터 타입은 부동소수점으로 구성된 2차원 배열이다.<br><code>size()</code>는 각 차원을 나타내는 숫자를 요소로 가진 튜플을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; size(z)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><code>ones()</code>는 인수로 데이터 타입과 숫자를 받아 매트릭스를 생성한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; s = ones(<span class="built_in">String</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">String</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>문자열 유닛 요소는 빈 문자열을 나타낸다.</p>
<p><strong>WARNING</strong><br> <code>s</code>는 1차원 배열이 아니다.</p>
 <figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; s ==  [<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>]</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p> <code>s</code>는 행(row) 매트릭스이며, [“”, “”, “”]는 열(column) 매트릭스이다.</p>
<p>매트릭스는 요소를 행으로 분리하기 위해 <code>;</code>을 구분자로 사용한다. 행을 직접 분리하는 코드는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>매트릭스 이름 뒤 대괄호를 사용하여 개별 요소들을 직접 입력할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; z[<span class="number">1</span>,<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">julia&gt; z[<span class="number">2</span>,<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">julia&gt; z</span><br><span class="line"><span class="number">2</span>×<span class="number">3</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">0.0</span></span><br><span class="line"> <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>또한 각 차원의 슬라이스를 사용하여 요소의 하위 그룹을 선택할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; u = z[:,<span class="number">2</span>:<span class="keyword">end</span>]</span><br><span class="line"><span class="number">2</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">1.0</span>  <span class="number">0.0</span></span><br><span class="line"> <span class="number">0.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p><code>.</code> 연산자는 모든 차원에 적용된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; ℯ.^(<span class="literal">im</span>*u)</span><br><span class="line"><span class="number">2</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Complex</span>&#123;<span class="built_in">Float64</span>&#125;,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">0.540302</span>+<span class="number">0.841471</span><span class="literal">im</span>       <span class="number">1.0</span>+<span class="number">0.0</span><span class="literal">im</span></span><br><span class="line">      <span class="number">1.0</span>+<span class="number">0.0</span><span class="literal">im</span>       <span class="number">0.540302</span>+<span class="number">0.841471</span><span class="literal">im</span></span><br></pre></td></tr></table></figure>
<h3 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h3><p>줄리아는 비공식 인터페이스를 지정하여 동작, 즉 특정 목표를 가진 메서드를 정의한다. 데이터 타입에 이런 메서드를 확장하면 해당 데이터 타입의 객체를 사용하여 동작을 빌드할 수 있다.</p>
<blockquote class="blockquote-center"><p>오리처럼 보이고 오리처럼 수영하고 오리처럼 울면 아마 그것은 오리일 것이다. </p>
</blockquote>
<p><a href="https://hyeonji-ryu.github.io/2020/03/03/Think-Julia-Chapter-6/">연습해보기 파트</a>에서 우리는 피보나치 수열의 $n$번째 요소를 반환하는 <code>fib()</code>를 구현하였다.</p>
<p>위의 함수는 컬렉션의 값을 반복하는 것이 인터페이스이다. 그러므로 피보나치 수열을 느리게 반환하는 이터레이터를 만들어보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Fibonacci&#123;T&lt;:<span class="built_in">Real</span>&#125; <span class="keyword">end</span></span><br><span class="line">Fibonacci(d::<span class="built_in">DataType</span>) = d&lt;:<span class="built_in">Real</span> ? Fibonacci&#123;d&#125;() : error(<span class="string">"No Real type!"</span>)</span><br><span class="line"></span><br><span class="line">Base.iterate(::Fibonacci&#123;T&#125;) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Real</span>&#125; = (zero(T), (one(T), one(T)))</span><br><span class="line">Base.iterate(::Fibonacci&#123;T&#125;, state::<span class="built_in">Tuple</span>&#123;T, T&#125;) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Real</span>&#125; = (state[<span class="number">1</span>], (state[<span class="number">2</span>], state[<span class="number">1</span>] + state[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
<p>위의 코드는 외부 생성자와 <code>iterate</code> 메서드를 사용하여 <code>Fibonnaci</code> 필드 없이 파라메트릭 데이터 타입을 구현하였다. 첫 번째는 이터레이터를 초기화하기 위해 호출되며, 첫 번째 값 0과 상태(state)를 반환한다. 위 사례에서 상태는 두 번째 값인 1과 세 번째 값 1을 포함한 튜플이다.</p>
<p>두 번째는 피보나치 수열의 다음 값을 얻기 위해 호출되고 첫 번째 요소는 다음 값, 두 번째 요소는 두 개의 다음 값을 가진 튜플을 반환한다.</p>
<p>이제는 <code>Fibonnaci</code>를 <code>for</code>루프로 나타낼 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> <span class="literal">e</span> <span class="keyword">in</span> Fibonacci(<span class="built_in">Int64</span>)</span><br><span class="line">           <span class="literal">e</span> &gt; <span class="number">100</span> &amp;&amp; <span class="keyword">break</span></span><br><span class="line">           print(<span class="literal">e</span>, <span class="string">" "</span>)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></span><br></pre></td></tr></table></figure>
<p>이것은 마술처럼 보일 수 있지만, 원리는 간단하다. 줄리아에서 <code>for</code>루프는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iter</span><br><span class="line">    <span class="comment"># body</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 루프의 프로세스를 풀어서 설명한다면 아래 코드와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">next = iterate(iter)</span><br><span class="line"><span class="keyword">while</span> next !== <span class="literal">nothing</span></span><br><span class="line">    (i, state) = next</span><br><span class="line">    <span class="comment"># body</span></span><br><span class="line">    next = iterate(iter, state)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이것은 잘 정의된 인터페이스가 어떻게 그에 맞는 함수들을 구현할 수 있게 허용하는지 보여주는 좋은 예시이다.</p>
<h3 id="대화식-유틸리티-Interactive-Utilities"><a href="#대화식-유틸리티-Interactive-Utilities" class="headerlink" title="대화식 유틸리티 (Interactive Utilities)"></a>대화식 유틸리티 (Interactive Utilities)</h3><p>우리는 이미 <code>InteractiveUtils</code> 모듈을 <a href="https://hyeonji-ryu.github.io/2020/03/18/Think-Julia-Chapter-18/#more">디버깅 파트</a>에서 보았다. <code>@which</code> 매크로는 빙산의 일각에 불과하다.</p>
<p>줄리아 코드는 <code>LLVM</code> 라이브러리에 의해 여러 단계로 기계코드화 된다. 각 단계의 결과들을 직접 시각화할 수 있다.</p>
<p>아래의 간단한 예제를 살펴보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> squaresum(a::<span class="built_in">Float64</span>, b::<span class="built_in">Float64</span>)</span><br><span class="line">    a^<span class="number">2</span> + b^<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>첫 번째 단계는 ‘낮은 수준의 코드(lowered code)’를 보는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> InteractiveUtils</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@code_lowered</span> squaresum(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="built_in">CodeInfo</span>(</span><br><span class="line"><span class="number">1</span> ─ %<span class="number">1</span> = (Core.apply_type)(Base.<span class="built_in">Val</span>, <span class="number">2</span>)</span><br><span class="line">│   %<span class="number">2</span> = (%<span class="number">1</span>)()</span><br><span class="line">│   %<span class="number">3</span> = (Base.literal_pow)(:^, a, %<span class="number">2</span>)</span><br><span class="line">│   %<span class="number">4</span> = (Core.apply_type)(Base.<span class="built_in">Val</span>, <span class="number">2</span>)</span><br><span class="line">│   %<span class="number">5</span> = (%<span class="number">4</span>)()</span><br><span class="line">│   %<span class="number">6</span> = (Base.literal_pow)(:^, b, %<span class="number">5</span>)</span><br><span class="line">│   %<span class="number">7</span> = %<span class="number">3</span> + %<span class="number">6</span></span><br><span class="line">└──      <span class="keyword">return</span> %<span class="number">7</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>@code_lowered</code> 매크로는 컴파일러가 일반화한 최적화 코드의 중간 단계를 배열로 반환한다.</p>
<p>다음 단계는 데이터 타입 정보를 추가하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="meta">@code_typed</span> squaresum(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="built_in">CodeInfo</span>(</span><br><span class="line"><span class="number">1</span> ─ %<span class="number">1</span> = (Base.mul_float)(a, a)::<span class="built_in">Float64</span></span><br><span class="line">│   %<span class="number">2</span> = (Base.mul_float)(b, b)::<span class="built_in">Float64</span></span><br><span class="line">│   %<span class="number">3</span> = (Base.add_float)(%<span class="number">1</span>, %<span class="number">2</span>)::<span class="built_in">Float64</span></span><br><span class="line">└──      <span class="keyword">return</span> %<span class="number">3</span></span><br><span class="line">) =&gt; <span class="built_in">Float64</span></span><br></pre></td></tr></table></figure>
<p>위의 결과에서 중간 결과의 데이터 타입과 정확하게 유추된 반환 값을 확인할 수 있다.</p>
<p>이 코드의 표현들을 <code>LLVM</code>코드로 변환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="meta">@code_llvm</span> squaresum(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">;  @ none:<span class="number">2</span> within <span class="string">`squaresum'</span></span><br><span class="line"><span class="string">define double @julia_squaresum_14821(double, double) &#123;</span></span><br><span class="line"><span class="string">top:</span></span><br><span class="line"><span class="string">; ┌ @ intfuncs.jl:243 within `</span>literal_pow'</span><br><span class="line">; │┌ @ float.jl:<span class="number">399</span> within <span class="string">`*'</span></span><br><span class="line"><span class="string">    %2 = fmul double %0, %0</span></span><br><span class="line"><span class="string">    %3 = fmul double %1, %1</span></span><br><span class="line"><span class="string">; └└</span></span><br><span class="line"><span class="string">; ┌ @ float.jl:395 within `</span>+'</span><br><span class="line">   %<span class="number">4</span> = fadd double %<span class="number">2</span>, %<span class="number">3</span></span><br><span class="line">; └</span><br><span class="line">  ret double %<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그러면 마지막으로 기계 코드가 생성된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="meta">@code_native</span> squaresum(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">	.section	__TEXT,__text,regular,pure_instructions</span><br><span class="line">; ┌ @ none:<span class="number">2</span> within <span class="string">`squaresum'</span></span><br><span class="line"><span class="string">; │┌ @ intfuncs.jl:243 within `</span>literal_pow'</span><br><span class="line">; ││┌ @ none:<span class="number">2</span> within <span class="string">`*'</span></span><br><span class="line"><span class="string">	vmulsd	%xmm0, %xmm0, %xmm0</span></span><br><span class="line"><span class="string">	vmulsd	%xmm1, %xmm1, %xmm1</span></span><br><span class="line"><span class="string">; │└└</span></span><br><span class="line"><span class="string">; │┌ @ float.jl:395 within `</span>+'</span><br><span class="line">	vaddsd	%xmm1, %xmm0, %xmm0</span><br><span class="line">; │└</span><br><span class="line">	retl</span><br><span class="line">	nopl	(%eax)</span><br><span class="line">; └</span><br></pre></td></tr></table></figure>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p><code>Logging</code> 매크로는 프린트 구문의 스캐폴딩을 대체할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="meta">@warn</span> <span class="string">"Abandon printf debugging, all ye who enter here!"</span></span><br><span class="line">┌ Warning: Abandon printf debugging, all ye who enter here!</span><br><span class="line">└ @ Main REPL[<span class="number">1</span>]:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>소스(source)에서 디버그 구문을 제거할 필요는 없다. 예를 들어 위의 <code>@warn</code>과 달리 아래의 코드는 기본적으로 출력이 생성되지 않는다. 이 경우 ‘디버그 로깅( debug logging)’을 사용하지 않으면 <code>sum(rand(100))</code>은 평가되지 않는다.</p>
<p>로깅 레벨은 환경 변수인 <code>JULIA_DEBUG:</code>로 선택할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">$ JULIA_DEBUG=all julia -<span class="literal">e</span> '<span class="meta">@debug</span> <span class="string">"The sum of some values <span class="subst">$(sum(rand(<span class="number">100</span>)</span>))"</span>'</span><br><span class="line">┌ Debug: The sum of some values <span class="number">47.116520814555024</span></span><br><span class="line">└ @ Main none:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>여기서는 모든 디버그 정보를 얻기 위해서 모두 사용햇지만 특정 파일 또는 모듈에 대한 출력만 생성하도록 선택할 수도 있다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 기타 문법들</title>
    <url>/2020/03/22/Think-Julia-Chapter-19/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap19" target="_blank" rel="noopener">The Goodies: Syntax</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="기타-문법들-Syntax"><a href="#기타-문법들-Syntax" class="headerlink" title="기타 문법들 (Syntax)"></a>기타 문법들 (Syntax)</h2><p>이 책의 목적 중 하나는 가능한 적게 줄리아를 사용하는 법을 알려주는 것이었다. 만약 동일한 어떤 일을 하는 두 가지의 방법이 있다면, 그 중 하나만 이 책에 적었으며 나머지는 언급하지 않았다. 때로는 나머지 방법을 연습문제에 포함시켰다.</p>
<p>지금부터는 언급하지 않았던 것들 중에 알아두면 좋은 것들을 소개할 것이다. 줄리아는 실제로 필수적이지는 않은 여러 가지 기능들을 제공한다. 이런 기능 없이도 좋은 코드를 작성할 수 있지만, 기능을 포함하면 더 간결하고 읽기 쉽고 효율적인 코드를 작성할 수 있다.</p>
<p>이 장과 다음 장에서는 이전 장에서 생략한 아래의 사항들에 대해 설명할 것이다.</p>
<ul>
<li>문법 보충</li>
<li><code>Base</code>에서 직접 사용 가능한 함수, 데이터 타입 및 매크로</li>
<li>표준 라이브러리에 있는 함수, 데이터 타입 및 매크로</li>
</ul>
<h3 id="네임드-튜플-Named-Tuples"><a href="#네임드-튜플-Named-Tuples" class="headerlink" title="네임드 튜플 (Named Tuples)"></a>네임드 튜플 (Named Tuples)</h3><p>네임드 튜플을 만들어 튜플의 구성요소 이름을 지정할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x = (a=<span class="number">1</span>, b=<span class="number">1</span>+<span class="number">1</span>)</span><br><span class="line">(a = <span class="number">1</span>, b = <span class="number">2</span>)</span><br><span class="line">julia&gt; x.a</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>네임드 튜플에서는 점 문법인 <code>(x.a)</code>을 사용하여 필드에 접근할 수 있다.</p>
<h3 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h3><p>줄리아에서 함수는 간결한 문법으로 정의할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; f(x,y) = x + y</span><br><span class="line">f (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br></pre></td></tr></table></figure>
<h4 id="익명-함수-Anonymous-Functions"><a href="#익명-함수-Anonymous-Functions" class="headerlink" title="익명 함수 (Anonymous Functions)"></a>익명 함수 (Anonymous Functions)</h4><p>이름 설정 없이 함수를 정의할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x -&gt; x^<span class="number">2</span> + <span class="number">2</span>x - <span class="number">1</span></span><br><span class="line"><span class="comment">#1 (generic function with 1 method)</span></span><br><span class="line">julia&gt; <span class="keyword">function</span> (x)</span><br><span class="line">           x^<span class="number">2</span> + <span class="number">2</span>x - <span class="number">1</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="comment">#3 (generic function with 1 method)</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 익명 함수의 예시이다. 익명 함수는 종종 다른 함수의 인수로 사용된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> Plots</span><br><span class="line"></span><br><span class="line">julia&gt; plot(x -&gt; x^<span class="number">2</span> + <span class="number">2</span>x - <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, xlabel=<span class="string">"x"</span>, ylabel=<span class="string">"y"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/25.png" alt="Plot"></p>
<p>위의 그래프는 <code>Plot</code> 명령어의 결과이다.</p>
<h4 id="키워드-인수-Keyword-Arguments"><a href="#키워드-인수-Keyword-Arguments" class="headerlink" title="키워드 인수 (Keyword Arguments)"></a>키워드 인수 (Keyword Arguments)</h4><p>함수 인수 또한 아래와 같이 명명될 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">ulia&gt; <span class="keyword">function</span> myplot(x, y; style=<span class="string">"solid"</span>, width=<span class="number">1</span>, color=<span class="string">"black"</span>)</span><br><span class="line">           <span class="comment">###</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">myplot (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line">julia&gt; myplot(<span class="number">0</span>:<span class="number">10</span>, <span class="number">0</span>:<span class="number">10</span>, style=<span class="string">"dotted"</span>, color=<span class="string">"blue"</span>)</span><br></pre></td></tr></table></figure>
<p>함수에서 키워드 인수는 세미콜론(;) 뒤에 지정되며, 쉼표로 호출된다.</p>
<h4 id="클로저-Closures"><a href="#클로저-Closures" class="headerlink" title="클로저 (Closures)"></a>클로저 (Closures)</h4><p>클로저는 함수가 함수의 호출 범위 밖에 정의된 변수를 캡쳐할 수 있게 하는 기술이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; foo(x) = ()-&gt;x</span><br><span class="line">foo (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; bar = foo(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#1 (generic function with 1 method)</span></span><br><span class="line"></span><br><span class="line">julia&gt; bar()</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>이 예시에서 함수 <code>foo()</code>는 <code>foo()</code>의 인수<code>x</code>에 접근하는 익명 함수를 반환한다. <code>bar</code>는 해당 익명함수를 지정하고 <code>foo()</code>의 인수인 값을 반환한다.</p>
<h3 id="블럭-Blocks"><a href="#블럭-Blocks" class="headerlink" title="블럭 (Blocks)"></a>블럭 (Blocks)</h3><p>블럭은 여러 명령문들을 그룹화하는 방법이다. 블럭은 키워드 <code>begin</code>로 시작하고 <code>end</code>로 끝난다.</p>
<p><a href="https://hyeonji-ryu.github.io/2020/03/02/Think-Julia-Chapter-4/">인터페이스 디자인</a>에서 <code>@svg</code>를 소개했다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line">    turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이 예시에서 <code>@svg</code>는 3개의 함수 호출을 그룹화한 블록인 단일 인수가 있다.</p>
<h4 id="let-블럭"><a href="#let-블럭" class="headerlink" title="let 블럭"></a><code>let</code> 블럭</h4><p><code>let</code> 블럭은 값을 참조할 수 있는 위치와 같은 새로운 바인딩(binding)을 생성하는 데 유용하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x, y, z = -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">let</span> x = <span class="number">1</span>, z</span><br><span class="line">           <span class="meta">@show</span> x y z;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = -<span class="number">1</span></span><br><span class="line">ERROR: <span class="built_in">UndefVarError</span>: z not defined</span><br><span class="line">julia&gt; <span class="meta">@show</span> x y z;</span><br><span class="line">x = -<span class="number">1</span></span><br><span class="line">y = -<span class="number">1</span></span><br><span class="line">z = -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>위 예시에서 첫 번째 <code>@show</code>매크로는 로컬 변수 <code>x</code>와 글로벌 변수 <code>y</code>와 정의되지 않은 <code>z</code>를 보여준다. 글로벌 변수는 그대로 유지된다.</p>
<h4 id="do-블럭"><a href="#do-블럭" class="headerlink" title="do 블럭"></a><code>do</code> 블럭</h4><p><a href="https://hyeonji-ryu.github.io/2020/03/13/Think-Julia-Chapter-14/">14장의 읽고 쓰기 파트</a>에서 우리는 작성이 끝난 파일을 닫아야 했다. 이것은 <code>do</code> 블럭을 사용하여 자동화할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; data = <span class="string">"This here's the wattle,\nthe emblem of our land.\n"</span></span><br><span class="line"><span class="string">"This here's the wattle,\nthe emblem of our land.\n"</span></span><br><span class="line">julia&gt; open(<span class="string">"output.txt"</span>, <span class="string">"w"</span>) <span class="keyword">do</span> fout</span><br><span class="line">           write(fout, data)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure>
<p>위 예시에서 <code>fout</code>는 결과를 위해 사용된 파일 스트림이다.</p>
<p>이것은 기능적으로 아래의 코드와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; f = fout -&gt; <span class="keyword">begin</span></span><br><span class="line">           write(fout, data)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="comment">#3 (generic function with 1 method)</span></span><br><span class="line">julia&gt; open(f, <span class="string">"output.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure>
<p>익명 함수는 <code>open()</code>의 첫 번째 인수로서 사용된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> open(f::<span class="built_in">Function</span>, args...)</span><br><span class="line">    io = open(args...)</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        f(io)</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">        close(io)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>do</code> 블럭은 둘러싸는 범위에서 변수를 캡처할 수 있다. 예를 들어 위의 예시였던 <code>open...do</code>에 있는 변수 데이터는 외부 범위에서 캡처된다.</p>
<h3 id="제어-흐름-Control-Flow"><a href="#제어-흐름-Control-Flow" class="headerlink" title="제어 흐름 (Control Flow)"></a>제어 흐름 (Control Flow)</h3><h4 id="삼항-연산자-Ternary-Operator"><a href="#삼항-연산자-Ternary-Operator" class="headerlink" title="삼항 연산자 (Ternary Operator)"></a>삼항 연산자 (Ternary Operator)</h4><p>삼항 연산자 <code>?:</code>는 단일 표현식 값들 중에서 선택해야 할 때 사용되는 <code>if-elseif</code>문의 대안이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; a = <span class="number">150</span></span><br><span class="line"><span class="number">150</span></span><br><span class="line">julia&gt; a % <span class="number">2</span> == <span class="number">0</span> ? println(<span class="string">"even"</span>) : println(<span class="string">"odd"</span>)</span><br><span class="line">even</span><br></pre></td></tr></table></figure>
<p><code>?</code>앞의 표현식은 조건을 나타낸 것이다. 만약 조건이 <code>true</code>면 <code>:</code> 이전의 표현식을 실행하며, <code>false</code>면 <code>:</code>뒤의 표현식을 실행한다.</p>
<h4 id="단락-평가-Short-Circuit-Evaluation"><a href="#단락-평가-Short-Circuit-Evaluation" class="headerlink" title="단락 평가 (Short-Circuit Evaluation)"></a>단락 평가 (Short-Circuit Evaluation)</h4><p>연산자 <code>&amp;&amp;</code>와 <code>||</code>는 단락 평가를 수행한다. 즉, 다음 인수는 오직 최종값을 결정할 때만 평가된다.</p>
<p>예를 들어 재귀적인 팩토리얼 함수 정의는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> fact(n::<span class="built_in">Integer</span>)</span><br><span class="line">    n &gt;= <span class="number">0</span> || error(<span class="string">"n must be non-negative"</span>)</span><br><span class="line">    n == <span class="number">0</span> &amp;&amp; <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    n * fact(n-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="테스크-일명-Coroutines"><a href="#테스크-일명-Coroutines" class="headerlink" title="테스크 (일명 Coroutines)"></a>테스크 (일명 Coroutines)</h4><p>테스크(task)는 반환 없이 협력적으로 제어할 수 있는 제어 구조이다. 줄리아에서, 테스크는 첫 번째 인수로 <code>channel</code> 객체를 가지는 함수로 구현될 수 있다. <code>channel</code>은 함수에서 수신자에게 값을 전달하는 데 사용된다.</p>
<p>피보나치 수열은 테스크를 사용하여 생성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> fib(c::<span class="built_in">Channel</span>)</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    put!(c, a)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">        put!(c, b)</span><br><span class="line">        (a, b) = (b, a+b)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>put!</code>은 <code>channel</code>객체에 값을 저장하며, <code>take!</code>은 객체로부터 값을 읽는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fib_gen = <span class="built_in">Channel</span>(fib);</span><br><span class="line"></span><br><span class="line">julia&gt; take!(fib_gen)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">julia&gt; take!(fib_gen)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">julia&gt; take!(fib_gen)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">julia&gt; take!(fib_gen)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">julia&gt; take!(fib_gen)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>생성자 <code>Channel</code>은 테스크를 만든다. <code>fib()</code>는 <code>put!</code>을 호출할 때마다 일시 중지되고 <code>take!</code>이후에 다시 시작된다. 성능상의 이유로 시퀀스의 여러 값은 재개와 일시정지 동안에 <code>Channel</code> 객체에 저장된다.</p>
<p>또한  <code>Channel</code> 객체는 이터레이터(iterator)로써도 사용된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> val <span class="keyword">in</span> <span class="built_in">Channel</span>(fib)</span><br><span class="line">           print(val, <span class="string">" "</span>)</span><br><span class="line">           val &gt; <span class="number">20</span> &amp;&amp; <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span></span><br></pre></td></tr></table></figure>
<h3 id="데이터-타입"><a href="#데이터-타입" class="headerlink" title="데이터 타입"></a>데이터 타입</h3><h4 id="기본-데이터-타입-Primitive-Types"><a href="#기본-데이터-타입-Primitive-Types" class="headerlink" title="기본 데이터 타입 (Primitive Types)"></a>기본 데이터 타입 (Primitive Types)</h4><p>기본적으로 사용되는 구체적 데이터 타입들을 기본 데이터 타입이라고 한다. 다른 언어들과 달리 줄리아에서는 고유한 기본 데이터 타입을 선언할 수 있다. 표준 기본 데이터 타입도 같은 방식으로 정의된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">primitive type</span> <span class="built_in">Float64</span> &lt;: <span class="built_in">AbstractFloat</span> <span class="number">64</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">primitive type</span> <span class="built_in">Bool</span> &lt;: <span class="built_in">Integer</span> <span class="number">8</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">primitive type</span> <span class="built_in">Char</span> &lt;: AbstractChar <span class="number">32</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">primitive type</span> <span class="built_in">Int64</span> &lt;: <span class="built_in">Signed</span> <span class="number">64</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 명령문에 있는 숫자들은 얼마나 많은 비트가 요구되는지 나타낸다.</p>
<p>아래의 예시는 기본 데이터 타입인 <code>Byte</code>와 생성자를 만든다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">primitive type</span> Byte <span class="number">8</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; Byte(val::<span class="built_in">UInt8</span>) = reinterpret(Byte, val)</span><br><span class="line">Byte</span><br><span class="line">julia&gt; b = Byte(<span class="number">0x01</span>)</span><br><span class="line">Byte(<span class="number">0x01</span>)</span><br></pre></td></tr></table></figure>
<p><code>reinterpret()</code>은 8비트의 부호없는 정수 비트를 바이트에 저장하는 데 사용된다.</p>
<h4 id="파라메트릭-데이터-타입-Parametric-Types"><a href="#파라메트릭-데이터-타입-Parametric-Types" class="headerlink" title="파라메트릭 데이터 타입 (Parametric Types)"></a>파라메트릭 데이터 타입 (Parametric Types)</h4><p>줄리아의 데이터 타입 시스템은 파라메트릭, 즉 데이터 타입이 매개 변수를 가질 수 있다.</p>
<p>데이터 타입 매개 변수는 데이터 타입 이름 뒤에 중괄호로 묶여 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point&#123;T&lt;:<span class="built_in">Real</span>&#125;</span><br><span class="line">    x::T</span><br><span class="line">    y::T</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 <code>Real</code>을 supertype으로 갖는 모든 데이터 타입인 <code>T</code>의 좌표를 가진 새로운 파라메트릭 타입 <code>Point{T&lt;:Real}</code> 정의한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; Point(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">Point&#123;<span class="built_in">Float64</span>&#125;(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>
<p>복합 데이터 타입 외에도 추상 데이터 타입이나 기본 데이터 타입에도 매개 변수가 있을 수 있다.</p>
<p><strong>Tip</strong><br>성능상의 이유로 구조체 필드에 구체적 데이터 타입을 사용하는 것이 절대적으로 권장되며, 그것이 <code>Point</code>를 빠르고 유연하게 만드는 좋은 방법이다.</p>
<h4 id="데이터-타입-유니언-Type-Unions"><a href="#데이터-타입-유니언-Type-Unions" class="headerlink" title="데이터 타입 유니언 (Type Unions)"></a>데이터 타입 유니언 (Type Unions)</h4><p>데이터 타입 유니언은 임의의 인수 타입으로 작용할 수 있는 추상적인 파라메트릭 데이터 타입이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; IntOrString = <span class="built_in">Union</span>&#123;<span class="built_in">Int64</span>, <span class="built_in">String</span>&#125;</span><br><span class="line"><span class="built_in">Union</span>&#123;<span class="built_in">Int64</span>, <span class="built_in">String</span>&#125;</span><br><span class="line">julia&gt; <span class="number">150</span> :: IntOrString</span><br><span class="line"><span class="number">150</span></span><br><span class="line">julia&gt; <span class="string">"Julia"</span> :: IntOrString</span><br><span class="line"><span class="string">"Julia"</span></span><br></pre></td></tr></table></figure>
<p>대부분의 컴퓨터 언어에서 데이터 타입 유니언은 데이터 타입을 추론하기 위한 내부 구조이다. 하지만 줄리아에서는 데이터 타입 유니언이 적을 때 효율적인 코드를 작성할 수 있기 때문에 이 기능을 사용자에게 노출한다. 이 기능은 줄리아를 사용하는 개발자에게 디스패치를 제어할 수 있는 유연성을 제공한다.</p>
<h3 id="메서드-Methods"><a href="#메서드-Methods" class="headerlink" title="메서드 (Methods)"></a>메서드 (Methods)</h3><h4 id="파라메트릭-메서드-Parametric-Methods"><a href="#파라메트릭-메서드-Parametric-Methods" class="headerlink" title="파라메트릭 메서드 (Parametric Methods)"></a>파라메트릭 메서드 (Parametric Methods)</h4><p>메서드 정의 또한 데이터 타입 매개 변수를 가질 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; isintpoint(p::Point&#123;T&#125;) <span class="keyword">where</span> &#123;T&#125; = (T === <span class="built_in">Int64</span>)</span><br><span class="line">isintpoint (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line">julia&gt; p = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Point&#123;<span class="built_in">Int64</span>&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">julia&gt; isintpoint(p)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="함수형-객체-Function-like-Objects"><a href="#함수형-객체-Function-like-Objects" class="headerlink" title="함수형 객체 (Function-like Objects)"></a>함수형 객체 (Function-like Objects)</h4><p>줄리아에서는 어떤 임의의 객체도 “호출 가능”하게 만들 수 있다. 이런 “호출 가능”한 객체를 펑터(functor)라고도 부른다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Polynomial&#123;R&#125;</span><br><span class="line">    coeff::<span class="built_in">Vector</span>&#123;R&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> (p::Polynomial)(x)</span><br><span class="line">    val = p.coeff[<span class="keyword">end</span>]</span><br><span class="line">    <span class="keyword">for</span> coeff <span class="keyword">in</span> p.coeff[<span class="keyword">end</span>-<span class="number">1</span>:-<span class="number">1</span>:<span class="number">1</span>]</span><br><span class="line">        val = val * x + coeff</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    val</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 <code>Polynomial</code>을 평가하기 위해서는 간단하게 호출하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; p = Polynomial([<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>])</span><br><span class="line">Polynomial&#123;<span class="built_in">Int64</span>&#125;([<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>])</span><br><span class="line">julia&gt; p(<span class="number">3</span>)</span><br><span class="line"><span class="number">931</span></span><br></pre></td></tr></table></figure>
<h3 id="생성자-Constructors"><a href="#생성자-Constructors" class="headerlink" title="생성자 (Constructors)"></a>생성자 (Constructors)</h3><p>파라메트릭 데이터 타입은 명시적 또는 암시적으로 생성될 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; Point(<span class="number">1</span>,<span class="number">2</span>)         <span class="comment"># implicit T</span></span><br><span class="line">Point&#123;<span class="built_in">Int64</span>&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">julia&gt; Point&#123;<span class="built_in">Int64</span>&#125;(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># explicit T</span></span><br><span class="line">Point&#123;<span class="built_in">Int64</span>&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">julia&gt; Point(<span class="number">1</span>,<span class="number">2.5</span>)       <span class="comment"># implicit T</span></span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching Point(::<span class="built_in">Int64</span>, ::<span class="built_in">Float64</span>)</span><br></pre></td></tr></table></figure>
<p>기본 내부 생성자 및 외부 생성자는 각 <code>T</code>에서 생성된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point&#123;T&lt;:<span class="built_in">Real</span>&#125;</span><br><span class="line">    x::T</span><br><span class="line">    y::T</span><br><span class="line">    Point&#123;T&#125;(x,y) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Real</span>&#125; = new(x,y)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Point(x::T, y::T) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Real</span>&#125; = Point&#123;T&#125;(x,y);</span><br></pre></td></tr></table></figure>
<p>그리고 <code>x</code>와 <code>y</code>는 같은 데이터 타입이어야 한다.</p>
<p><code>x</code>와 <code>y</code>가 다른 데이터 타입을 가지면, 외부 생성자를 아래와 같이 정의될 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Point(x::<span class="built_in">Real</span>, y::<span class="built_in">Real</span>) = Point(promote(x,y)...);</span><br></pre></td></tr></table></figure>
<p><code>promote()</code>의 세부사항은 아래에서 다룰 것이다.</p>
<h3 id="전환-및-프로모션-Conversion-and-Promotion"><a href="#전환-및-프로모션-Conversion-and-Promotion" class="headerlink" title="전환 및 프로모션 (Conversion and Promotion)"></a>전환 및 프로모션 (Conversion and Promotion)</h3><p>줄리아는 인수를 공동 데이터 타입으로 승격시키는 시스탬을 가지고 잇다. 이 작업은 자동으로 수행되지는 않지만 쉽게 확장할 수 있다.</p>
<h4 id="전환-Conversion"><a href="#전환-Conversion" class="headerlink" title="전환 (Conversion)"></a>전환 (Conversion)</h4><p>값은 다른 데이터 타입으로 변환될 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x = <span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line">julia&gt; typeof(x)</span><br><span class="line"><span class="built_in">Int64</span></span><br><span class="line">julia&gt; convert(<span class="built_in">UInt8</span>, x)</span><br><span class="line"><span class="number">0x0c</span></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line"><span class="built_in">UInt8</span></span><br></pre></td></tr></table></figure>
<p>또한 고유한 <code>convert</code>메서드도 추가할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; Base.convert(::<span class="built_in">Type</span>&#123;Point&#123;T&#125;&#125;, x::<span class="built_in">Array</span>&#123;T, <span class="number">1</span>&#125;) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Real</span>&#125; = Point(x...)</span><br><span class="line"></span><br><span class="line">julia&gt; convert(Point&#123;<span class="built_in">Int64</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">Point&#123;<span class="built_in">Int64</span>&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="프로모션-Promotion"><a href="#프로모션-Promotion" class="headerlink" title="프로모션 (Promotion)"></a>프로모션 (Promotion)</h4><p>프로모션은 혼합 데이터 타입의 값을 단일 공통 데이터 타입으로 변환하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; promote(<span class="number">1</span>, <span class="number">2.5</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1.0</span>, <span class="number">2.5</span>, <span class="number">3.0</span>)</span><br></pre></td></tr></table></figure>
<p><code>promote()</code>의 메서드 일반적으로 직접 정의되지는 않지만, 보조 함수인 <code>promote_rule()</code>은 프로모션의 규칙을 나타내는 데 사용된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">promote_rule(::<span class="built_in">Type</span>&#123;<span class="built_in">Float64</span>&#125;, ::<span class="built_in">Type</span>&#123;<span class="built_in">Int32</span>&#125;) = <span class="built_in">Float64</span></span><br></pre></td></tr></table></figure>
<h3 id="메타프로그래밍-Metaprogramming"><a href="#메타프로그래밍-Metaprogramming" class="headerlink" title="메타프로그래밍 (Metaprogramming)"></a>메타프로그래밍 (Metaprogramming)</h3><p>줄리아 코드는 언어 자체의 데이터 구조로서 표현할 수 있다. 이는 프로그램이 자체적으로 코드를 변환하고 생성할 수 있도록 허락한다.</p>
<h4 id="표현식"><a href="#표현식" class="headerlink" title="표현식"></a>표현식</h4><p>모든 줄리아 프로그램은 문자열로서 시작한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; prog = <span class="string">"1 + 2"</span></span><br><span class="line"><span class="string">"1 + 2"</span></span><br></pre></td></tr></table></figure>
<p>다음 단계는 줄리아 문자열의 문자 각각을 분석하여 <code>Expr</code>라는 줄리아 데이터 타입의 표현식 객체로 나타내는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; ex = Meta.parse(prog)</span><br><span class="line">:(<span class="number">1</span> + <span class="number">2</span>)</span><br><span class="line">julia&gt; typeof(ex)</span><br><span class="line"><span class="built_in">Expr</span></span><br><span class="line">julia&gt; dump(ex)</span><br><span class="line"><span class="built_in">Expr</span></span><br><span class="line">  head: <span class="built_in">Symbol</span> call</span><br><span class="line">  args: <span class="built_in">Array</span>&#123;<span class="built_in">Any</span>&#125;((<span class="number">3</span>,))</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">Symbol</span> +</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">Int64</span> <span class="number">1</span></span><br><span class="line">    <span class="number">3</span>: <span class="built_in">Int64</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><code>dump()</code>은 expr 객체의 주석을 보여준다.</p>
<p>괄호 안에 <code>:</code>을 쓰거나 또는 <code>quote</code> 블록을 사용하여 표현식을 직접 구성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; ex = <span class="keyword">quote</span></span><br><span class="line">           <span class="number">1</span> + <span class="number">2</span></span><br><span class="line">       <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a><code>eval</code></h4><p>줄리아는 <code>eval</code>을 사용하여 표현식 객체를 평가할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; eval(ex)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>모든 모듈은 범위 내에서 표현식을 평가하는 고유한 <code>eval()</code>을 가진다.</p>
<p><strong>WARNING</strong><br><code>eval()</code>을 과도하게 사용하는 것은 사실 무언가가 잘못되었다는 것을 의미한다.</p>
<h4 id="매크로-Macros"><a href="#매크로-Macros" class="headerlink" title="매크로 (Macros)"></a>매크로 (Macros)</h4><p>매크로는 프로그램에서 생성된 코드를 포함할 수 있다. 매크로는 <code>Expr</code>객체의 튜플을 컴파일된 표현식에 직접 매핑한다.</p>
<p>아래의 코드는 간단한 매크로이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">macro</span> containervariable(container, element)</span><br><span class="line">    <span class="keyword">return</span> esc(:($(<span class="built_in">Symbol</span>(container,element)) = $container[$element]))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>매크로는 이름 앞에 <code>@(at-sign)</code>을 붙인다. <code>@containervariable letters 1</code> 매크로 호출은 아래의 코드로 대체된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">:(letters1 = letters[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p><code>@macroexpand @containervariable letters 1</code>은 디버깅에 매우 유용한 표현식을 반환한다.</p>
<p>이 예제는 매크로가 어떻게 인수 이름에 접근하는지 보여준다. 반환 표현식은 매크로 호출 환경에서 분석되어야 하므로 <code>esc</code>를 사용하여 “escaped” 처리를 해야한다.</p>
<p><strong>NOTE</strong><br>왜 매크로인가? 전체 프로그램이 실행되기 전에 매크로는 분석 시간 동안 맟춤형 코드의 조각들을 생성하고 포함한다.</p>
<h4 id="생성-함수-Generated-Functions"><a href="#생성-함수-Generated-Functions" class="headerlink" title="생성 함수 (Generated Functions)"></a>생성 함수 (Generated Functions)</h4><p>매크로 <code>@generated</code>는 인수의 타입에 따라 메서드에 대한 특수 코드를 생성한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="meta">@generated</span> <span class="keyword">function</span> square(x)</span><br><span class="line">    println(x)</span><br><span class="line">    :(x * x)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>함수를 호출할 경우, 생성 함수는 일반 함수처럼 작동한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x = square(<span class="number">2</span>); <span class="comment"># note: output is from println() statement in the body</span></span><br><span class="line"><span class="built_in">Int64</span></span><br><span class="line">julia&gt; x              <span class="comment"># now we print x</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">julia&gt; y = square(<span class="string">"spam"</span>);</span><br><span class="line"><span class="built_in">String</span></span><br><span class="line">julia&gt; y</span><br><span class="line"><span class="string">"spamspam"</span></span><br></pre></td></tr></table></figure>
<h3 id="결측값-Missing-Values"><a href="#결측값-Missing-Values" class="headerlink" title="결측값 (Missing Values)"></a>결측값 (Missing Values)</h3><p>결측값은 <code>Missing</code>유형의 싱글톤(singleton) 인스턴스인 <code>missing</code>객체를 통해 표현될 수 있다.</p>
<p>배열은 결측값을 포함할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; a = [<span class="number">1</span>, missing]</span><br><span class="line"><span class="number">2</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Union</span>&#123;Missing, <span class="built_in">Int64</span>&#125;,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">  missing</span><br></pre></td></tr></table></figure>
<p>이런 배열 요소의 데이터 타입은 <code>Union{Missing, T}</code> 이며, 결측값이 아닌 <code>T</code> 데이터 타입이다.</p>
<p>결측값이 포함된 배열을 호출하면 리듀스 함수가 결측값을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; sum(a)</span><br><span class="line">missing</span><br></pre></td></tr></table></figure>
<p>이 상황에서는 결측값을 넘겨주는 <code>skipmissing()</code>을 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; sum(skipmissing([<span class="number">1</span>, missing]))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="C와-포트란-코드-호출-Calling-C-and-Fortran-Code"><a href="#C와-포트란-코드-호출-Calling-C-and-Fortran-Code" class="headerlink" title="C와 포트란 코드 호출 (Calling C and Fortran Code)"></a>C와 포트란 코드 호출 (Calling C and Fortran Code)</h3><p>많은 코드들이 C 또는 포트란으로 작성된다. 테스트된 코드를 다시 사용하는 것이 직접 만든 알고리즘 버전을 코드로 작성하는 것보다 더 낫다. 줄리아는 <code>ccall</code> 문법을 사용하여 기존 C 또는 포트란 라이브러리를 직접 호출할 수 있다.</p>
<p>우리는 <a href="https://hyeonji-ryu.github.io/2020/03/13/Think-Julia-Chapter-14/#more">데이터베이스</a> 파트에서 데이터베이스 함수의 GDBM 라이브러리에 줄리아 인터페이스를 도입하였다. 라이브러리는 C로 작성되며, 데이터베이스를 닫으려면 close (db)에 대한 함수를 호출해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Base.close(dbm::DBM) = gdbm_close(dbm.handle)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> gdbm_close(handle::<span class="built_in">Ptr</span>&#123;Cvoid&#125;)</span><br><span class="line">    <span class="keyword">ccall</span>((:gdbm_close, <span class="string">"libgdbm"</span>), Cvoid, (<span class="built_in">Ptr</span>&#123;Cvoid&#125;,), handle)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>dbm 객체는 <code>Ptr{Cvoid}</code>데이터 타입의 필드 <code>handle</code>을 가지고 있다. 이 필드에는 데이터베이스를 참조하는 C 포인터가 있다. 데이터베이스를 닫으려면 C 함수인 <code>gdbm_close()</code>는 데이터베이스를 가리키는 C 포인터만 반환 값 없이 호출해야 한다. 줄리아는 인수를 가진 <code>ccall()</code>을 사용하여 직접 수행한다.</p>
<ul>
<li>우리가 호출하고자하는 함수의 이름을 요소로 가지는 튜플: <code>gdbm_close</code> 및 문자열로 지정된 공유 라이브러리 <code>&quot;libgdm&quot;</code></li>
<li>반환 데이터 타입: <code>Cvoid</code></li>
<li>인수 데이터 타입의 튜플: <code>(Ptr{Cvoid})</code></li>
<li>인수 값: <code>handle</code></li>
</ul>
<p>GDBM 라이브러리의 완전한 맵핑은 ThinkJulia 소스에서 예제로 찾을 수 있다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>chapter 0. 시작하기</title>
    <url>/2020/03/19/Algorithms-0/</url>
    <content><![CDATA[<p>글을 시작하기에 앞서 해당 글은 Sanjoy Dasgupta, Christos Papadimitriou, Umesh 의 저서인 Algorithms를 바탕으로 요약 및 정리한 글임을 알려드립니다.<br><a id="more"></a></p>
<h2 id="피보나치-입문"><a href="#피보나치-입문" class="headerlink" title="피보나치 입문"></a>피보나치 입문</h2><p>피보나치는 유명한 수열로 가장 많이 알려져있다. 수열 내에서 각 숫자들은 이전 두 숫자의 합이라는 것이 피보나치 수열의 원리이다. 피보나치수 $F_n$은 다음과 같다.</p>
<script type="math/tex; mode=display">
fib(n) =
 \begin{cases}
0 & \text{if n=0 $$}\\
1 & \text{if n=1 $$}\\
fib(n-1)+fib(n-2) & \text{if n>1 $$}\\
\end{cases}</script><h3 id="지수적-알고리즘"><a href="#지수적-알고리즘" class="headerlink" title="지수적 알고리즘"></a>지수적 알고리즘</h3><p>피보나치 수열은 $2^n$과 거의 같은 속도로 증가한다. 일반적으로 $F_n$≈$2^{0.694n}$ 이다. 따라서 피보나치 함수 fib(n)의 수행속도는 $2^{0.694n}$인 $(1.6)^n$에 비례한다. 즉, $F_n+1$을 계산하는 것은 $F_n$을 계산하는 시간의 1.6배가 더 걸린다는 것이다.</p>
<p>지수함수를 기반으로 한 피보나치 수열을 구하는 공식은 $n$에서 $0$이 될 때까지 스스로를 반복해야 하기 때문에 $n$이 크면 클수록 엄청나게 많은 시간이 소요된다. 그렇다면 좀 더 빠르게 만들 수는 없을까? 피보나치에서 나온 값들을 배열에 저장한다면, 더 빠르게 작동할 것이다.</p>
<h3 id="다항-시간-알고리즘"><a href="#다항-시간-알고리즘" class="headerlink" title="다항 시간 알고리즘"></a>다항 시간 알고리즘</h3><p>다항함수는 지수함수보다 훨씬 빠르게 작동한다. 따라서 다항함수를 기반으로 작성된 코드가 훨씬 효율적이다. 코드는 먼저 $0$부터 $n$까지의 배열을 만든 후, 해당 배열의 인수를 다항식인 $f(X)=f(x-2)+f(x-1)$ 넣는 프로세스로 진행된다. 물론 $f(0)$과 $f(1)$은 $0$과 $1$로 값을 따로 지정한다. 이 방식은 지수함수를 기반으로 작성했을 때보다 훨씬 빠르고 효율적으로 작동한다.</p>
<h3 id="좀-더-정확한-분석"><a href="#좀-더-정확한-분석" class="headerlink" title="좀 더 정확한 분석"></a>좀 더 정확한 분석</h3><p>위의 지수적 알고리즘과 다항 시간 알고리즘을 좀 더 정확하게 알아보고자 한다. 뒤의 1장에서 배우겠지만, $n$비트의 두 숫자를 더하는 데 걸리는 시간은 $n$에 비례한다. 따라서 지수적 알고리즘은 $F_n$을 $n$의 수만큼 반복하여 더했기 때문에 연산 개수는 $n*F_n$이라고 할 수 있다. 또한 다항 시간 알고리즘의 연산 개수는 $n$의 개수에 따른 결과값들을 더하기 때문에 $n^2$에 비례한다. 정확하게 분석해도 다항시간 알고리즘이 훨씬 빠르다.</p>
<h2 id="빅오-표기법-big-O-notation"><a href="#빅오-표기법-big-O-notation" class="headerlink" title="빅오 표기법 (big-O notation)"></a>빅오 표기법 (big-O notation)</h2><p>알고리즘의 효율성은 데이터 개수인 $n$에 따라 연산되는 횟수를 의미하며, 크게 시간 복잡도(효율성)와 공간 복잡도(효율성)로 나뉜다. 이런 알고리즘의 효율성을 나타내는 방법으로는 빅오(Big-O), 빅오메가(big-Ω),빅세타(big-Θ) 표기법이 있다.</p>
<ul>
<li>빅오(Big-O)표기법: 상한선 기준 (≤)</li>
<li>빅오메가(big-Ω): 하한선 기준 (≥)</li>
<li>빅세타(big-Θ): 상한선과 하한선 사이를 기준 (≤ ≤)</li>
</ul>
<p>알고리즘 효율성은 그래프가 위로 향할수록(값이 클수록) 비효율적이라는 뜻이다. 빅오 표기법은 상한선을 기준으로 표기하기 때문에 알고리즘의 최악의 효율정도를 제시할 수 있어 주로 사용된다.</p>
<p>하지만 상한선이 꼭 해당 알고리즘의 최악의 효율성과 동일한 것은 아니다. 만약 최악의 효율성은 $n$값이 $1000$일 때 나타난다고 가정하자. 하지만 알고리즘은 찾고자 하는 값을 5번만에도 찿을 수 있다. 따라서 최악의 효율성이 항상 그 알고리즘의 효율성을 대변하지는 않는다.</p>
<h3 id="빅오-표기법의-수학적-정의"><a href="#빅오-표기법의-수학적-정의" class="headerlink" title="빅오 표기법의 수학적 정의"></a>빅오 표기법의 수학적 정의</h3><p>빅오 표기법의 수학적 정의는 다음과 같다.</p>
<p>“모든 $n≥n_0≥0$ 에 대하여 $0≤f(n)≤c*g(n)$ 인 양수 $c$와 $n_0$가 존재하면 $f(n)=O(g(n))$이다.”</p>
<p>예를 통해 개념을 정리하자.<br>내가 만든 알고리즘의 시간 효율성을 나타내는 함수 $f(n)$이고 $n$과 상수 $c$을 아래의 방정식과 같다고 가정한다.</p>
<p>$f(n)=n^2+5n+8$<br>$g(n)=n^2+4$</p>
<p>위의 방정식은 $0≤f(n)≤c*g(n)$을 만족하는 상수 $c$가 존재한다.<br>또한 $n_0$은 $f(n)$와 $g(n)$가 같은 값일 때를 찾으면 되는데, 예시에서는 존재한다. 여기서 같은 값이란 그래프의 비교가 시작되는 지점이다. 상수 $c$와 $n_0$를 찾았다면 빅오 표기법으로 작성할 수 있다.</p>
<h3 id="빅오-표기법의-특징"><a href="#빅오-표기법의-특징" class="headerlink" title="빅오 표기법의 특징"></a>빅오 표기법의 특징</h3><p>빅오 표기법은 몇 가지의 특징을 가지고 있다.</p>
<ul>
<li><p>상수항을 무시한다.<br>빅오 표기법에서는 데이터 입력값인 $n$이 충분히 크다고 가정하며, 알고리즘의 효율성 또한 $n$값에 좌우되기 때문에 상수항처럼 사소한 부분은 무시한다.</p>
<p>$O(3n^2)$ -&gt; $O(n^2)$</p>
</li>
<li><p>영향력이 크지 않은 항도 무시한다.<br>빅오 표기법에서는 가장 영향력이 큰 항을 제외한 나머지는 큰 영향력이 없다. 따라서 제외하여 판단한다.</p>
<p>$O(3n^2+5n+15)$ -&gt; $O(n^2)$</p>
</li>
</ul>
<p>아래의 그래프는 각 함수마다의 성능을 보여준다.</p>
<p><img src="/images/23.png" alt="big-O notation"></p>
<p>그래프에 나와있는 시간 효율성을 정리하면 다음과 같다.</p>
<p>$O(1) &lt; O(log n) &lt; O(n) &lt; O(nlog n) &lt; O(n^2) &lt; O(2^n)$</p>
<p>상수함수 &lt; 로그함수 &lt; 선형함수 &lt; 다항함수 &lt; 지수함수</p>
<p>위의 순서를 보면, 상수함수가 가장 작고 지수함수가 가장 크다. 즉 상수함수는 데이터 수가 많아도 빠르게 작동하는 알고리즘이며, 지수함수는 데이터 수가 많아질수록 급격하게 느려지는 알고리즘이라는 뜻이다. 시간 효율성 관점에서는 상수함수가 더욱 우월하다.</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>알고리즘</tag>
        <tag>빅오 표기법</tag>
        <tag>피보나치</tag>
        <tag>기초</tag>
      </tags>
  </entry>
  <entry>
    <title>17. 서브타이핑</title>
    <url>/2020/03/18/Think-Julia-Chapter-18/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap18" target="_blank" rel="noopener">Subtyping</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="서브타이핑-Subtyping"><a href="#서브타이핑-Subtyping" class="headerlink" title="서브타이핑 (Subtyping)"></a>서브타이핑 (Subtyping)</h2><p>이전 장에서는 다중 디스패치 매커니즘과 폴리모픽 메서드에 대해서 알아보았다. 인수 데이터 타입을 지정하지 않으면 모든 데이터 타입이 인수로 사용가능한 메서드가 생성된다. 메서드에서 허용된 데이터 타입의 서브셋(subset)을 지정하는 것은 다음 단계이다.</p>
<p>이번 장에서는 카드 놀이에서의 카드 덱 및 포커 패를 나타내는 데이터 타입을 사용한 서브타이핑을 볼 것이다. 만약 포커를 해본 적이 없다면, <a href="https://en.wikipedia.org/wiki/Poker" target="_blank" rel="noopener">해당 링크</a>에서 관련 정보를 읽을 수 있다.</p>
<h3 id="카드"><a href="#카드" class="headerlink" title="카드"></a>카드</h3><p>덱에 4개의 모양과 13개의 순위로 조합된 52개의 카드가 있다. 모양은 하트(<code>♥</code>), 스페이드(<code>♠</code>), 다이아몬드(<code>♦</code>), 클로버(<code>♣</code>)으로 구성되어 있다. 순위는 에이스(A), 2, 3, 4, 5, 6, 7, 8, 9, 10, 잭(J), 퀸(Q), 킹(K)으로 나눠져있다. 게임을 진행할 때는 에이스가 킹보다 높으며 2보다는 낮다.</p>
<p>카드를 표현하기 위해 새로운 객체를 정의한다면, 객체는 무슨 속성을 가져야 하는지가 명확하다. 바로 모양과 순위이다. 하지만 이 사실이 어떤 데이터 타입의 속성이어야 하는지와 연결되지는 않는다. 한 가지 방안은 <code>&quot;Spade&quot;</code>와 <code>&quot;Queen&quot;</code>처럼 문자열을 사용하는 것이다. 이런 구현의 문제점은 카드들의 순위와 모양을 비교하는 것이 어렵다는 점이다.</p>
<p>대안으로는 모양과 순위를 인코드(encode)하기 위해 정수를 사용하는 것이다. 인코드(encode)란 숫자와 모양 또는 숫자와 순위 사이에 매핑을 정의하는 것을 의미한다. 이런 종류의 인코딩은 암호화(encryption)이다.</p>
<p>예를 들어 아래의 정보는 각 모양과 이에 연결되는 정수 코드를 보여준다.</p>
<ul>
<li><code>♠</code> -&gt; 4</li>
<li><code>♥</code> -&gt; 3</li>
<li><code>♦</code> -&gt; 2</li>
<li><code>♣</code> -&gt; 1</li>
</ul>
<p>이 코드는 높은 값의 모양은 높은 숫자에 매핑했기 때문에 카드들을 비교하기가 더 쉽다. 우리는 카드들의 정수 코드를 사용하여 비교할 수 있다.</p>
<p>위에서 사용한 <code>-&gt;</code> 기호는 줄리아 프로그램에서 사용하는 것은 아니지만 매핑을 명확히 보여주기 위해서 사용한 것이다. 이와 같은 기호들은 프로그램 디자인의 일부이며, 코드에는 나타나지 않는다.</p>
<p><code>Card</code> 구조체의 정의는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Card</span><br><span class="line">    suit :: <span class="built_in">Int64</span></span><br><span class="line">    rank :: <span class="built_in">Int64</span></span><br><span class="line">    <span class="keyword">function</span> Card(suit::<span class="built_in">Int64</span>, rank::<span class="built_in">Int64</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">1</span> ≤ suit ≤ <span class="number">4</span>, <span class="string">"suit is not between 1 and 4"</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">1</span> ≤ rank ≤ <span class="number">13</span>, <span class="string">"rank is not between 1 and 13"</span>)</span><br><span class="line">        new(suit, rank)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>Card</code>를 만들기 위해서는 <code>Card()</code>에 원하는 모양과 순위를 넣어 호출해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; queen_of_diamonds = Card(<span class="number">2</span>, <span class="number">12</span>)</span><br><span class="line">Card(<span class="number">2</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<h3 id="글로벌-변수-Global-Variables"><a href="#글로벌-변수-Global-Variables" class="headerlink" title="글로벌 변수 (Global Variables)"></a>글로벌 변수 (Global Variables)</h3><p>사람들이 쉽게 읽을 수 있도록 하는 <code>Card</code> 객체를 출력하기 위해서는 정수 코드로 매핑된 모양과 순위가 필요하다. 보편적인 방법은 문자열 배열로 만드는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> suit_names = [<span class="string">"♣"</span>, <span class="string">"♦"</span>, <span class="string">"♥"</span>, <span class="string">"♠"</span>]</span><br><span class="line"><span class="keyword">const</span> rank_names = [<span class="string">"A"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>, <span class="string">"J"</span>, <span class="string">"Q"</span>, <span class="string">"K"</span>]</span><br></pre></td></tr></table></figure>
<p><code>suit_names</code>과 <code>rank_names</code>은 글로벌 변수이다. <code>const</code> 선언은 변수가 오직 하나에만 할당되도록 한다. 이것은 글로벌 변수들의 실행 문제들을 해결해준다.</p>
<p>이제 우리는 적절한 <code>show</code> 메서드를 구현할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Base.show(io::<span class="built_in">IO</span>, card::Card)</span><br><span class="line">    print(io, rank_names[card.rank], suit_names[card.suit])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>rank_names[card.rank]</code> 표현식은 “<code>rank_names</code> 배열의 인덱스로 <code>Card</code> 객체의 <code>rank</code>필드를 사용하라 그리고 알맞은 인수를 선택하라” 를 표현한 것이다.</p>
<p>지금까지 완성한 메서드를 사용하면, 우리는 출력된 카드를 얻을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; Card(<span class="number">3</span>, <span class="number">11</span>)</span><br><span class="line">J♥</span><br></pre></td></tr></table></figure>
<h3 id="카드-비교하기-Comparing-Cards"><a href="#카드-비교하기-Comparing-Cards" class="headerlink" title="카드 비교하기 (Comparing Cards)"></a>카드 비교하기 (Comparing Cards)</h3><p>내장 데이터 타입에서는 관계 연산자(<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, etc.)가 값들을 비교하여 큰지, 작은지 또는 같은지를 결정한다. 하지만 개발자가 정의한 고유 데이터 타입에서는 <code>&lt;</code> 메서드를 제공하여 내장 연산자들의 실행을 가져올 수 있다.</p>
<p>카드를 정확하게 순서대로 나열하는 것은 명확하지 않다. 예를 들어 3 클로버와 2 다이아몬드 중에 무엇이 더 나은가? 하나는 보다 높은 순위지만 낮은 모양이고, 다른 것은 낮은 순위지만 높은 모양이다. 카드들을 비교하기 위해서는 순위와 모양 중 무엇이 더 중요한지를 결정해야 한다.</p>
<p>답은 아마 게임을 어떤 게임을 하고 있는지에 따라서 나뉘겠지만, 간단하게 하기 위해서 우리는 모양이 더 중요하다고 임의로 선택할 것이다. 따라서 모든 스페이드는 모든 다이아몬드보다 더 중요하다.</p>
<p>해당 사항을 <code>&lt;</code>로 작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Base.&lt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> &lt;(c1::Card, c2::Card)</span><br><span class="line">    (c1.suit, c1.rank) &lt; (c2.suit, c2.rank)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="유닛-테스팅-Unit-Testing"><a href="#유닛-테스팅-Unit-Testing" class="headerlink" title="유닛 테스팅 (Unit Testing)"></a>유닛 테스팅 (Unit Testing)</h3><p>유닛 테스팅은 코드가 예상했던 대로 정확하게 작동하는지 확인해준다. 이 방법은 코드 수정 후에도 제대로 작동하는지 확인하기 위해서 사용하며, 또한 개발 중에도 코드 실행이 잘 작동하는지 미리 정의해볼 수 있다.</p>
<p>간단한 유닛 테스팅은 <code>@test</code>메크로로 실행된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> Test</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@test</span> Card(<span class="number">1</span>, <span class="number">4</span>) &lt; Card(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">Test Passed</span><br><span class="line">julia&gt; <span class="meta">@test</span> Card(<span class="number">1</span>, <span class="number">3</span>) &lt; Card(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">Test Passed</span><br></pre></td></tr></table></figure>
<p>만약 따라오는 표현식이 <code>true</code>라면 <code>@test</code>는 <code>&quot;Test Passed&quot;</code>를 반환하고 <code>false</code>라면 <code>&quot;Test Failed&quot;</code>를 반환한다 그리고 표현식이 아예 평가될 수 없다면 <code>&quot;error result&quot;</code>를 반환한다.</p>
<h3 id="덱-Decks"><a href="#덱-Decks" class="headerlink" title="덱 (Decks)"></a>덱 (Decks)</h3><p>지금까지는 카드를 만들었으며, 다음 단계로는 덱을 정의하는 것이다. 덱은 카드로 만들어졌기 때문에 각각의 덱은 카드 배열을 속성으로서 포함하는 것이 당연하다.</p>
<p>아래는 <code>Deck</code> 구조체 정의이다. 생성자는 필드로 <code>cards</code>를 가지며, 52개 카드의 기본 세트를 일반화한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Deck</span><br><span class="line">    cards :: <span class="built_in">Array</span>&#123;Card, <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Deck()</span><br><span class="line">    deck = Deck(Card[])</span><br><span class="line">    <span class="keyword">for</span> suit <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">        <span class="keyword">for</span> rank <span class="keyword">in</span> <span class="number">1</span>:<span class="number">13</span></span><br><span class="line">            push!(deck.cards, Card(suit, rank))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    deck</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>덱을 채우는 가장 쉬운 방법은 ‘중첩 루프(nested loop)’를 사용하는 것이다. 바깥의 루프는 1부터 4까지의 모양을 열거하며, 내부의 루프는 1부터 13의 순위를 열거한다. 각 반복은 최신의 모양과 순위를 포함한 새로운 <code>Card</code>를 생성하여 <code>deck.cards</code>에 밀어넣는다.</p>
<p>아래는 <code>Deck</code>을 보여주는 <code>show</code>메서드이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Base.show(io::<span class="built_in">IO</span>, deck::Deck)</span><br><span class="line">    <span class="keyword">for</span> card <span class="keyword">in</span> deck.cards</span><br><span class="line">        print(io, card, <span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    println()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>결과는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; Deck()</span><br><span class="line">A♣ <span class="number">2</span>♣ <span class="number">3</span>♣ <span class="number">4</span>♣ <span class="number">5</span>♣ <span class="number">6</span>♣ <span class="number">7</span>♣ <span class="number">8</span>♣ <span class="number">9</span>♣ <span class="number">10</span>♣ J♣ Q♣ K♣ A♦ <span class="number">2</span>♦ <span class="number">3</span>♦ <span class="number">4</span>♦ <span class="number">5</span>♦ <span class="number">6</span>♦ <span class="number">7</span>♦ <span class="number">8</span>♦ <span class="number">9</span>♦ <span class="number">10</span>♦ J♦ Q♦ K♦ A♥ <span class="number">2</span>♥ <span class="number">3</span>♥ <span class="number">4</span>♥ <span class="number">5</span>♥ <span class="number">6</span>♥ <span class="number">7</span>♥ <span class="number">8</span>♥ <span class="number">9</span>♥ <span class="number">10</span>♥ J♥ Q♥ K♥ A♠ <span class="number">2</span>♠ <span class="number">3</span>♠ <span class="number">4</span>♠ <span class="number">5</span>♠ <span class="number">6</span>♠ <span class="number">7</span>♠ <span class="number">8</span>♠ <span class="number">9</span>♠ <span class="number">10</span>♠ J♠ Q♠ K♠</span><br></pre></td></tr></table></figure>
<h3 id="추가-제거-셔플-그리고-정렬"><a href="#추가-제거-셔플-그리고-정렬" class="headerlink" title="추가, 제거, 셔플 그리고 정렬"></a>추가, 제거, 셔플 그리고 정렬</h3><p>카드를 다루려면 덱으로부터 카드를 제거하고 반환하는 함수가 필요하다. <code>pop!()</code>은 편리하게 이를 수행할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Base.pop!(deck::Deck)</span><br><span class="line">    pop!(deck.cards)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>pop!()</code>은 배열에서 마지막 카드를 제거하기 때문에</p>
<p>카드를 추가하기 위해서는 <code>push!()</code>를 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Base.push!(deck::Deck, card::Card)</span><br><span class="line">    push!(deck.cards, card)</span><br><span class="line">    deck</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>한번에 많은 작업들을 수행하지 않고 다른 메서드를 사용하는 방식을 ‘비니어(veneer)’라고도 부른다. 비니어는 원래 목공에서 사용되는 단어이며, 고급스럽게 보이기 위해 싼 목재 표면에 비싼 목재를 붙일 때 사용되는 고품질의 얇은 층을 의미한다.<br>이 예시에서 <code>push!</code>는 덱에 알맞는 배열 작동을 표현하는 얇은 메서드이며, 이 방식은 구현의 인터페이스나 외관을 향상시킨다.</p>
<p>또 다른 예시로서, <code>Random</code>을 사용하여 <code>suffle!()</code>이라는 함수를 작성해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Random</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Random.shuffle!(deck::Deck)</span><br><span class="line">    shuffle!(deck.cards)</span><br><span class="line">    deck</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="추상-데이터-타입과-서브타이핑"><a href="#추상-데이터-타입과-서브타이핑" class="headerlink" title="추상 데이터 타입과 서브타이핑"></a>추상 데이터 타입과 서브타이핑</h3><p>우리는 카드를 들고 있는 ‘손’을 표현하는 데이터 타입을 원한다. 손과 덱은 카드 모음을 만들고 추가 및 제거 작동이 필요하다는 점에서 비슷하다. 하지만 손과 덱은 다른 점도 분명히 있다. 예를 들어 포커에서는 두 손을 비교하여 누가 이길지를 비교해야 하고, 각 손의 점수를 계산해야 한다.</p>
<p>그래서 구체적인 데이터 타입을 그룹화하는 방법이 필요하다. 줄리아에서는 덱과 손의 부모처럼 제공하는 ‘추상 데이터 타입(abstract type)’을 정의하여 제공한다. 이를 ‘서브타이핑(subtyping)’이라고 한다.</p>
<p>추상 데이터 타입인 <code>CardSet</code>을 불러오자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract type</span> CardSet <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>새로운 추상 데이터 타입은 <code>abstract type</code>으로 생성된다. 선택적인 “부모” 데이터 타입도 존재하는 추상 데이터 타입을 <code>&lt;:</code> 뒤에 작성함으로써 구체회될 수 있다.</p>
<p><code>supretype</code>이 주어지지 않으면, 기본 <code>supretype</code>은 <code>Any</code>로 지정된다. <code>Any</code>는 모든 객체가 인스턴스이고 모든 데이터 타입이 서브타입인 추상 데이터 타입이다.</p>
<p>지금부터는 <code>CardSet</code>의 자식인 <code>Deck</code>읖 나타낼 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Deck &lt;: CardSet</span><br><span class="line">    cards :: <span class="built_in">Array</span>&#123;Card, <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Deck()</span><br><span class="line">    deck = Deck(Card[])</span><br><span class="line">    <span class="keyword">for</span> suit <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">        <span class="keyword">for</span> rank <span class="keyword">in</span> <span class="number">1</span>:<span class="number">13</span></span><br><span class="line">            push!(deck.cards, Card(suit, rank))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    deck</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>isa</code>연산자는 해당 객체가 주어진 데이터 타입이 맞는지 확인해준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; deck = Deck();</span><br><span class="line"></span><br><span class="line">julia&gt; deck <span class="keyword">isa</span> CardSet</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>또한 손도 <code>CardSet</code>의 종류 중 하나이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Hand &lt;: CardSet</span><br><span class="line">    cards :: <span class="built_in">Array</span>&#123;Card, <span class="number">1</span>&#125;</span><br><span class="line">    label :: <span class="built_in">String</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Hand(label::<span class="built_in">String</span>=<span class="string">""</span>)</span><br><span class="line">    Hand(Card[], label)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>52개의 새로운 카드를 손에 채우는 대신, <code>Hand</code> 생성자는 <code>cards</code>를 빈 배열과 함께 초기화한다. 선택적 인수는 생성자에 전달되어 <code>Hand</code>에 라벨을 제공한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; hand = Hand(<span class="string">"new hand"</span>)</span><br><span class="line">Hand(Card[], <span class="string">"new hand"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="추상-데이터-타입과-함수"><a href="#추상-데이터-타입과-함수" class="headerlink" title="추상 데이터 타입과 함수"></a>추상 데이터 타입과 함수</h3><p>이제부터는 <code>CardSet</code>을 인수로 가진 함수를 통해 <code>Deck</code>과 <code>Hand</code> 사이의 공통 작업을 표현할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Base.show(io::<span class="built_in">IO</span>, cs::CardSet)</span><br><span class="line">    <span class="keyword">for</span> card <span class="keyword">in</span> cs.cards</span><br><span class="line">        print(io, card, <span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.pop!(cs::CardSet)</span><br><span class="line">    pop!(cs.cards)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.push!(cs::CardSet, card::Card)</span><br><span class="line">    push!(cs.cards, card)</span><br><span class="line">    <span class="literal">nothing</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>카드를 다루기 위해 <code>pop!()</code>과 <code>push!()</code>를 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; deck = Deck()</span><br><span class="line">A♣ <span class="number">2</span>♣ <span class="number">3</span>♣ <span class="number">4</span>♣ <span class="number">5</span>♣ <span class="number">6</span>♣ <span class="number">7</span>♣ <span class="number">8</span>♣ <span class="number">9</span>♣ <span class="number">10</span>♣ J♣ Q♣ K♣ A♦ <span class="number">2</span>♦ <span class="number">3</span>♦ <span class="number">4</span>♦ <span class="number">5</span>♦ <span class="number">6</span>♦ <span class="number">7</span>♦ <span class="number">8</span>♦ <span class="number">9</span>♦ <span class="number">10</span>♦ J♦ Q♦ K♦ A♥ <span class="number">2</span>♥ <span class="number">3</span>♥ <span class="number">4</span>♥ <span class="number">5</span>♥ <span class="number">6</span>♥ <span class="number">7</span>♥ <span class="number">8</span>♥ <span class="number">9</span>♥ <span class="number">10</span>♥ J♥ Q♥ K♥ A♠ <span class="number">2</span>♠ <span class="number">3</span>♠ <span class="number">4</span>♠ <span class="number">5</span>♠ <span class="number">6</span>♠ <span class="number">7</span>♠ <span class="number">8</span>♠ <span class="number">9</span>♠ <span class="number">10</span>♠ J♠ Q♠ K♠</span><br><span class="line">julia&gt; shuffle!(deck)</span><br><span class="line">J♦ <span class="number">10</span>♣ <span class="number">8</span>♠ <span class="number">9</span>♥ <span class="number">5</span>♠ <span class="number">7</span>♣ <span class="number">6</span>♦ A♠ J♣ <span class="number">7</span>♠ <span class="number">5</span>♦ <span class="number">10</span>♥ <span class="number">3</span>♦ <span class="number">9</span>♦ <span class="number">9</span>♣ <span class="number">4</span>♣ <span class="number">8</span>♦ <span class="number">8</span>♥ <span class="number">5</span>♣ A♥ K♥ K♦ K♠ <span class="number">4</span>♦ A♦ Q♥ <span class="number">6</span>♠ <span class="number">2</span>♦ <span class="number">6</span>♥ <span class="number">2</span>♣ <span class="number">10</span>♠ <span class="number">3</span>♥ <span class="number">2</span>♥ J♥ Q♣ <span class="number">5</span>♥ <span class="number">2</span>♠ <span class="number">9</span>♠ <span class="number">10</span>♦ Q♠ <span class="number">3</span>♠ <span class="number">8</span>♣ K♣ <span class="number">7</span>♥ <span class="number">3</span>♣ J♠ <span class="number">4</span>♥ <span class="number">6</span>♣ <span class="number">7</span>♦ <span class="number">4</span>♠ A♣ Q♦</span><br><span class="line">julia&gt; card = pop!(deck)</span><br><span class="line">Q♦</span><br><span class="line">julia&gt; push!(hand, card)</span><br></pre></td></tr></table></figure>
<p>자연스러운 다음 단계는 <code>move!()</code>에서 해당 코드를 캡슐화하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> move!(cs1::CardSet, cs2::CardSet, n::<span class="built_in">Int</span>)</span><br><span class="line">    <span class="meta">@assert</span> <span class="number">1</span> ≤ n ≤ length(cs1.cards)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        card = pop!(cs1)</span><br><span class="line">        push!(cs2, card)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">nothing</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>move!()</code>는 두 개의 <code>CardSet</code> 객체와 카드를 처리할 수까지 총 세 개의 인수를 가져간다. 두 개의 <code>CardSet</code> 객체는 변경가능하며, <code>nothing</code>을 반환한다.</p>
<p>게임에서 카드들은 한 손에서 다른 손으로 가거나 손에서 덱으로 이동한다. 이런 작동들은 모두 <code>move!()</code>를 사용하면 된다. 즉, <code>cs1</code>과 <code>cs2</code>는 <code>Deck</code>이나 <code>hand</code>일 수 있다.</p>
<h3 id="데이터-타입-다이어그램"><a href="#데이터-타입-다이어그램" class="headerlink" title="데이터 타입 다이어그램"></a>데이터 타입 다이어그램</h3><p>지금까지는 프로그램의 상태를 보여주는 스택 다이어그램과 객체와 값의 속성을 보여주는 객체 다이어그램을 살펴보았다. 이런 다이어그램들은 프로그램 실행에서 스냅샷을 나타내므로 프로그램이 실행되면 이들도 변한다.</p>
<p>또한 다이어그램은 가끔 과도하게 상세하다. ‘데이터 타입 다이어그램(type diagram)’은 프로그램 구조를 더 추상적으로 표현한다. 개별적인 객체를 모두 보여주는 것 대신에 데이터 타입의 관계만을 보여준다.</p>
<p>데이터 타입 사이의 관계의 종류는 여러 가지이다.</p>
<ul>
<li><p>구체적인 데이터 타입의 객체는 다른 데이터 타입의 객체로부터 참조를 포함할 수 있다. 에를 들어, 각 직사각형은 Point의 참조를 포함하고, 덱은 카드 배열의 참조를 포함한다. 이런 관계의 종류는 “HAS-A”라고 한다. 즉, “직사각형은 포인트를 참조한다 (a Rectangle has a Point)” 인 것이다.</p>
</li>
<li><p>구체적인 데이터 타입은 서브데이터 타입으로서 추상 데이터 타입을 가진다. 이런 관계의 종류를 “IS-A”이다. 즉, “손은 Cardset의 종류이다.(a Hand is a kind of a CardSet)” 이다.</p>
</li>
<li><p>한 데이터 타입의 객체는 다른 데이터 타입의 객체를 매개 변수로 사용하거나 계산의 일부로 사용한다는 점에서 다른 데이터 타입에 따라 달라질 수 있다. 이런 관계를 “종속성(dependency)”이라고 한다.</p>
</li>
</ul>
<p><img src="/images/24.png" alt="type diagram"></p>
<p>위의 다이어그램에서 속인 빈 화살표는 IS-A 관계를 보여준다. Hand는 CardSet의 서브데이터 타입을 가지고 있다.</p>
<p>일반적인 화살표는 HAS-A 관계를 보여준다. Deck은 Card객체를 참조한다.</p>
<p>옆에 *를 가진 화살표는 다수(multiplicity)이다. 이것은 Deck이 얼마나 많은 카드를 가지고 있는지를 표시한다. 다수(multiplicity)는 <code>52</code>와 같은 간단한 숫자나 <code>like 5:7</code>같은 범위, Deck이 여러 개의 Cards를 가진다는 별 표시 등으로 표현된다.</p>
<p>종속성은 위의 다이어그램에 없다. 일반적으로 종속성은 점선 화살표로 표시되며, 종속성이 많을 때에는 생략되기도 한다.</p>
<p>다이어그램의 세부사항들은 Deck이 카드들의 배열을 포함한다는 것을 보여주지만, 배열이나 딕셔너리같은 내장 데이터 타입들은 보통 타입 다이어그램에 포함되지 않는다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>서브타이핑은 객체를 인수로 가진 함수를 호출할 때 어떤 메서드가 호출되는지 파악하기 힘드므로 디버깅하기 어렵게 만든다.</p>
<p><code>Hand</code>객체에서 작동하는 함수를 작성한다고 가정해보자. 그러면 <code>+PokerHand+s</code>, <code>+BridgeHand+s</code>와 같은 <code>hand+s</code>의 모든 종류들에 작동할 수 있도록 만들고 싶을 것이다. <code>+sort!</code>와 같은 메서드를 호출하면 추상 데이터 타입인 <code>Hand</code>에 대해 정의된 메서드를 얻을 수 있다. 하지만 서브데이터 타입 중 하나를 인수로 사용하는 <code>sort!</code>메서드가 존재한다면, 아레의 버전을 얻게 될 것이다. 이런 방식은 보통 좋지만, 때로는 헷갈릴 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Base.sort!(hand::Hand)</span><br><span class="line">    sort!(hand.cards)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>프로그램을 통한 실행 흐름에 대해 확실할 수 없는 경우 가장 간단한 해결책은 관련 메서드 시작부분에 <code>print</code>문을 추가하는 것이다. <code>shuffle!</code>이 <code>Running shuffle! Deck</code>과 같은 메시지를 출력하면, 프로그램이 작동할 때 실행 흐름을 추적한다.</p>
<p>더 나은 대안으로는 <code>@which</code> 매크로를 사용하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="meta">@which</span> sort!(hand)</span><br><span class="line">sort!(hand::Hand) <span class="keyword">in</span> Main at REPL[<span class="number">5</span>]:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>그러면 <code>Hand</code>의 <code>sort!</code> 메서드는 인수로서 <code>Hand</code> 데이터 타입의 객체 하나를 가진다.</p>
<p>설계 제안은 다음과 같다.<br>메서드를 재정의(override)할 때, 새로운 메서드의 인터페이스는 이전 메서드와 동일해야 한다. 동일한 매개 변수를 가져가고 동일한 데이터 타입을 반환하며 동이란 전제 조건 및 사후 조건을 준수해야 한다. 이 조건을 따른다면, <code>CardSet</code>과 같은 supertype의 인스턴스와 같이 작동하도록 설계된 함수가 서브데이터 타입인 <code>Deck</code>과 <code>Hand</code>의 인스턴스에도 작동한다는 것을 알 수 있다.</p>
<p>이와 같은 ‘리스코프 치환 규칙(Liskov substitution principle)’을 어긴다면, 해당 코드는 아마 붕괴할 것이다.</p>
<p><code>supertype()</code>은 데이터 타입의 supertype을 찾아준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; supertype(Deck)</span><br><span class="line">CardSet</span><br></pre></td></tr></table></figure>
<h3 id="데이터-캡슐화"><a href="#데이터-캡슐화" class="headerlink" title="데이터 캡슐화"></a>데이터 캡슐화</h3><p>이전 섹션에서는 ‘데이터 타입 지향 디자인 (type-oriented design)’이라는 개발 계획을 보여줬다. 우리는 <code>Point</code>,<code>Rectangle</code>,<code>MyTime</code>과 같이 필요한 객체들을 확인하고, 그들을 표현하기 위해 구조체를 정의하였다. 각각의 경우에는 객체와 현실세계의 실체 사이에 명백한 대응 관계가 있다.</p>
<p>그러나 때로는 어떤 객체가 필요한지, 어떻게 상호작용해야 하는지 명확하지 않다. 이 경우에는 다른 개발 계획이 필요하다. 캡슐화와 일반화를 통해 함수 인터페이스로 발견한 것과 같은 방식으로 우리는 데이터 캡슐화를 통해 데이터 타입 인터페이스를 발견할 수 있다.</p>
<p><a href="https://hyeonji-ryu.github.io/2020/03/12/Think-Julia-Chapter-13/">12장</a>에서 본 마르코프 분석이 좋은 예시이다. 아래의 코드는 글로벌 변수인 <code>prefix</code>와 <code>suffixes</code>를 정의한 것이다. 이 변수들은 여러 함수에서 사용될 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">suffixes = <span class="built_in">Dict</span>()</span><br><span class="line">prefix = []</span><br></pre></td></tr></table></figure>
<p>위의 변수들은 글로벌 변수이기 때문에 한 번에 하나의 분석만 실행할 수 있다. 두 개의 텍스트를 읽으면 접두사와 접미사가 동일한 데이터 구조에 추가되어 흥미로운 생성 텍스트가 만들어진다.</p>
<p>여러 분석을 실행하고, 별도로 유지하기 위해서는 각 분석의 상태를 객체에 캡슐화할 수 있다. 아래의 코드를 통해 확인하자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Markov</span><br><span class="line">    order :: <span class="built_in">Int64</span></span><br><span class="line">    suffixes :: <span class="built_in">Dict</span>&#123;<span class="built_in">Tuple</span>&#123;<span class="built_in">String</span>,<span class="built_in">Vararg</span>&#123;<span class="built_in">String</span>&#125;&#125;, <span class="built_in">Array</span>&#123;<span class="built_in">String</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">    prefix :: <span class="built_in">Array</span>&#123;<span class="built_in">String</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Markov(order::<span class="built_in">Int64</span>=<span class="number">2</span>)</span><br><span class="line">    new(order, <span class="built_in">Dict</span>&#123;<span class="built_in">Tuple</span>&#123;<span class="built_in">String</span>,<span class="built_in">Vararg</span>&#123;<span class="built_in">String</span>&#125;&#125;, <span class="built_in">Array</span>&#123;<span class="built_in">String</span>, <span class="number">1</span>&#125;&#125;(), <span class="built_in">Array</span>&#123;<span class="built_in">String</span>, <span class="number">1</span>&#125;())</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>그 다음, 함수를 메서드를 변환한다. 예를 들어 아래의 <code>processword</code>를 보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> processword(markov::Markov, word::<span class="built_in">String</span>)</span><br><span class="line">    <span class="keyword">if</span> length(markov.prefix) &lt; markov.order</span><br><span class="line">        push!(markov.prefix, word)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    get!(markov.suffixes, (markov.prefix...,), <span class="built_in">Array</span>&#123;<span class="built_in">String</span>, <span class="number">1</span>&#125;())</span><br><span class="line">    push!(markov.suffixes[(markov.prefix...,)], word)</span><br><span class="line">    popfirst!(markov.prefix)</span><br><span class="line">    push!(markov.prefix, word)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>작동을 변경하지 않고 디자인만 변경하는 프로그램 변환은 <a href="https://hyeonji-ryu.github.io/2020/03/02/Think-Julia-Chapter-4/">리팩토링</a>의 또 다른 예시이다.</p>
<p>이 예시는 데이터 타입 설계를 위한 개발 계획을 제시한다.</p>
<ul>
<li><p>글로벌 변수를 읽고 쓰는 함수를 시작하시오.</p>
</li>
<li><p>프로그램이 작동하면 전역 변수들과 그들을 사용하는 함수 사이의 연관성을 찾으시오.</p>
</li>
<li><p>관련 변수를 구조체의 필드로서 캡슐화하시오.</p>
</li>
<li><p>연관된 함수들을 새로운 데이터 타입의 객체가 인수인 메서드로 변환하시오.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>0. introduction</title>
    <url>/2020/03/17/mathematic-1/</url>
    <content><![CDATA[<p>글을 시작하기에 앞서 해당 글은 Marc Peter Deisenroth, A. Aldo Faisal, Cheng Soon Ong의 저서인 mathematics for machine learning을 바탕으로 요약 및 정리한 글임을 알려드립니다.<br><a id="more"></a></p>
<p>머신러닝(Machine learning)은 데이터로부터 유용한 정보를 자동으로 추출해주는 알고리즘을 디자인하는 것이다. 강조할 부분은 “자동(automatic)”이다. 머신러닝은 많은 데이터셋에 적용하여 의미있는 것들을 생산하는 범용 방법론(general-purpose methodology)에 관심이 있다. 머신러닝을 설명하는 세 가지의 핵심 단어가 있다. 데이터, 모델, 그리고 학습이다.</p>
<p>머신러닝의 목적은 데이터로부터 가치있는 패턴을 찾는 방법을 개발하는 방법을 디자인하는 것이다. 이 목적에 도달하기 위해서는 주어진 데이터를 일반화하는 프로세스를 가진 모델을 디자인한다. 이후 학습에서는 모델의 매개 변수를 최적화하여 데이터의 패턴과 구조를 자동으로 찾을 수 있게 한다. 결국 머신러닝의 최종 목표는 위의 과정을 거쳐 준비된 모델이 새로운 데이터를 받아도 패턴을 잘 찾을 수 있는 모델을 구축하는 것이다.</p>
<p>복잡한 머신러닝이 구축되는 원리를 알기 위해서는 수학적 기초가 중요하다. 원리를 이해하는 것은 새로운 머신러닝 방법들을 생산하고, 존재하는 방법들을 디버깅할 수 있다.</p>
]]></content>
      <categories>
        <category>mathematics for machine learning</category>
      </categories>
      <tags>
        <tag>머신러닝</tag>
        <tag>mathematics</tag>
        <tag>machine learning</tag>
        <tag>mathematics for machine learning</tag>
        <tag>머신러닝 수학</tag>
        <tag>수학</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 다중 디스패치</title>
    <url>/2020/03/17/Think-Julia-Chapter-17/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap17" target="_blank" rel="noopener">Multiple Dispatch</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="다중-디스패치-Multiple-Dispatch"><a href="#다중-디스패치-Multiple-Dispatch" class="headerlink" title="다중 디스패치 (Multiple Dispatch)"></a>다중 디스패치 (Multiple Dispatch)</h2><p>줄리아에서는 다른 데이터 타입들에서도 작동하는 코드를 작성할 수 있으며, 해당 코드를 ‘제네릭 프로그래밍(generic programming)’이라고 한다.</p>
<p>이번 장에서는 줄리아에서 데이터 타입 선언 사용하는 방법에 설명하고 인수의 데이터 타입에 따라 다른 작동을 구현하는 함수인 다중 디스패치(Multiple Dispatch)에 대해 알아볼 것이다.</p>
<h3 id="데이터-타입-선언-Type-Declarations"><a href="#데이터-타입-선언-Type-Declarations" class="headerlink" title="데이터 타입 선언 (Type Declarations)"></a>데이터 타입 선언 (Type Declarations)</h3><p><code>::</code> 연산자는 변수나 표현식에 ‘데이터 타입 주석(type annotations)’을 붙인다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; (<span class="number">1</span> + <span class="number">2</span>) :: <span class="built_in">Float64</span></span><br><span class="line">ERROR: <span class="built_in">TypeError</span>: <span class="keyword">in</span> typeassert, expected <span class="built_in">Float64</span>, got <span class="built_in">Int64</span></span><br><span class="line">julia&gt; (<span class="number">1</span> + <span class="number">2</span>) :: <span class="built_in">Int64</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>이런 방식은 개발자가 예측한 대로 프로그램이 작동하는지 확인하는데 도움을 준다.</p>
<p>또한 <code>::</code> 연산자는 변수 옆인 할당문 왼쪽 측면에도 붙을 수도 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">function</span> returnfloat()</span><br><span class="line">           x::<span class="built_in">Float64</span> = <span class="number">100</span></span><br><span class="line">           x</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">returnfloat (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line">julia&gt; x = returnfloat()</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line">julia&gt; typeof(x)</span><br><span class="line"><span class="built_in">Float64</span></span><br></pre></td></tr></table></figure>
<p>변수 <code>x</code>는 데이터 타입이 항상 <code>Float64</code>이며, 값은 부동 소수점으로 변환된다.</p>
<p>또한 데이터 타입 주석은 함수의 정의 헤더 부분에도 불일 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> sinc(x)::<span class="built_in">Float64</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    sin(x)/(x)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>sinc()</code>의 반환 값은 항상 <code>Float64</code>로 변환된다.</p>
<p>데이터 타입이 생략될 때, 줄리아에서는 항상 데이터 타입 <code>Any</code>을 값으로 사용할 수 있다.</p>
<h3 id="메서드-Methods"><a href="#메서드-Methods" class="headerlink" title="메서드 (Methods)"></a>메서드 (Methods)</h3><p><a href="https://hyeonji-ryu.github.io/2020/03/16/chapter-16/#more">구조체와 함수</a>에서 <code>MyTime</code>이라는 구조체를 정의하였다. <code>printtime()</code>이라는 함수를 사용하여 작성해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Printf</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> MyTime</span><br><span class="line">    hour :: <span class="built_in">Int64</span></span><br><span class="line">    minute :: <span class="built_in">Int64</span></span><br><span class="line">    second :: <span class="built_in">Int64</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> printtime(time)</span><br><span class="line">    <span class="meta">@printf</span>(<span class="string">"%02d:%02d:%02d"</span>, time.hour, time.minute, time.second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>보다시피, 데이터 타입 선언은 성능상의 이유로 구조체 정의의 필드에 추가될 수 있다.</p>
<p>위 함수를 호출하려면, <code>MyTime</code> 객체를 인수로 전달해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; start = MyTime(<span class="number">9</span>, <span class="number">45</span>, <span class="number">0</span>)</span><br><span class="line">MyTime(<span class="number">9</span>, <span class="number">45</span>, <span class="number">0</span>)</span><br><span class="line">julia&gt; printtime(start)</span><br><span class="line"><span class="number">09</span>:<span class="number">45</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p><code>MyTime</code> 객체만을 인수로 받는다는 메서드를 <code>printtime()</code>에 추가하기 위해서는 함수 정의에 <code>::MyTime</code>을 인수로 작성하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printtime(time::MyTime)</span><br><span class="line">    <span class="meta">@printf</span>(<span class="string">"%02d:%02d:%02d"</span>, time.hour, time.minute, time.second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>메서드는 특정 기호가 포함된 함수 정의이다. <code>printtime()</code>은 <code>MyTime</code> 객체만을 인수로 받는다.</p>
<p><code>printtime()</code>를 <code>MyTime</code> 객체로 호출하는 것은 아래와 같은 결과를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; printtime(start)</span><br><span class="line"><span class="number">09</span>:<span class="number">45</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>아래는 <code>::</code>을 사용하지 않고 함수를 재정의하여 모든 데이터 타입을 인수로 허용한 함수이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printtime(time)</span><br><span class="line">    println(<span class="string">"I don't know how to print the argument time."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>만약 <code>MyTime</code> 객체가 아닌 다른 데이터 타입을 인수로 하여 <code>printtime()</code>을 호출한다면 아래와 같은 결과를 얻는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; printtime(<span class="number">150</span>)</span><br><span class="line"><span class="literal">I</span> don't know how to print the argument time.</span><br></pre></td></tr></table></figure>
<h3 id="추가적-예시들-Additional-Examples"><a href="#추가적-예시들-Additional-Examples" class="headerlink" title="추가적 예시들 (Additional Examples)"></a>추가적 예시들 (Additional Examples)</h3><p>앞서 <a href="https://hyeonji-ryu.github.io/2020/03/16/Think-Julia-Chapter-16/#more">15장</a>에서 사용했던 <code>increment()</code>에 인수를 세부적으로 설정하여 재정의할 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> increment(time::MyTime, seconds::<span class="built_in">Int64</span>)</span><br><span class="line">    seconds += timetoint(time)</span><br><span class="line">    inttotime(seconds)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>한번 더 짚고 넘어가자면, 위의 함수는 ‘순수 함수(pure function)’이며 ‘변경자(modifier)’는 아니다.</p>
<p>아래의 코드는 <code>increment()</code>를 불러오는 방법이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; start = MyTime(<span class="number">9</span>, <span class="number">45</span>, <span class="number">0</span>)</span><br><span class="line">MyTime(<span class="number">9</span>, <span class="number">45</span>, <span class="number">0</span>)</span><br><span class="line">julia&gt; increment(start, <span class="number">1337</span>)</span><br><span class="line">MyTime(<span class="number">10</span>, <span class="number">7</span>, <span class="number">17</span>)</span><br></pre></td></tr></table></figure>
<p>인수 순서를 바꿔서 넣는다면, 오류 메시지를 얻는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; increment(<span class="number">1337</span>, start)</span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching increment(::<span class="built_in">Int64</span>, ::MyTime)</span><br></pre></td></tr></table></figure>
<p>그 이유는 메서드에 정의된 순서가 <code>increment(time::MyTime, seconds::Int64)</code>이지 <code>increment(seconds::Int64, time::MyTime)</code>가 아니기 때문이다.</p>
<p>다음으로는 두 인수를 비교하는 <code>isafter()</code>를 <code>MyTime</code> 객체만 인수로 받을 수 있도록 설정해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isafter(t1::MyTime, t2::MyTime)</span><br><span class="line">    (t1.hour, t1.minute, t1.second) &gt; (t2.hour, t2.minute, t2.second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>또한 선택적 인수를 사용하면 ‘다중 메서드 정의(multiple method definitions)’가 구현된 셈이다. 예시는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> f(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">    a + <span class="number">2</span>b</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위 함수는 아래의 세 가지 메서드로 변환된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">f(a, b) = a + <span class="number">2</span>b</span><br><span class="line">f(a) = f(a, <span class="number">2</span>)</span><br><span class="line">f() = f(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>이 표현식들은 유효한 줄리아 메서드 정의이며, 함수 또는 메서드를 정의하는 단축 표기 방법이다.</p>
<h3 id="생성자-Constructors"><a href="#생성자-Constructors" class="headerlink" title="생성자 (Constructors)"></a>생성자 (Constructors)</h3><p>생성자(Constructors)는 객체를 만들기 위해서 호출되는 특별한 함수이다. <code>MyTime</code>의 기본 생성자 메서드는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">MyTime(hour, minute, second)</span><br><span class="line">MyTime(hour::<span class="built_in">Int64</span>, minute::<span class="built_in">Int64</span>, second::<span class="built_in">Int64</span>)</span><br></pre></td></tr></table></figure>
<p>또한 자체 ‘외부 생성자(outer constructor)’ 메서드를 추가할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> MyTime(time::MyTime)</span><br><span class="line">    MyTime(time.hour, time.minute, time.second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이 메서드는 새로운 <code>MyTime</code> 객체가 인수의 복사본이기 때문에 ‘복사 생성자(copy constructor)’라고도 부른다.</p>
<p>인수를 변경하지 못하게 하려면, ‘내부 생성자(inner constructor)’ 메서드가 필요하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyTime</span><br><span class="line">    hour :: <span class="built_in">Int64</span></span><br><span class="line">    minute :: <span class="built_in">Int64</span></span><br><span class="line">    second :: <span class="built_in">Int64</span></span><br><span class="line">    <span class="keyword">function</span> MyTime(hour::<span class="built_in">Int64</span>=<span class="number">0</span>, minute::<span class="built_in">Int64</span>=<span class="number">0</span>, second::<span class="built_in">Int64</span>=<span class="number">0</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">0</span> ≤ minute &lt; <span class="number">60</span>, <span class="string">"Minute is not between 0 and 60."</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">0</span> ≤ second &lt; <span class="number">60</span>, <span class="string">"Second is not between 0 and 60."</span>)</span><br><span class="line">        new(hour, minute, second)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이제 구조체인 <code>MyTime</code>은 4개의 내부 생성자 메서드를 가지고 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">MyTime()</span><br><span class="line">MyTime(hour::<span class="built_in">Int64</span>)</span><br><span class="line">MyTime(hour::<span class="built_in">Int64</span>, minute::<span class="built_in">Int64</span>)</span><br><span class="line">MyTime(hour::<span class="built_in">Int64</span>, minute::<span class="built_in">Int64</span>, second::<span class="built_in">Int64</span>)</span><br></pre></td></tr></table></figure>
<p>내부 생성자 메서드는 항상 데이터 타입 선언 블럭 내에 정의되며, 새로 선언된 데이터 타입의 객체를 만드는 <code>new()</code>라는 특수 함수에 접근할 수 있다.</p>
<p><strong>WARNING</strong><br>내부 생성자가 정의되었다면 기본 생성자는 사용할 수 없다. 따라서 필요한 내부 생성자는 명확하게 작성해야 한다.</p>
<p>로컬 함수인 <code>new()</code>의 인수 없이 사용하는 두 번째 메서드는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutable struct</span> MyTime</span><br><span class="line">    hour :: <span class="built_in">Int</span></span><br><span class="line">    minute :: <span class="built_in">Int</span></span><br><span class="line">    second :: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">function</span> MyTime(hour::<span class="built_in">Int64</span>=<span class="number">0</span>, minute::<span class="built_in">Int64</span>=<span class="number">0</span>, second::<span class="built_in">Int64</span>=<span class="number">0</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">0</span> ≤ minute &lt; <span class="number">60</span>, <span class="string">"Minute is between 0 and 60."</span>)</span><br><span class="line">        <span class="meta">@assert</span>(<span class="number">0</span> ≤ second &lt; <span class="number">60</span>, <span class="string">"Second is between 0 and 60."</span>)</span><br><span class="line">        time = new()</span><br><span class="line">        time.hour = hour</span><br><span class="line">        time.minute = minute</span><br><span class="line">        time.second = second</span><br><span class="line">        time</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위 코드는 필드 하나가 자체 구조체가 되는 ‘재귀 데이터 구조(recursive data structures)’를 가능하게 한다. 해당 예시의 구조체는 인스턴스화 이후에 필드가 수정되기 때문에 변경 가능해야 한다.</p>
<h3 id="show"><a href="#show" class="headerlink" title="show"></a><code>show</code></h3><p><code>show()</code>는 객체를 문자열로 표현하여 반환하는 특별한 함수이다. 아래의 코드는 <code>MyTime</code> 객체에 <code>show</code> 메서드를 사용한 예시이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Printf</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.show(io::<span class="built_in">IO</span>, time::MyTime)</span><br><span class="line">    <span class="meta">@printf</span>(io, <span class="string">"%02d:%02d:%02d"</span>, time.hour, time.minute, time.second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>Base.show</code> 함수에 새로운 메서드를 추가하고 싶기 때문에 <code>show</code>앞에 <code>Base</code>를 작성하였다.</p>
<p>객체를 출력하면 줄리아는 <code>show()</code>를 실행한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; time = MyTime(<span class="number">9</span>, <span class="number">45</span>)</span><br><span class="line"><span class="number">09</span>:<span class="number">45</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>새로운 복합 데이터 타입을 작성할 때는 항상 외부 생성자를 사용한다. 이렇게 하면 객체와 <code>show</code>를 인스턴스하기 더 쉬워져서 디버깅에 유용하다.</p>
<h3 id="연산자-오버로딩-operator-overloading"><a href="#연산자-오버로딩-operator-overloading" class="headerlink" title="연산자 오버로딩 (operator overloading)"></a>연산자 오버로딩 (operator overloading)</h3><p>연산자 메서드를 정의함으로써, 개발자가 정의한 고유 데이터 타입 안에서 연산자들이 어떻게 작동하는지를 지정할 수 있다. 예를 들어 만약 두 개의 <code>MyTime</code> 인수와 <code>+</code>메서드를 정의하였다면, <code>MyTime</code> 객체에서 <code>+</code> 연산자를 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Base.+</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> +(t1::MyTime, t2::MyTime)</span><br><span class="line">    seconds = timetoint(t1) + timetoint(t2)</span><br><span class="line">    inttotime(seconds)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>import</code>문은 메서드를 추가할 수 있도록 <code>+</code> 연산자를 로컬 범위에서 가져온다.</p>
<p>아래의 코드는 정의한 <code>+</code> 연산자를 어떻게 사용하는지를 보여준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; start = MyTime(<span class="number">9</span>, <span class="number">45</span>)</span><br><span class="line"><span class="number">09</span>:<span class="number">45</span>:<span class="number">00</span></span><br><span class="line">julia&gt; duration = MyTime(<span class="number">1</span>, <span class="number">35</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">01</span>:<span class="number">35</span>:<span class="number">00</span></span><br><span class="line">julia&gt; start + duration</span><br><span class="line"><span class="number">11</span>:<span class="number">20</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>이제부터는 <code>+</code> 연산자를 <code>MyTime</code>객체와 사용하면 줄리아는 위에서 만든 메서드를 가져오며, REPL이 결과를 보여줄 때는 줄리아가 앞에서 작성한 <code>show</code>를 사용하여 보여준다.</p>
<p>개발자가 정의한 데이터 타입에서 작동하도록 연산자들의 작동을 추가하는 것을 ‘연산자 오버로딩(operator overloading)’이라고 한다.</p>
<h3 id="다중-디스패치-Multiple-dispatch"><a href="#다중-디스패치-Multiple-dispatch" class="headerlink" title="다중 디스패치 (Multiple dispatch)"></a>다중 디스패치 (Multiple dispatch)</h3><p>이전 섹션에서는 <code>MyTime</code>객체끼리 더하는 과정을 보았다. 하지만 만약 <code>MyTime</code>객체에 정수를 더하고 싶다면 어떻게 해야할까?</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> +(time::MyTime, seconds::<span class="built_in">Int64</span>)</span><br><span class="line">    increment(time, seconds)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 함수는 <code>+</code> 연산자가 <code>MyTime</code>객체와 정수가 더해지는 방법을 메서드로 정의하였다.</p>
<p>두 개를 더한 결과는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; start = MyTime(<span class="number">9</span>, <span class="number">45</span>)</span><br><span class="line"><span class="number">09</span>:<span class="number">45</span>:<span class="number">00</span></span><br><span class="line">julia&gt; start + <span class="number">1337</span></span><br><span class="line"><span class="number">10</span>:<span class="number">07</span>:<span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>덧셈은 교환법칙이 성립하기 때문에 인수 순서가 변경된 메서드도 추가한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> +(seconds::<span class="built_in">Int64</span>, time::MyTime)</span><br><span class="line">  time + seconds</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>인수 순서를 바꿔도 똑같은 결과를 얻을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="number">1337</span> + start</span><br><span class="line"><span class="number">10</span>:<span class="number">07</span>:<span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>함수를 적용할 때 어떤 메서드가 적합한지 선택하는 것을 ‘디스패치(dispatch)’라고 한다. 줄리아는 디스패치 프로세스가 주어진 인수의 수와 데이터 타입에 따라 호출할 함수의 메서드를 선택할 수 있도록 한다. 함수의 인수를 모두 사용하여 호출할 메서드를 선택하는 것을 ‘다중 디스패치(multiple dispatch)’라고 한다.</p>
<h3 id="제네릭-프로그래밍-Generic-Programming"><a href="#제네릭-프로그래밍-Generic-Programming" class="headerlink" title="제네릭 프로그래밍 (Generic Programming)"></a>제네릭 프로그래밍 (Generic Programming)</h3><p>다중 디스패치는 유용하지만 항상 필요한 것은 아니다. 다른 데이터 타입을 인수로 하여 함수를 작성하면 다중 디스패치를 사용하지 않아도 된다.</p>
<p>지금까지 문자열에 대해 작성한 많은 함수들은 다른 데이터 타입의 시퀀스에도 작동한다. 예를 들어, <a href="https://hyeonji-ryu.github.io/2020/03/10/Think-Julia-Chapter-11/">딕셔너리로 카운팅하기</a>에서 사용한 단어의 개수를 세어주는 <code>histogram()</code> 을 보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> histogram(s)</span><br><span class="line">    d = <span class="built_in">Dict</span>()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s</span><br><span class="line">        <span class="keyword">if</span> c ∉ keys(d)</span><br><span class="line">            d[c] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            d[c] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    d</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이 함수에서 <code>s</code>의 요소는 해시(hashable)할 수 있기에 딕셔너리의 키(key)로 사용될 수 있고, 따라서 리스트, 튜플, 심지어 딕셔너리에서도 작동한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = (<span class="string">"spam"</span>, <span class="string">"egg"</span>, <span class="string">"spam"</span>, <span class="string">"spam"</span>, <span class="string">"bacon"</span>, <span class="string">"spam"</span>)</span><br><span class="line">(<span class="string">"spam"</span>, <span class="string">"egg"</span>, <span class="string">"spam"</span>, <span class="string">"spam"</span>, <span class="string">"bacon"</span>, <span class="string">"spam"</span>)</span><br><span class="line">julia&gt; histogram(t)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Any</span>,<span class="built_in">Any</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  <span class="string">"bacon"</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="string">"spam"</span>  =&gt; <span class="number">4</span></span><br><span class="line">  <span class="string">"egg"</span>   =&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>여러 데이터 타입에서도 작동하는 함수들을 폴리모픽(polymorphic)이라고 한다. 폴리모픽은 코드를 재사용할 수 있도록 도와준다.</p>
<p>예를 들어, 시퀀스의 요소들의 합을 제공하는 내장함수인 <code>sum()</code>은 덧셈을 가지고 있는 모든 데이터 타입의 시퀀스에 작동한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t1 = MyTime(<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">01</span>:<span class="number">07</span>:<span class="number">02</span></span><br><span class="line">julia&gt; t2 = MyTime(<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br><span class="line"><span class="number">01</span>:<span class="number">05</span>:<span class="number">08</span></span><br><span class="line">julia&gt; t3 = MyTime(<span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">01</span>:<span class="number">05</span>:<span class="number">00</span></span><br><span class="line">julia&gt; sum((t1, t2, t3))</span><br><span class="line"><span class="number">03</span>:<span class="number">17</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>일반적으로 함수 내부의 모든 연산들이 지정된 데이터 타입으로 작동하면, 함수는 그 유형에도 작동된다.</p>
<p>폴리모픽의 가장 좋은 종류는 의도하지 않았는데 이미 작성된 함수가 해당 데이터 타입에 적용가능하다는 것을 알게되는 것이다.</p>
<h3 id="인터페이스와-구현-Interface-and-Implementation"><a href="#인터페이스와-구현-Interface-and-Implementation" class="headerlink" title="인터페이스와 구현 (Interface and Implementation)"></a>인터페이스와 구현 (Interface and Implementation)</h3><p>다중 디스패치의 목적 중 하나는 소프트웨어의 유지 및 보수를 쉽게 만드는 것이다. 즉, 시스템의 다른 부분이 변경될 때 프로그램을 계속 작동시키고 새로운 요구 사항을 충족하도록 프로그램을 수정하는 것이다.</p>
<p>이러한 목표를 달성하는 데 도움이 되는 디자인 원칙은 인터페이스(interface)를 구현(implementation)과 분리하는 것이다. 즉 데이터 타입이 지정된 인수를 가진 메서드는 해당 데이터 타입의 필드가 어떻게 표현되는지에 의존해서는 안된다는 것을 의미한다.</p>
<p>예를 들어, 이 장에서 우리는 시간을 나타내는 구조체를 개발했다. 이 데이터 타입으로 지정된 인수가 있는 메서드는 <code>timetoint</code>, <code>isafter</code> 그리고 <code>+</code>가 있다. 우리는 이 메서드들을 여러 방법으로 구현할 수 있다. 구현의 세부 사항들은 <code>MyTime</code>을 어떻게 표현하는지에 의존한다. 이 장에서 <code>MyTime</code>의 필드는 <code>hour</code>, <code>minute</code>, <code>second</code> 이다.</p>
<p>다른 방법으로는 자정 이후로 <code>second</code>의 수를 단일 정수로 나타낸 필드로 대체할 수 있다. 이 구현은 <code>isafter</code>와 같은 함수를 더 쉽게 작성할 수 있도록 하지만 다른 함수들을 더 어렵게 만든다.</p>
<p>새로운 데이터 타입을 배포한 후 더 좋은 구현을 발견할 수 있다. 만약 프로그램의 다른 부분이 해당 데이터 타입을 사용중이라면, 인터페이스를 변경하는데 시간이 많이 걸리고 오류가 발생할 수 있다.</p>
<p>그러나 인터페이스를 신중하게 디자인한 경우 인터페이스를 변경하지 않고 구현을 변경할 수 있다. 즉, 프로그램의 다른 부분은 변경할 필요가 없게 된다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>만약 함수에 대해 둘 이상의 메서드를 지정한다면, 적절한 인수를 사용하여 함수를 호출하기가 어려울 수 있다. 줄리아는 함수 메서드를 조사할 수 있다.</p>
<p>메서드가 주어진 함수에서 사용할 수 있는지 알기 위해서는 <code>methods()</code>를 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; methods(printtime)</span><br><span class="line"><span class="comment"># 2 methods for generic function "printtime":</span></span><br><span class="line">[<span class="number">1</span>] printtime(time::MyTime) <span class="keyword">in</span> Main at REPL[<span class="number">3</span>]:<span class="number">2</span></span><br><span class="line">[<span class="number">2</span>] printtime(time) <span class="keyword">in</span> Main at REPL[<span class="number">4</span>]:<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>이 예시에서는 <code>printtime()</code>가 2개의 메서드를 가지고 있으며, 하나는 <code>MyTime</code> 인수이고 다른 하나는 <code>Any</code> 인수이다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 구조체와 함수</title>
    <url>/2020/03/16/Think-Julia-Chapter-16/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap16" target="_blank" rel="noopener">Structs and Functions</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="구조체와-함수-Structs-and-Functions"><a href="#구조체와-함수-Structs-and-Functions" class="headerlink" title="구조체와 함수 (Structs and Functions)"></a>구조체와 함수 (Structs and Functions)</h2><p>저번 장에서 새로운 복합 데이터 타입을 생성하는 방법에 대해서 알아보았다면, 지금부터는 개발자가 정의한 고유 객체들을 매개 변수로 사용하여 결과로 반환하는 함수를 작성해볼 것이다. 따라서 이번 장에서는 “함수적 프로그래밍 스타일(unctional programming style)”과 새로운 두 가지 프로그램 개발 계획을 볼 것이다.</p>
<h3 id="시간-Time"><a href="#시간-Time" class="headerlink" title="시간 (Time)"></a>시간 (Time)</h3><p>복합 데이터 타입의 또 다른 에시로서, 시간을 기록하는 <code>MyTime</code>을 <code>struct</code>로 정의할 것이다. 코드는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Represents the time of day.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fields: hour, minute, second</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">struct</span> MyTime</span><br><span class="line">    hour</span><br><span class="line">    minute</span><br><span class="line">    second</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>Time</code>이라는 이름은 이미 줄리아에서 사용 중이기 때문에, 충돌을 방지하기 위해 <code>MyTime</code>로 결정하였다. 이제 새로운 <code>MyTime</code> 객체를 생성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; time = MyTime(<span class="number">11</span>, <span class="number">59</span>, <span class="number">30</span>)</span><br><span class="line">MyTime(<span class="number">11</span>, <span class="number">59</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/22.png" alt="object diagram"></p>
<p><code>MyTime</code> 객체 다이어그램은 위와 같다.</p>
<h3 id="순수-함수-Pure-Functions"><a href="#순수-함수-Pure-Functions" class="headerlink" title="순수 함수 (Pure Functions)"></a>순수 함수 (Pure Functions)</h3><p>지금부터 시간 값을 추가하는 두 개의 함수를 작성할 것이다. 두 개의 함수 중 하나는 ‘순수 함수(pure functions)’이며 다른 하나는 ‘변경자(modifiers)’이다. 또한 이 함수들은 간단한 프로토타입으로 시작하여 복잡한 문제를 점진적으로 해결하는 방법인 ‘프로토타입 및 패치(prototype and patch)’를 호출하여 개발 계획도 시연할 것이다.</p>
<p>아래의 코드는 <code>addtime</code>의 간단한 프로토타입이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> addtime(t1, t2)</span><br><span class="line">    MyTime(t1.hour + t2.hour, t1.minute + t2.minute, t1.second + t2.second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이 함수는 <code>MyTime</code> 객체를 새로 생성한 후, 필드를 초기화하고 새로운 객체에 대한 참조를 반환한다. 이렇게 인수로 전달된 객체를 수정하지 않고 반환하는 함수를 ‘순수 함수’라고 한다. 즉, 인수로 전달된 객체들은 값을 제공하거나 보여지는 정도만 실행되고 어떤 영향도 받지 않는다.</p>
<p>위 함수를 테스트하기 위해서 두 개의 <code>MyTime</code> 객체를 만든다. <code>start</code>에는 ‘Monty Python and the Holy Grail’ 영화의  시작시간이 포함되고, <code>duration</code>에는 영화의 상영 시간인 1시간 35분이 포함된다.</p>
<p><code>addtime</code>은 영화가 끝난 시간을 보여준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; start = MyTime(<span class="number">9</span>, <span class="number">45</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; duration = MyTime(<span class="number">1</span>, <span class="number">35</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; done = addtime(start, duration);</span><br><span class="line"></span><br><span class="line">julia&gt; printtime(done)</span><br><span class="line"><span class="number">10</span>:<span class="number">80</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>결과는 <code>10:80:00</code>으로 우리가 원하던 시간은 아니다. 문제는 해당 함수가 분단위와 초단위가 60을 초과하는 경우를 처리하지 못한다는 것이다. 그렇게 되면 60분을 1시간으로, 60초를 1분으로 헤당 열에 반입해야 한다. 이를 해결한 코드는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> addtime(t1, t2)</span><br><span class="line">    second = t1.second + t2.second</span><br><span class="line">    minute = t1.minute + t2.minute</span><br><span class="line">    hour = t1.hour + t2.hour</span><br><span class="line">    <span class="keyword">if</span> second &gt;= <span class="number">60</span></span><br><span class="line">        second -= <span class="number">60</span></span><br><span class="line">        minute += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> minute &gt;= <span class="number">60</span></span><br><span class="line">        minute -= <span class="number">60</span></span><br><span class="line">        hour += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    MyTime(hour, minute, second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 함수는 정확하게 작동하지만 코드가 복잡해졌다. 이후 더 짧은 대안들을 배울 것이다.</p>
<h3 id="변경자-Modifiers"><a href="#변경자-Modifiers" class="headerlink" title="변경자 (Modifiers)"></a>변경자 (Modifiers)</h3><p>때로는 함수가 매개 변수로 얻는 객체를 수정하는 것이 더 유용하다. 이 경우에는 변경 사항이 호출자에게 보여진다. 이런 방식으로 작동하는 함수를 ‘변경자(Modifiers)’라고 한다.</p>
<p>인수인 ‘second’의 숫자를 <code>MyTime</code> 객체에 추가하는 <code>increment!()</code>는 변경자를 사용하여 자연스럽게 작성할 수 있다. 초안은 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> increment!(time, seconds)</span><br><span class="line">    time.second += seconds</span><br><span class="line">    <span class="keyword">if</span> time.second &gt;= <span class="number">60</span></span><br><span class="line">        time.second -= <span class="number">60</span></span><br><span class="line">        time.minute += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> time.minute &gt;= <span class="number">60</span></span><br><span class="line">        time.minute -= <span class="number">60</span></span><br><span class="line">        time.hour += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>첫 번째 줄은 기본적인 작동을 수행하며, 나머지 줄은 우리가 봤던 특별한 경우들을 처리한다.</p>
<p>이 함수는 정확한가? 만약 <code>second</code>가 60보다 크면 어떻게 작동하는가?</p>
<p>함수가 제대로 작동하는지 확인하기 위해서는 <code>time.second</code> 가 60이 넘을 때까지 여러 번 실행해야 한다. 이를 위한 방법으로는 <code>if</code>문을 <code>while</code>문으로 바꾸는 것이다. 이것은 정확하게 작동하지만, 효과적이지는 않다.</p>
<h3 id="프로토타이핑-vs-계획-Prototyping-Versus-Planning"><a href="#프로토타이핑-vs-계획-Prototyping-Versus-Planning" class="headerlink" title="프로토타이핑 vs. 계획 (Prototyping Versus Planning)"></a>프로토타이핑 vs. 계획 (Prototyping Versus Planning)</h3><p>개발자가 시연하고 있는 개발 계획을 ‘프로토타입 및 패치(prototype and patch)’라고 한다. 각 함수에서 기본 계산을 실행하는 프로토타입을 만들어 테스트 한 후, 발생한 오류들을 패치한다.</p>
<p>이 방법은 문제가 무엇인지 깊게 이해하지 못한 경우에 특히 효과적이다. 그러나 점진적인 수정방법은 모든 오류를 한번에 볼 수 없기에, 가끔 불필요하게 복잡한 코드로 수정하도록 한다.</p>
<p>위 문제의 대안은 문제에 대한 높은 수준의 통찰력을 통해 프로그래밍이 훨씬 쉬워질 수 있도록 설계하는 개발방식이다. 이전 ‘초단위 문제’의 경우, 필요한 통찰력은 <code>Time</code> 객체가 <a href="https://en.wikipedia.org/wiki/Sexagesimal" target="_blank" rel="noopener">육십진법</a>의 3개의 숫자라는 것이다. 초단위 <code>second</code>속성이 1열, 분단위 <code>minute</code>속성이 60열, 시단위 <code>hour</code>속성이 3600열이다.</p>
<p><code>addtime()</code>와 <code>increment!()</code>를 작성할 때, 육십진법에서는 한 열에서 다음 열로 이동해야 하기 때문에 이를 효과적으로 추가하는 방식을 고려하고 싶다.</p>
<p>이런 생각은 전체적인 문제의 다른 접근법을 제안한다. <code>MyTime</code> 객체를 정수로 변환하고 컴퓨터의 계산을 활용하는 것이다.</p>
<p>아래의 함수는 <code>MyTime</code> 객체를 정수로 변환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> timetoint(time)</span><br><span class="line">    minutes = time.hour * <span class="number">60</span> + time.minute</span><br><span class="line">    seconds = minutes * <span class="number">60</span> + time.second</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>그리고 아래의 함수는 정수를 <code>MyTime</code>으로 변환한다. (<code>divrem</code>은 첫 번째 인수를 두 번째 인수로 나누고 몫과 나머지를 튜플로 반환한다)</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> inttotime(seconds)</span><br><span class="line">    (minutes, second) = divrem(seconds, <span class="number">60</span>)</span><br><span class="line">    hour, minute = divrem(minutes, <span class="number">60</span>)</span><br><span class="line">    MyTime(hour, minute, second)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 함수가 올바른지 확인하기 위해서는 약간의 생각과 테스트를 진행하면 된다. 테스트하는 방법은 <code>timetoint(inttotime(x)) == x</code>가 많은 <code>x</code>값에도 작동하는지 확인하는 것이다. 일관성 검사(consistency check)의 예이다.</p>
<p>위의 함수가 정확하다고 확신한다면, <code>addtime</code>을 다시 작성하는데 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> addtime(t1, t2)</span><br><span class="line">    seconds = timetoint(t1) + timetoint(t2)</span><br><span class="line">    inttotime(seconds)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>해당 버전은 처음보다 훨씬 쉽고 명확하다.</p>
<p>어떤면에서 육십진법에서 십진법 또는 그 반대로 변환하는 것은 시간을 처리하는 것보다 어렵다. 기본 변환이 더 추상적이기 때문이다.</p>
<p>하지만 시간을 육십진법으로 취급하고 <code>timetoint()</code> 및 <code>inttotime()</code>와 같은 변환 함수를 작성하는데 투자할 수 있는 통찰력만 있다면 더 짧고 읽기 쉬운 안정적인 프로그램을 만들 수 있다.</p>
<p>또한 나중에 함수를 추가하는 것이 더 쉽다. 예를 들어, 두 개의 <code>MyTime</code>을 빼서 둘 사이의 지속 시간을 찾는다고 가정해보자. 가장 편한 방법은 두 개를 빼주는 것이다. 변환 함수를 사용하면 더 쉽고 정확하게 뺄 수 있다.</p>
<p>아이러니하게도, 떄로는 문제를 더 일반화하여 만드는 것이 더 쉽다. 그 이유는 특별한 경우도 적고 오류 가능성도 적어지기 때문이다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p><code>MyTime</code> 객체는 <code>minute</code>과 <code>second</code>의 값이 0부터 60사이(0은 포함, 60은 불포함)이고, <code>hour</code>이 양수이면 올바르게 생성된다. <code>minute</code>와 <code>hour</code>는 값이 정수여야 하지만, <code>second</code>은 소수도 가능하다.</p>
<p>이와 같은 요구사항들은 항상 참이여야 하기 때문에 고정 변수(invariants)라 불린다. 다른 방식으로 말하면, 만약 요구사항들이 참이 아니라면 무언가가 잘못되었다는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isvalidtime(time)</span><br><span class="line">    <span class="keyword">if</span> time.hour &lt; <span class="number">0</span> || time.minute &lt; <span class="number">0</span> || time.second &lt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> time.minute &gt;= <span class="number">60</span> || time.second &gt;= <span class="number">60</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>고정 변수를 확인하는 코드를 작성하면 오류를 감지하고 원인을 찾을 수 있다. 예를 들어 <code>isvalidtime()</code>가 <code>MyTime</code> 객체를 가져와서 고정 변수를 위반하면 <code>false</code>를 반환한다.</p>
<p>각 함수의 시작 부분에 <code>isvalidtime()</code>를 추가하여 인수가 유효한지 확인할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> addtime(t1, t2)</span><br><span class="line">    <span class="keyword">if</span> !isvalidtime(t1) || !isvalidtime(t2)</span><br><span class="line">        error(<span class="string">"invalid MyTime object in add_time"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    seconds = timetoint(t1) + timetoint(t2)</span><br><span class="line">    inttotime(seconds)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>또는 주어진 고정 변수를 확인하고 실패하면 예외를 제공하는 <code>@assert</code> 매크로를 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> addtime(t1, t2)</span><br><span class="line">    <span class="meta">@assert</span>(isvalidtime(t1) &amp;&amp; isvalidtime(t2), <span class="string">"invalid MyTime object in add_time"</span>)</span><br><span class="line">    seconds = timetoint(t1) + timetoint(t2)</span><br><span class="line">    inttotime(seconds)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>@assert</code> 매크로는 정상적인 조건을 처리하는 코드와 오류를 확인하는 코드를 구분하기 때문에 유용하다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>14. 구조체와 객체</title>
    <url>/2020/03/15/Think-Julia-Chapter-15/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap15" target="_blank" rel="noopener">Structs and Objects</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="구조체와-객체-Structs-and-Objects"><a href="#구조체와-객체-Structs-and-Objects" class="headerlink" title="구조체와 객체 (Structs and Objects)"></a>구조체와 객체 (Structs and Objects)</h2><p>지금까지 우리는 내장된 데이터 타입들과 함수를 어떻게 사용하는지 배웠다. 다음 단계는 고유한 데이터 타입을 생성하는 방법을 배우는 것이다. 이 주제는 양이 방대하기 때문에 여러 장에 걸쳐 공부할 것이다.</p>
<h3 id="복합-데이터-타입-Composite-Types"><a href="#복합-데이터-타입-Composite-Types" class="headerlink" title="복합 데이터 타입 (Composite Types)"></a>복합 데이터 타입 (Composite Types)</h3><p>우리는 그동안 줄리아에 내장된 데이터 타입을 많이 사용했다. 이제부터는 2차원 공간에서 점을 나타내는 새로운 데이터 타입인 <code>Point</code>를 정의할 것이다.</p>
<p>수학에서 점은 보통 좌표를 구분하는 쉼표와 함께 괄호 안에 표시된다. 예를 들어, (0,0)은 원점을 나타낸 것이고, (x,y)는 원점으로부터 x는 가로축, y는 세로축의 거리를 표시한 것이다.</p>
<ul>
<li>좌표를 x와 y라는 두 변수에 별도로 저장할 수 있다.</li>
<li>좌표를 배열이나 튜플의 요소로 저장할 수 있다.</li>
<li>점을 객체로 나타내는 새로운 데이터 타입을 만들 수 있다.</li>
</ul>
<p>새로운 타입을 만드는 것은 다른 방법에 비해서 더욱 복잡하지만, 확실한 장점이 있다. (장점은 나중에 볼 것이다)</p>
<p>복합 데이터 타입을 정의하는 것을 구조체(struct)라고 한다. 점의 <code>struct</code> 정의는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point</span><br><span class="line">    x</span><br><span class="line">    y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>헤더는 새로운 구조체를 부를 이름으로 <code>Point</code>라고 정의하며, 본문은 구조체의 속성(attributes) 또는 필드(fields)를 정의한다. <code>Point</code>구조체는 <code>x</code>와 <code>y</code>라는 두 개의 필드를 가진다.</p>
<p>구조체는 객체를 만드는 공장과 같다. 점을 만들기 위해서는 필드의 값을 인수로 갖는 <code>Point()</code>를 호출한다. <code>Point()</code>를 함수로 쓸 때, 이를 생성자(constructor)라고 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; p = Point(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">Point(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br></pre></td></tr></table></figure>
<p>반환 값은 <code>p</code>에 할당한 <code>Point</code>객체로 표시된다.</p>
<p>새 객체를 만드는 것을 인스턴스화(instantiation)라고 하며, 객체는 데이터 타입의 인스턴스이다.</p>
<p>만약 인스턴스를 출력한다면, 줄리아는 해당 인스턴스가 어떤 데이터 타입 및 속성을 가지고 있는지 일려준다.</p>
<p>모든 객체는 어떤 데이터 타입의 인스턴스이다. 그렇기 때문에 객체(object)와 인스턴스(instance)라는 단어는 바꿔서 사용할 수 있다. 하지만 이 장에서는 개발자가 정의한 고유 데이터 타입을 설명할 때만 인스턴스를 사용할 것이다.</p>
<p>객체와 그 필드를 보여주는 상태 다이아그램을 ‘객체 다이어그램(object diagram)’이라고 한다.</p>
<p><img src="/images/20.png" alt="object diagram"></p>
<h3 id="구조체는-불변이다-Structs-are-Immutable"><a href="#구조체는-불변이다-Structs-are-Immutable" class="headerlink" title="구조체는 불변이다 (Structs are Immutable)"></a>구조체는 불변이다 (Structs are Immutable)</h3><p><code>.</code>표기법을 사용하면 필드의 값을 가져올 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x = p.x</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line">julia&gt; p.y</span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure>
<p>표현식 <code>p.x</code>는 ‘객체 <code>p</code>를 참고(reference)하여 <code>x</code>의 값을 가져와라’라는 의미이다. 예를 들어, <code>x</code>라는 이름으로 변수에 값을 할당해보자. 그래도 변수<code>x</code>와 필드<code>x</code>는 충돌하지 않는다.</p>
<p>또한 어떤 표현식에서는 점 표기법을 사용할 수 있다. 예시는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; distance = sqrt(p.x^<span class="number">2</span> + p.y^<span class="number">2</span>)</span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure>
<p>그러나 구조체는 기본적으로 변경할 수 없으며, 생성(construction) 후에는 필드는 값이 변경될 수 없다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; p.y = <span class="number">1.0</span></span><br><span class="line">ERROR: setfield! <span class="keyword">immutable</span> <span class="keyword">struct</span> of <span class="keyword">type</span> Point cannot be changed</span><br></pre></td></tr></table></figure>
<p>이런 구조체의 불변성은 몇 가지의 장점을 가지고 있다.</p>
<ul>
<li>더 효율적일 수 있다.</li>
<li>데이터 타입 생성자가 제공하는 불변값을 위반하는 것은 불가능하다.</li>
<li>불변 객체를 사용하는 코드는 추론하기가 더 쉽다.</li>
</ul>
<h3 id="변경가능한-구조체-Mutable-Structs"><a href="#변경가능한-구조체-Mutable-Structs" class="headerlink" title="변경가능한 구조체 (Mutable Structs)"></a>변경가능한 구조체 (Mutable Structs)</h3><p>필요한 경우, ‘변경가능한 복합 데이터 타입(mutable composite types)’은 키워드 <code>mutable struct</code>로 정의할 수 있다. 변경가능한 점(point) 정의는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutable struct</span> MPoint</span><br><span class="line">    x</span><br><span class="line">    y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>또한 점 표기법을 사용하여 변경가능한 구조체의 인스턴스에 값을 할당할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; blank = MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">julia&gt; blank.x = <span class="number">3.0</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line">julia&gt; blank.y = <span class="number">4.0</span></span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure>
<h3 id="직사각형-Rectangles"><a href="#직사각형-Rectangles" class="headerlink" title="직사각형 (Rectangles)"></a>직사각형 (Rectangles)</h3><p>대부분은 객체의 필드를 어떻게 설정해야 할지 명확하지만, 어떤 경우에는 개발자가 결정을 내려야 한다. 예를 들어 직사각형을 나타내는 데이터 타입을 디자인한다고 가정해보자. 직사각형의 사이즈와 위치를 구체화하기 위해서 어떤 필드를 사용해야 하는가? 간단하게 생각하기 위해서 각도는 무시하고 수직이나 수평 단위로 생각하자.</p>
<p>그러면 적어도 두 가지의 가능성이 있다.</p>
<ul>
<li>직사각형의 한 모서리 또는 가운데 좌표, 너비와 높이를 지정할 수 있다.</li>
<li>두 개의 반대쪽 모서리 좌표를 지정할 수 있다.</li>
</ul>
<p>위 두 개의 방안 중에 무엇이 더 나은지 판단하기는 어렵기 때문에 첫 번째 방법을 예로 하여 설명할 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Represents a rectangle.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fields: width, height, corner.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">struct</span> Rectangle</span><br><span class="line">    width</span><br><span class="line">    height</span><br><span class="line">    corner</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>독스트링(docstring)은 필드 목록을 알려준다. 높이와 넓이는 숫자로 작성하고, 모서리의 경우는 왼쪽 아래 모서리를 지정하는 <code>Point</code>객체이다.</p>
<p>직사각형을 나타내기 위해서는 <code>Rectangle</code>객체를 인스턴스화해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; origin = MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">julia&gt; box = Rectangle(<span class="number">100.0</span>, <span class="number">200.0</span>, origin)</span><br><span class="line">Rectangle(<span class="number">100.0</span>, <span class="number">200.0</span>, MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>))</span><br></pre></td></tr></table></figure>
<p>객체 다이어그램은 이 객체의 상태를 그림으로 보여준다. 그림을 보면 다른 객체의 필드인 객체가 포함되었다. 그 이유는 <code>corner</code>의 속성이 변경가능한 객체라서 <code>Rectangle</code> 외부에서 작성할 수 있기 때문이다.</p>
<p><img src="/images/21.png" alt="object diagram"></p>
<h3 id="인수로서-인스턴스-Instances-as-Arguments"><a href="#인수로서-인스턴스-Instances-as-Arguments" class="headerlink" title="인수로서 인스턴스 (Instances as Arguments)"></a>인수로서 인스턴스 (Instances as Arguments)</h3><p>일반적인 방법으로 인스턴스를 인수로 전달할 수 있다. 예를 들면 아래의 코드와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printpoint(p)</span><br><span class="line">    println(<span class="string">"(<span class="subst">$(p.x)</span>, <span class="subst">$(p.y)</span>)"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>printpoint()</code>는 <code>Point</code>를 인수로 사용하여 수학 표기법으로 반환한다. 이를 호출하기 위해 <code>p</code>를 인수로 전달하였다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; printpoint(blank)</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br></pre></td></tr></table></figure>
<p>만약 변경가능한 구조체 객체가 함수에 인수로 전달되면, 함수는 객체의 필드를 수정할 수 있다. 예를 들어 <code>movepoint!()</code>는 변경가능한 <code>Point</code>와 두 개의 숫자인  <code>dx</code>, <code>dy</code>을 인수로 가져가서 <code>Point</code>의 <code>x</code>와 <code>y</code>의 속성에 각각 숫자를 추가한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> movepoint!(p, dx, dy)</span><br><span class="line">    p.x += dx</span><br><span class="line">    p.y += dy</span><br><span class="line">    <span class="literal">nothing</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>아래의 결과는 필드가 수정되는 것을 보여준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; origin = MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">julia&gt; movepoint!(origin, <span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; origin</span><br><span class="line">MPoint(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<p>함수 내부에서는 <code>p</code>가 <code>origin</code>의 에일리언스이므로, 함수가 <code>p</code>를 수정하면 <code>origin</code>이 변경된다.</p>
<p>만약 변경불가능한 <code>Point</code>객체를 <code>movepoint!()</code>에 입력하면 오류가 발생한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; movepoint!(p, <span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">ERROR: setfield! <span class="keyword">immutable</span> <span class="keyword">struct</span> of <span class="keyword">type</span> Point cannot be changed</span><br></pre></td></tr></table></figure>
<p>그러나 변경불가능한 객체의 변경가능한 속성 값은 수정할 수 있다. 예를 들어 <code>moverectangle!()</code>은 인수로 <code>Rectangle</code> 객체와 두 개의 숫자인 <code>dx</code>와 <code>dy</code>를 가져간 후 <code>movepoint!()</code>를 사용하여 직사각형의 모서리를 움직인다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> moverectangle!(rect, dx, dy)</span><br><span class="line">  movepoint!(rect.corner, dx, dy)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이제는 <code>movepoint!</code>안의 <code>p</code>가 <code>rect.corner</code>의 에일리언스이므로, <code>p</code>를 수정하면 <code>rect.corner</code>도 변경된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; box</span><br><span class="line">Rectangle(<span class="number">100.0</span>, <span class="number">200.0</span>, MPoint(<span class="number">0.0</span>, <span class="number">0.0</span>))</span><br><span class="line">julia&gt; moverectangle!(box, <span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; box</span><br><span class="line">Rectangle(<span class="number">100.0</span>, <span class="number">200.0</span>, MPoint(<span class="number">1.0</span>, <span class="number">2.0</span>))</span><br></pre></td></tr></table></figure>
<p><strong>WARNING</strong><br> 변경불가능한 객체의 변경가능한 속성도 재할당할 수는 없다.</p>
 <figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; box.corner = MPoint(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">ERROR: setfield! <span class="keyword">immutable</span> <span class="keyword">struct</span> of <span class="keyword">type</span> Rectangle cannot be changed</span><br></pre></td></tr></table></figure>
<h3 id="반환-값으로서-인스턴스-Instances-as-Return-Values"><a href="#반환-값으로서-인스턴스-Instances-as-Return-Values" class="headerlink" title="반환 값으로서 인스턴스 (Instances as Return Values)"></a>반환 값으로서 인스턴스 (Instances as Return Values)</h3><p>함수는 인스턴스를 반환할 수 있다. 예를 들어, <code>findcenter()</code>은 <code>Rectangle</code>을 인수로 받아서 직사각형 중심의 좌표를 포함하는 <code>Point</code>를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> findcenter(rect)</span><br><span class="line">    Point(rect.corner.x + rect.width / <span class="number">2</span>, rect.corner.y + rect.height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>표현식 <code>rect.corner.x</code>은 “객체 <code>rect</code>을 참고하여 필드 <code>corner</code>를 선택한 후, 해당 객체의 <code>x</code> 필드를 가져오라”는 의미이다.</p>
<p>다음은 <code>box</code>을 인수로 전달하고 <code>Point</code>를 <code>center</code>로 할당하는 예이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; center = findcenter(box)</span><br><span class="line">Point(<span class="number">51.0</span>, <span class="number">102.0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="복사-Copying"><a href="#복사-Copying" class="headerlink" title="복사 (Copying)"></a>복사 (Copying)</h3><p>에일리어싱은 한 곳에서 변경하면 다른 곳에 예기치 못한 영향을 주기 때문에 프로그램을 읽기 어렵게 만든다. 주어진 객체를 참조하는 모든 변수를 추적하기는 어렵다.</p>
<p>객체를 복사하는 것은 에일리어싱을 대신한다. 줄리아는 객체를 복제할 수 있는 <code>deepcopy()</code>를 제공한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; p1 = MPoint(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">MPoint(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">julia&gt; p2 = deepcopy(p1)</span><br><span class="line">MPoint(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">julia&gt; p1 ≡ p2</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">julia&gt; p1 == p2</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><code>≡</code> 연산자는 우리가 예상했던 대로 <code>p1</code>과 <code>p2</code>가 같은 객체가 아니라는 것을 보여준다. 하지만 왜 <code>==</code> 연산자는 두 객체가 같은 값임에도 불구하고 <code>false</code>를 반환하는가? 그 이유는 변경가능한 객체에서 <code>==</code>연산자는 <code>===</code>연산자와 동일하게 작동하기 때문이다. 즉, 객체의 동등성(equivalence)이 아닌 동일성(identity)을 비교한다. 이것은 줄리아가 변경가능한 복합 데이터 타입에서 무엇을 동등성으로 고려해야 하는지 모른다는 것을 의미한다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>객체 작업을 시작하면 몇 가지 새로운 예외가 발생할 수 있다. 존재하지 않는 필드에 접근하려고 하면 다음과 같은 결과를 얻는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; p = Point(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">Point(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">julia&gt; p.z = <span class="number">1.0</span></span><br><span class="line">ERROR: <span class="keyword">type</span> Point has no field z</span><br><span class="line">Stacktrace:</span><br><span class="line"> [<span class="number">1</span>] setproperty!(::Point, ::<span class="built_in">Symbol</span>, ::<span class="built_in">Float64</span>) at ./sysimg.jl:<span class="number">19</span></span><br><span class="line"> [<span class="number">2</span>] top-level scope at none:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>만약 객체의 데이터 타입이 무엇인지 확실하지 않다면, 물어볼 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; typeof(p)</span><br><span class="line">Point</span><br></pre></td></tr></table></figure>
<p>또한 <code>isa</code>를 사용하여 객체가 데이터 타입의 인스턴스인지 확인할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; p <span class="keyword">isa</span> Point</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>만약 객체가 특정 속성을 가지고 있는지 확신할 수 없다면, 내장 함수인 <code>fieldnames()</code>를 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fieldnames(Point)</span><br><span class="line">(:x, :y)</span><br></pre></td></tr></table></figure>
<p>또는 <code>isdefined()</code>도 사용가능하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; isdefined(p, :x)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">julia&gt; isdefined(p, :z)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>첫 번째 인수는 어떤 객체든 들어갈 수 있다. 두 번째 인수에는 <code>:</code>기호를 넣고 뒤에 필드의 이름을 작성하면 된다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>13. 파일</title>
    <url>/2020/03/13/Think-Julia-Chapter-14/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap14" target="_blank" rel="noopener">Files</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="파일-Files"><a href="#파일-Files" class="headerlink" title="파일 (Files)"></a>파일 (Files)</h2><p>이번 장에서는 데이터를 영구 저장소에 보관하는 ‘지속되는(persistent)’ 프로그램에 대해 소개하고, 파일 및 데이터베이스와 같은 다양한 종류의 영구 저장소를 사용하는 법을 알아볼 것이다.</p>
<h3 id="지속성-Persistence"><a href="#지속성-Persistence" class="headerlink" title="지속성 (Persistence)"></a>지속성 (Persistence)</h3><p>지금까지 본 대부분의 프로그램들은 일시적으로 실행되었다. 즉, 프로그램이 종료되는 순간 데이터는 사라지며 프로그램을 다시 실행하면 깨끗한 슬레이트에서 시작한다는 것을 의미한다.</p>
<p>하지만 영구적인 프로그램도 존재한다. 프로그램이 장시간 또는 항상 실행되며, 데이터의 일부를 하드 드라이브와 같은 영구 저장소에 보관하여 재부팅해도 프로그램이 멈춘 그 상태를 반환한다.</p>
<p>영구적인 프로그램의 예시로 운영체제(OS)와 웹서버를 볼 수 있다. 운영체제는 컴퓨터가 켜질 때마다 실행되며, 웹서버는 네트워크에서 들어오는 요청을 받기 위해 항상 켜져 있다.</p>
<p>프로그램이 데이터를 유지하는 가장 간단한 방법 중 하나는 텍스트 파일을 읽고 쓰는 것이다. 우리는 이미 앞에서 텍스트 파일을 읽는 프로그램을 보았다. 이 장에서는 텍스트 파일을 작성하는 프로그램을 보게 될 것이다.</p>
<p>다른 대안은 프로그램 상태를 데이터베이스에 저장하는 것이다. 이 장에서는 간단한 데이터베이스를 사용하는 방법도 살펴볼 것이다.</p>
<h3 id="읽고-쓰기-Reading-and-Writing"><a href="#읽고-쓰기-Reading-and-Writing" class="headerlink" title="읽고 쓰기 (Reading and Writing)"></a>읽고 쓰기 (Reading and Writing)</h3><p>텍스트 파일은 하드 드라이브나 플래시 메모리(flash memory)와 같은 영구 매체에 저장된 문자들의 시퀀스이다. 우리는 <a href="https://hyeonji-ryu.github.io/2020/03/06/chapter-9/">8. 워드 플레이</a>에서 파일을 열고 읽는 방법을 배웠다.</p>
<p>파일을 쓰기 위해서는, 두 번째 매개 변수에 “w”을 입력하여 ‘쓰기 모드’로 파일을 열어야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fout = open(<span class="string">"output.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"><span class="built_in">IOStream</span>(&lt;file output.txt&gt;)</span><br></pre></td></tr></table></figure>
<p><strong>파일이 이미 존재하는 경우 파일을 쓰기 모드로 열면 이전 데이터가 전부 지워지니 주의해야 한다.</strong> 파일이 없다면 새 파일이 만들어진다. <code>open()</code>은 파일 객체를 반환하고 <code>write()</code>는 데이터를 파일에 넣는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; line1 = <span class="string">"This here's the wattle,\n"</span>;</span><br><span class="line"></span><br><span class="line">julia&gt; write(fout, line1)</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>반환 값은 작성된 문자의 개수이다. 파일 객체는 현재 위치를 추적하므로 다시 <code>write()</code>를 호출하면 새 데이터가 파일 끝에 추가된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; line2 = <span class="string">"the emblem of our land.\n"</span>;</span><br><span class="line"></span><br><span class="line">julia&gt; write(fout, line2)</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>쓰기가 끝났다면, 파일을 닫아야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; close(fout)</span><br></pre></td></tr></table></figure>
<p>만약 파일을 닫지 않으면, 프로그램이 종료될 때 자동으로 닫힌다.</p>
<h3 id="서식-Formatting"><a href="#서식-Formatting" class="headerlink" title="서식 (Formatting)"></a>서식 (Formatting)</h3><p><code>write()</code>의 인수는 문자열이어야 하기 때문에 만약 파일에 값을 넣고 싶다면 문자열로 변환해야 한다. 가장 쉬운 방법은 <code>string()</code>이나 보간법을 사용하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fout = open(<span class="string">"output.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"><span class="built_in">IOStream</span>(&lt;file output.txt&gt;)</span><br><span class="line">julia&gt; write(fout, string(<span class="number">150</span>))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><code>write()</code> 대신에 <code>print(ln)</code>을 사용할수도 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; camels = <span class="number">42</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line">julia&gt; println(fout, <span class="string">"I have spotted <span class="variable">$camels</span> camels."</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Tip</strong><br>가장 강력한 방식은 <code>@printf</code>을 사용하는 것이다. 이에 대한 세부적인 사항은 <a href="https://docs.julialang.org/en/v1/stdlib/Printf/" target="_blank" rel="noopener">이 링크</a>에서 확인할 수 있다.</p>
<h3 id="파일이름과-경로"><a href="#파일이름과-경로" class="headerlink" title="파일이름과 경로"></a>파일이름과 경로</h3><p>파일은 폴더라고 불리는 디렉토리(directory)에 저장된다. 실행중인 모든 프로그램은 기본값으로 ‘현재 작동중인 디렉토리’을 가진다. 예를 들어, 만약 파일을 열어 읽어보고 싶다면, 줄리아는 현재 디렉토리에서 파일을 찾는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; cwd = pwd()</span><br><span class="line"><span class="string">"/home/ben"</span></span><br></pre></td></tr></table></figure>
<p><code>cwd</code>는 현재 작동중인 디렉토리를 보여준다. 위 예시는 결과로 사용자인 ben의 홈 디렉토리를 보여주었다.</p>
<p>파일이나 디렉토리를 식별하는 <code>&quot;/home/ben&quot;</code>와 같은 문자열을 경로(path)라고 한다.</p>
<p><code>memo.txt</code>와 같은 간단한 파일 이름도 경로가 될 수 있지만, 해당 파일은 현재 디렉토리에 저장되어 있기 때문에 파일 이름만 사용하는 것은 상대 경로이다. 현재 디렉토리가 <code>&quot;/home/ben&quot;</code>인 경우, 상대 경로인 <code>memo.txt</code>는 <code>&quot;/home/ben/memo.txt&quot;</code>를 참조한다.</p>
<p><code>/</code>로 시작하는 경로는 현재 디렉토리에 의존하지 않는다. 파일의 절대 경로를 찾고 싶다면 <code>abspath()</code>를 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; abspath(<span class="string">"memo.txt"</span>)</span><br><span class="line"><span class="string">"/home/ben/memo.txt"</span></span><br></pre></td></tr></table></figure>
<p>줄리아에서는 파일 이름과 경로와 관련된 여러 함수들을 제공한다. 예를 들어 <code>ispath()</code>는 파일이나 디렉토리가 존재하는지 확인한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; ispath(<span class="string">"memo.txt"</span>)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>만약 존재한다면, <code>isdir()</code>은 디렉토리인지를 확인한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; isdir(<span class="string">"memo.txt"</span>) <span class="comment"># 상대 경로 -&gt; 파일 이름일 뿐 디렉토리는 아니다.</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">julia&gt; isdir(<span class="string">"/home/ben"</span>) <span class="comment"># 절대 경로 -&gt; 디렉토리</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>비슷하게 <code>isfile()</code>은 파일인지를 확인한다.</p>
<p><code>readdir()</code>은 인수로 제공한 디렉토리에 들어있는 파일과 다른 디렉토리의 이름들을 베열로 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; readdir(cwd)</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">String</span>,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="string">"memo.txt"</span></span><br><span class="line"> <span class="string">"music"</span></span><br><span class="line"> <span class="string">"photos"</span></span><br></pre></td></tr></table></figure>
<p>이런 함수들을 설명하기 위해 다음 예시를 확인해보자. 아래의 함수는 디렉토리 경로를 받으면 그 안에 있는 파일들과 디렉토리의 이름을 반환한다. 재밌는 점은 디렉토리 내부에 있는 다른 디렉토리도 통과하여 그 안의 파일 이름을 전부 가져오는 재귀로 구성되있다는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> walk(dirname)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> readdir(dirname)</span><br><span class="line">        path = joinpath(dirname, name)</span><br><span class="line">        <span class="keyword">if</span> isfile(path)</span><br><span class="line">            println(path)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            walk(path)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>joinpath()</code>는 디렉토리와 파일 이름을 가져와 완전한 경로로 결합한다.</p>
<p><strong>Tip</strong><br>줄리아는 <a href="https://docs.julialang.org/en/v1/base/file/#Base.Filesystem.walkdir" target="_blank" rel="noopener"><code>walkdir()</code></a>이라는 함수를 제공한다. 이 함수는 우리가 작성한 함수와 비슷하지만 더 다양한 기능을 제공한다. 연습문제로 위 링크의 설명서를 읽고 함수를 사용하여 디렉토리 내부의 파일 이름을 출력해보라.</p>
<h3 id="예외-포착-Catching-Exceptions"><a href="#예외-포착-Catching-Exceptions" class="headerlink" title="예외 포착 (Catching Exceptions)"></a>예외 포착 (Catching Exceptions)</h3><p>파일을 읽고 쓸 때, 많은 오류들이 발생할 수 있다. 만약 존재하지 않는 파일을 열려고 한다면 <code>SystemError</code>가 일어난다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fin = open(<span class="string">"bad_file"</span>)</span><br><span class="line">ERROR: <span class="built_in">SystemError</span>: opening file <span class="string">"bad_file"</span>: No such file or directory</span><br></pre></td></tr></table></figure>
<p>또한 파일에 접근할 권한이 없는 경우에도 위와 같은 오류가 발생한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fout = open(<span class="string">"/etc/passwd"</span>, <span class="string">"w"</span>)</span><br><span class="line">ERROR: <span class="built_in">SystemError</span>: opening file <span class="string">"/etc/passwd"</span>: Permission denied</span><br></pre></td></tr></table></figure>
<p>이런 오류들을 피하기 위해서는 <code>ispath()</code>와 <code>isfile()</code>같은 함수를 이용해야 하지만, 모든 가능성을 확인하려면 많은 시간이 걸린다.</p>
<p><code>try</code>문을 사용하면 더 쉽게 문제를 해결할 수 있다. <code>try</code>문은 문법적으로 <code>if</code>문과 유사하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">    fin = open(<span class="string">"bad_file.txt"</span>)</span><br><span class="line"><span class="keyword">catch</span> exc</span><br><span class="line">    println(<span class="string">"Something went wrong: <span class="variable">$exc</span>"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>줄리아는 <code>try</code>절을 실행하며 시작한다. 모두 잘 진행되면 <code>catch</code>절을 건너 뛰고 진행하지만, 예외가 발생하면 <code>catch</code>절을 실행한다. <code>try</code>문으로 예외를 처리하는 것을 ‘예외 포착(Catching Exceptions)’이라고 한다. 이 예시에서 예외 절은 별로 도움이 되지 않는 오류 메시지를 출력한다. 일반적으로 예외를 발견하면 우리는 문제점을 수정하거나 다시 시도하거나 적어도 프로그램이 어떤 상황인지 알고 종료할 수 있는 기회를 얻는다.</p>
<p>일반적으로 상태 변경을 수행하거나 파일과 같은 리소스를 사용하는 코드에는 코드가 완료될 때 수행해야하는 정리 작업이 있다.(예시: 파일 닫기) 예외로 인해서 정상적인 종료에 도달하기도 전에 코드가 종료될 수 있기 때문에 작업이 복잡해진다. <code>finally</code> 키워드는 이전의 코드들이 종료되는 이유와 관계없이 특정 코드를 작동한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">"output.txt"</span>)</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    line = readline(f)</span><br><span class="line">    println(line)</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">    close(f)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위 예시에서 <code>close()</code>는 무조건 실행된다.</p>
<h3 id="데이터베이스-Databases"><a href="#데이터베이스-Databases" class="headerlink" title="데이터베이스 (Databases)"></a>데이터베이스 (Databases)</h3><p>데이터베이스(database)는 데이터를 저장하기 위해 조직된 파일이다. 많은 데이터베이스는 키에서 값으로 매핑된다는 점에서 딕셔너리처럼 구성되어 있다. 하지만 데이터베이스는 디스크와 같은 다른 영구저장소에 있으므로 프로그램이 종료된 후에도 유지된다는 점이 딕셔너리와는 다르다.</p>
<p><code>ThinkJulia</code>는 데이터베이스 작성 및 업데이트를 위해 <code>GDBM</code>(GNU dbm)에 대한 인터페이스를 제공한다. 예를 들어 이미지 파일의 설명(captions)이 포함된 데이터베이스를 만들 수 있다.</p>
<p>데이터베이스를 여는 것은 다른 파일을 여는 것과 비슷하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> ThinkJulia</span><br><span class="line"></span><br><span class="line">julia&gt; db = DBM(<span class="string">"captions"</span>, <span class="string">"c"</span>)</span><br><span class="line">DBM(&lt;captions&gt;)</span><br></pre></td></tr></table></figure>
<p>“c모드”는 데이터베이스가 존재하지 않는 경우 데이터베이스를 작성해야 함을 의미한다. 결과는 딕셔너리처럼 사용할 수 있는 데이터베이스 객체이다.</p>
<p>새 아이템을 만들 때는 <code>GDBM</code>이 데이터베이스 파일을 업데이트해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; db[<span class="string">"cleese.png"</span>] = <span class="string">"Photo of John Cleese."</span></span><br><span class="line"><span class="string">"Photo of John Cleese."</span></span><br></pre></td></tr></table></figure>
<p>만약 아이템 중 하나에 접근하고 싶다면, <code>GDBM</code>은 파일을 읽어온다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; db[<span class="string">"cleese.png"</span>]</span><br><span class="line"><span class="string">"Photo of John Cleese."</span></span><br></pre></td></tr></table></figure>
<p>원래 존재하던 키에 다른 값을 재할당한다면, <code>GDBM</code>은 새로운 값으로 변경한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; db[<span class="string">"cleese.png"</span>] = <span class="string">"Photo of John Cleese doing a silly walk."</span></span><br><span class="line"><span class="string">"Photo of John Cleese doing a silly walk."</span></span><br><span class="line">julia&gt; db[<span class="string">"cleese.png"</span>]</span><br><span class="line"><span class="string">"Photo of John Cleese doing a silly walk."</span></span><br></pre></td></tr></table></figure>
<p><code>keys()</code>와 <code>values()</code>와 같이 딕셔너리에 적용되는 몇몇의 함수는 데이터베이스에서 작동하지 않는다. 하지만 <code>for</code>루프와 같은 반복에서는 작동한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> db</span><br><span class="line">    println(key, <span class="string">": "</span>, value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>파일과 마찬가지로 데이터베이스도 작성이 끝나면 닫아야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; close(db)</span><br></pre></td></tr></table></figure>
<h3 id="직렬화-Serialization"><a href="#직렬화-Serialization" class="headerlink" title="직렬화 (Serialization)"></a>직렬화 (Serialization)</h3><p><code>GDBM</code>의 한계는 키와 값이 문자열 또는 바이트 배열이어야 한다는 것이다. 다른 유형을 사용하려고 하면 오류가 발생한다.</p>
<p>위의 상황에서는 직렬화해주는 <code>serialize()</code>와 역직렬화해주는 <code>deserialize()</code>가 도움이 될 수 있다. 이 함수들은 거의 모든 유형의 객체를 데이터베이스에 저장하기에 적합한 바이트 배열(an iobuffer)로 변환한 다음 바이트 배열을 다시 객체로 변환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> Serialization</span><br><span class="line"></span><br><span class="line">julia&gt; io = <span class="built_in">IOBuffer</span>();</span><br><span class="line"></span><br><span class="line">julia&gt; t = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; serialize(io, t)</span><br><span class="line"><span class="number">24</span></span><br><span class="line">julia&gt; print(take!(io))</span><br><span class="line"><span class="built_in">UInt8</span>[<span class="number">0x37</span>, <span class="number">0x4a</span>, <span class="number">0x4c</span>, <span class="number">0x07</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x15</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0xe2</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]</span><br></pre></td></tr></table></figure>
<p>위의 형식은 사람을 위한 것이 아닌 줄리아가 해석하기 쉽게 변환한 것이다. <code>deserialize()</code>는 객체를 재구성한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; io = <span class="built_in">IOBuffer</span>();</span><br><span class="line"></span><br><span class="line">julia&gt; t1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; serialize(io, t1)</span><br><span class="line"><span class="number">24</span></span><br><span class="line">julia&gt; s = take!(io);</span><br><span class="line"></span><br><span class="line">julia&gt; t2 = deserialize(<span class="built_in">IOBuffer</span>(s));</span><br><span class="line"></span><br><span class="line">julia&gt; print(t2)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p><code>serialize()</code>와 <code>deserialize()</code>는 메모리에 입출력하는 흐름을 나타하는  ‘iobuffer’ 객체로부터 쓰고 읽는다. <code>take!()</code>는 ‘iobuffer’의 내용을 바이트 배열로 가져오고 ‘iobuffer’을 초기상태로 재설정한다.</p>
<p>새 객체가 이전 객체와 동일한 값을 갖지만, 동일한 객체는 아니다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t1 == t2</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">julia&gt; t1 ≡ t2</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>즉, 직렬화와 역직렬화는 객체를 복사하는 것과 같다. 이 방식을 사용하여 문자열이 아닌 요소들도 데이터베이스에 저장할 수 있다.</p>
<p><strong>Tip</strong><br>실제로 문자열이 아닌 요소들이 저장된 데이터베이스는 <a href="https://github.com/JuliaIO/JLD2.jl" target="_blank" rel="noopener"><code>JLD2</code></a>라는 패키지에 캡슐화하여 사용하는게 일반적이다.</p>
<h3 id="명령-객체-Command-Objects"><a href="#명령-객체-Command-Objects" class="headerlink" title="명령 객체 (Command Objects)"></a>명령 객체 (Command Objects)</h3><p>대부분의 운영체제는 셀(shell)이라고 하는 명령 줄 인터페이스를 제공한다. 셀은 일반적으로 파일 시스템을 탐색하고 응용프로그램을 시작하는 명령을 제공한다. 예를 들어, Unix에서는 <code>cd</code>를 사용하여 디렉토리를 변경하고 <code>ls</code>를 사용하여 디렉토리의 내용을 표시하며 <code>firefox</code>를 입력하여 웹브라우저를 시작할 수 있다.</p>
<p>셀에서 실행할 수 있는 모든 프로그램은 명령 객체를 사용하여 줄리아에서도 시작할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; cmd = <span class="string">`echo hello`</span></span><br><span class="line"><span class="string">`echo hello`</span></span><br></pre></td></tr></table></figure>
<p>백틱(Backticks,`)은 명령을 구분하는데 사용된다.</p>
<p><code>run()</code>은 명령을 실행한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; run(cmd);</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p><code>hello</code>는 echo 명령문의 출력이며, <code>STDOUT</code>으로 전송된다. <code>run()</code>은 명령을 실행하며 문제가 생기면 <code>ErrorException</code>을 보여준다.</p>
<p>만약</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; a = read(cmd, <span class="built_in">String</span>)</span><br><span class="line"><span class="string">"hello\n"</span></span><br></pre></td></tr></table></figure>
<p>예를 들어, 대부분의 Unix시스템은 파일의 내용을 읽고 “체크썸(checksum)”계산하는 <code>md5sum</code> 또는 <code>md5</code>를 제공한다. <code>md5</code>에 대한 정보는 <a href="https://en.wikipedia.org/wiki/Md5" target="_blank" rel="noopener">해당 링크</a>에 있다. 이 명령은 두 파일의 내용이 같은지 여부를 확인하는 효율적인 방법을 제공한다. 서로 다른 내용이 동일한 체크썸을 생성할 확률은 매우 적다.</p>
<p>아래의 코드는 줄리아에서 <code>md5</code>를 실행하기 위한 명령을 사용하고, 결과를 얻는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; filename = <span class="string">"output.txt"</span></span><br><span class="line"><span class="string">"output.txt"</span></span><br><span class="line">julia&gt; cmd = <span class="string">`md5 <span class="variable">$filename</span>`</span></span><br><span class="line"><span class="string">`md5 output.txt`</span></span><br><span class="line">julia&gt; res = read(cmd, <span class="built_in">String</span>)</span><br><span class="line"><span class="string">"MD5 (output.txt) = d41d8cd98f00b204e9800998ecf8427e\n"</span></span><br></pre></td></tr></table></figure>
<h3 id="모듈-Modules"><a href="#모듈-Modules" class="headerlink" title="모듈 (Modules)"></a>모듈 (Modules)</h3><p>이름이 <code>&quot;wc.ji&quot;</code>인 파일이 있다고 가정하자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> linecount(filename)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> eachline(filename)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    count</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">print(linecount(<span class="string">"wc.jl"</span>))</span><br></pre></td></tr></table></figure>
<p>위의 프로그램을 실행한다면, 파일 자체를 읽고 파일의 라인 수를 출력한다. 출력을 실행해보면 <code>&quot;wc.ji&quot;</code>는 9개의 라인으로 이루어져 있다. 또한 아래와 같이 REPL에 포함시길 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; include(<span class="string">"wc.jl"</span>)</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>줄리아는 분리된 가변적인 작업공간을 생성하는 모듈을 소개한다. (마치 새로운 글로벌 설정 공간과도 같다)</p>
<p>모듈은 키워드 <code>module</code>로 시작해서 <code>end</code>로 끝난다. 모듈로 작성하면 도메인에 설정한 함수나 변수와 충돌하지 않는다. <code>import</code>는 다른 모듈을 가져와서 제어할 수 있도록 허락하며, <code>export</code>는 특정한 모듈 안에 있는 함수들을 공개한다. 즉, 모듈을 설정하지 않고도 외부에서 쓸 수 있는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LineCount</span><br><span class="line">    <span class="keyword">export</span> linecount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> linecount(filename)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> eachline(filename)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        count</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>LineCount</code> 모듈 객체은 <code>linecount</code>를 제공한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> LineCount</span><br><span class="line"></span><br><span class="line">julia&gt; linecount(<span class="string">"wc.jl"</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<p><strong>WARNING</strong><br>이미 가져온 모듈을 다시 <code>import</code>하는 경우 줄리아는 아무 작업을 수행하지 않는다. 파일이 변경된 후에도 파일을 다시 읽지 않는다.<br>모듈을 다시 로드하려면 REPL을 다시 시작해야 한다. 세션을 더 오래 유지할 수 있는 <a href="https://github.com/timholy/Revise.jl" target="_blank" rel="noopener"><code>Revise</code></a> 패키지가 있다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>파일을 읽고 쓸 때, 공백과 관련된 문제가 생길 수 있다. 공백, 탭, 줄바꿈과 같은 문제들은 일반적으로 코드에서 보이지 않기 때문에 디버깅하기 어렵다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; s = <span class="string">"1 2\t 3\n 4"</span>;</span><br><span class="line"></span><br><span class="line">julia&gt; println(s)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>내장 함수인 <code>repr()</code>와 <code>dump()</code>는 어떤 객체든지 인수로 받아서 객체의 값을 문자열로 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; repr(s)</span><br><span class="line"><span class="string">"\"1 2\\t 3\\n 4\""</span></span><br><span class="line">julia&gt; dump(s)</span><br><span class="line"><span class="built_in">String</span> <span class="string">"1 2\t 3\n 4"</span></span><br></pre></td></tr></table></figure>
<p>이런 함수들은 디버깅하기에 유용하다.</p>
<p>실행중에 발생할 수 있는 또 다른 문제는 시스템들이 라인의 끝을 구분하기 위해 각각의 다른 문자를 사용하는 것이다. 어떤 시스템은 줄바꿈을 <code>\n</code>으로 표시하며, 다른 시스템은 <code>\r</code>로 표시한다. 시스템들간에 파일을 이동하면 이런 불일치의 문제가 발생할 수 있다.</p>
<p>대부분의 시스템에는 한 형식에서 다른 형식으로 변환하는 응용 프로그램이 있다. 관련 정보는 <a href="https://en.wikipedia.org/wiki/Newline" target="_blank" rel="noopener">해당 링크</a>에서 확인할 수 있다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>12. 사례 연구 - 데이터 구조 선택</title>
    <url>/2020/03/12/Think-Julia-Chapter-13/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap13" target="_blank" rel="noopener">Case Study: Data Structure Selection</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="사례-연구-데이터-구조-선택"><a href="#사례-연구-데이터-구조-선택" class="headerlink" title="사례 연구: 데이터 구조 선택"></a>사례 연구: 데이터 구조 선택</h2><p>지금까지 줄리아의 핵심 데이터 구조에 대해서 배우고 이를 사용하는 일부 알고리즘 살펴보았다.<br>이번 장에서는 사례 연구를 통해서 데이터 구조를 선택하고 사용하는 방법을 연습할 것이다.</p>
<h3 id="단어-빈도-분석-Word-Frequency-Analysis"><a href="#단어-빈도-분석-Word-Frequency-Analysis" class="headerlink" title="단어 빈도 분석 (Word Frequency Analysis)"></a>단어 빈도 분석 (Word Frequency Analysis)</h3><p>가능하다면, 해결책을 살펴보기 전에 아래의 연습문제를 풀어보자.</p>
<p><strong>연습문제 1</strong><br> 파일을 읽고, 각 줄을 단어로 나누고, 단어에서 공백과 문장부호를 제거한 후 소문자로 변환하는 프로그램을 작성해라.</p>
<p> <strong>Tip</strong><br> <code>isletter()</code>은 문자를 알파벳인지 테스트한다.</p>
<p><strong>연습문제 2</strong><br> <a href="https://gutenberg.org" target="_blank" rel="noopener">Project Gutenberg</a>로 가서 저작권이 없는 책을 일반 텍스트 형식으로 다운로드해라.<br> 이전에 사용했던 프로그램을 수정하여 다운로드한 책을 읽어온 후, 파일 시작 부분의 헤더 정보를 건너 뛰고 위의 프로그램을 실행하라.<br> 그 다음 책의 총 단어 수와 각 단어가 사용된 횟수를 계산하도록 프로그램을 수정해라.</p>
<p><strong>연습문제 3</strong><br> 책에서 가장 자주 사용되는 20개의 단어를 인쇄하도록 이전 연습문제의 프로그램을 수정해라.</p>
<p><strong>연습문제 4</strong><br> 이전 프로그램을 수정하여 단어 목록을 읽은 후, 단어 목록에 없는 단어를 인쇄해라. 오타는 몇 개인가? 단어 목록에 있어야 하는 일반적인 단어는 몇 개이며, 실제로 모호한 단어는 몇 개인가?</p>
<h3 id="랜덤-숫자"><a href="#랜덤-숫자" class="headerlink" title="랜덤 숫자"></a>랜덤 숫자</h3><p> 대부분의 컴퓨터 프로그램은 같은 입력이 주어지면 똑같은 결과를 출력한다. 그래서 이런 실행 흐름을 결정론적이라고 말할 수 있다. 결정론은 동일한 계산이 동일한 결과를 산출한다고 가정하기 때문에 일반적으로 좋은 이론이다. 하지만 일부 응용 프로그램의 경우 컴퓨터가 예측할 수 없는 형태이기를 원한다. 게임은 확실한 예이며, 다른 예들도 있다.</p>
<p>프로그램을 비결정론적으로 만드는 것은 어렵지만, 적어도 비결정론적으로 보이게 하는 방법은 있다. 그 중 하나는 ‘의사 난수 (pseudorandom numbers)’ 생성하는 알고리즘을 사용하는 것이다. 의사 난수는 결정론적 계산에 의해 생성되기 때문에 실제로 완벽한 무작위는 아니지만, 마치 랜덤 숫자와 같은 결과를 제공한다.</p>
<p><code>rand()</code>는 <code>0.0</code>과 <code>1.0</code>사이의 랜덤 소수를 반환한다. (0.0은 포함하지만 1.0은 포함하지 않는다) <code>rand()</code>를 호출할 때마다, 긴 배열 중에 다음 소수가 반환된다. 아래의 코드를 통해 결과를 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    x = rand()</span><br><span class="line">    println(x)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>또한 <code>rand()</code>는 이터레이터나 배열을 인수로서 가져올 수 있으며 결과로 랜덤 요소를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    x = rand(<span class="number">1</span>:<span class="number">6</span>)</span><br><span class="line">    print(x, <span class="string">" "</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="단어-히스토그램"><a href="#단어-히스토그램" class="headerlink" title="단어 히스토그램"></a>단어 히스토그램</h3><p>이 장을 진행하기 전에 앞에서 제시했던 연습문제를 풀어봐야 한다. 그 다음 <a href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/data/emma.txt" target="_blank" rel="noopener">해당 링크</a>에 가서 텍스트를 다운로드해라.</p>
<p>아래의 코드는 파일을 읽고 파일에 있는 단어의 히스토그램을 작성하는 프로그램이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> processfile(filename)</span><br><span class="line">    hist = <span class="built_in">Dict</span>()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> eachline(filename)</span><br><span class="line">        processline(line, hist)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    hist</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> processline(line, hist)</span><br><span class="line">    line = replace(line, <span class="string">'-'</span> =&gt; <span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> split(line)</span><br><span class="line">        word = string(filter(isletter, [word...])...)</span><br><span class="line">        word = lowercase(word)</span><br><span class="line">        hist[word] = get!(hist, word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>위의 프로그램은 위의 링크에서 다운받은 ‘emma.txt’을 읽어온다.</p>
<p><code>processfile()</code>은 파일의 줄을 읽어오고 <code>processline()</code>으로 한 줄씩 보낸다. 히스토그램인 <code>hist</code>는 누적기(accumulator)로 사용된다.</p>
<p><code>processline()</code>은 줄을 단어로 분리하고 문자 배열로 변경하는 <code>split()</code>을 사용하기 전에 <code>-</code>을 공백으로 바꾸기 위해서 <code>replace()</code>를 사용한다. 그리고 단어 배열은 <code>filter()</code>와 <code>isletter</code>로 마침표와 기타 문장기호들을 제거하고 <code>lowercase()</code>로 소문자로 변경한다.(정확히 말하면, 문자열은 변경된 것이 아니라 소문자로 구성된 새 문자열을 반환한 것이다)</p>
<p>마지막으로, <code>processline()</code>은 새로운 항목을 만들거나 기존 항목을 증가시켜 히스토그램을 업데이트한다.</p>
<p>파일의 단어가 총 몇 개인지 세어보려면 히스토그램에서 빈도가 합쳐져야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> totalwords(hist)</span><br><span class="line">    sum(values(hist))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>다른 단어들의 수는 딕셔너리에서 아이템의 수이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> differentwords(hist)</span><br><span class="line">    length(hist)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>결과는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; println(<span class="string">"Total number of words: "</span>, totalwords(hist))</span><br><span class="line">Total number of words: <span class="number">162742</span></span><br><span class="line"></span><br><span class="line">julia&gt; println(<span class="string">"Number of different words: "</span>, differentwords(hist))</span><br><span class="line"><span class="built_in">Number</span> of different words: <span class="number">7380</span></span><br></pre></td></tr></table></figure>
<h3 id="가장-일반적인-단어"><a href="#가장-일반적인-단어" class="headerlink" title="가장 일반적인 단어"></a>가장 일반적인 단어</h3><p>가장 일반적인 단어들을 찾기 위해서는 각각의 튜플이 단어와 빈도를 포함한 튜플 배열을 만들고 그 배열을 정리하면 된다. 아래의 함수는 히스토스램을 가져와 단어-빈도 튜플 배열로 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> mostcommon(hist)</span><br><span class="line">    t = []</span><br><span class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> hist</span><br><span class="line">        push!(t, (value, key))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    reverse!(sort(t))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 튜플은 빈도가 첫 번째 값이기 때문에 정렬도 빈도를 기준으로 배치된다. 아래의 코드는 10개의 가장 일반적인 단어를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">t = mostcommon(hist)</span><br><span class="line">println(<span class="string">"The most common words are:"</span>)</span><br><span class="line"><span class="keyword">for</span> (freq, word) <span class="keyword">in</span> t[<span class="number">1</span>:<span class="number">10</span>]</span><br><span class="line">    println(word, <span class="string">"\t"</span>, freq)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드에서는 <code>\t</code>인 줄내림 분리기호를 사용하였다. 그 결과 단어들은 아래로 정렬된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">The most common words are:</span><br><span class="line">to  <span class="number">5295</span></span><br><span class="line">the <span class="number">5266</span></span><br><span class="line">and <span class="number">4931</span></span><br><span class="line">of  <span class="number">4339</span></span><br><span class="line">i   <span class="number">3191</span></span><br><span class="line">a   <span class="number">3155</span></span><br><span class="line">it  <span class="number">2546</span></span><br><span class="line">her <span class="number">2483</span></span><br><span class="line">was <span class="number">2400</span></span><br><span class="line">she <span class="number">2364</span></span><br></pre></td></tr></table></figure>
<p><strong>Tip</strong><br>위 코드는 <code>sort()</code>의 <code>rev</code> 키워드 인수를 사용하여 단순화할 수 있다. <code>rev</code>에 대해서는 <a href="https://docs.julialang.org/en/v1/base/sort/#Base.sort." target="_blank" rel="noopener">이 링크</a>에서 읽을 수 있다.</p>
<h3 id="선택적-매개-변수-Optional-Parameters"><a href="#선택적-매개-변수-Optional-Parameters" class="headerlink" title="선택적 매개 변수 (Optional Parameters)"></a>선택적 매개 변수 (Optional Parameters)</h3><p>지금까지는 선택적 인수를 가진 내장 함수들을 보았다. 물론 프로그래머가 직접 정의하는 함수 또한 선택적 인수를 사용하여 작성할 수 있다.<br>예를 들어 가장 일반적인 단어를 히스토그램으로 출력하는 함수는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printmostcommon(hist, num=<span class="number">10</span>)</span><br><span class="line">    t = mostcommon(hist)</span><br><span class="line">    println(<span class="string">"The most common words are: "</span>)</span><br><span class="line">    <span class="keyword">for</span> (freq, word) <span class="keyword">in</span> t[<span class="number">1</span>:num]</span><br><span class="line">        println(word, <span class="string">"\t"</span>, freq)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>첫 번째 매개 변수는 필수적으로 들어가야 하지만, 두 번째 매개 변수는 선택적이다. 위 코드에서 선택적 매개 변수의 기본값은 <code>num=10</code>이다.</p>
<p>만약 하나의 인수만 넣어 실행하면</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">printmostcommon(hist)</span><br></pre></td></tr></table></figure>
<p><code>num</code>은 자동으로 기본값이 입력된다. 만약 두 개의 인수를 모두 넣으면</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">printmostcommon(hist,<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p><code>num</code>은 기본값 대신 입력한 새로운 값을 사용한다.</p>
<p>만약 함수에 필수적(required) 매개 변수와 선택적(optional) 매개 변수를 모두 입력하고 싶다면, 필수적 변수는 첫 번째로 입력하고 선택적 변수는 그 뒤에 써야 한다.</p>
<h3 id="딕셔너리-뺄셈-Dictionary-Subtraction"><a href="#딕셔너리-뺄셈-Dictionary-Subtraction" class="headerlink" title="딕셔너리 뺄셈 (Dictionary Subtraction)"></a>딕셔너리 뺄셈 (Dictionary Subtraction)</h3><p>책에서 words.txt 단어 리스트에 없는 단어를 찾는 것은 두 딕셔너리를 빼는 것 처럼 인식된다. 즉, 책에는 있지만 단어 리스트에는 없는 단어를 찾으려는 것이다.</p>
<p><code>subtract()</code>은 딕셔너리 <code>d1</code>과 <code>d2</code>를 가져와서 <code>d1</code>는 있지만 <code>d2</code>에는 없는 키들을 포함한 새로운 딕셔너리를 반환한다. 값은 필요 없기 때문에 <code>nothing</code>으로 설정했다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> subtract(d1, d2)</span><br><span class="line">    res = <span class="built_in">Dict</span>()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys(d1)</span><br><span class="line">        <span class="keyword">if</span> key ∉ keys(d2)</span><br><span class="line">            res[key] = <span class="literal">nothing</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    res</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>책에는 있지만 단어 리스트에 없는 단어를 찾기 위해서는 words.txt 또한 <code>processfile()</code>를 사용해서 히스토그램으로 만들어야 한다. 그리고 <code>subtract()</code>를 사용하자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">words = processfile(<span class="string">"words.txt"</span>)</span><br><span class="line">diff = subtract(hist, words)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"Words in the book that aren't in the word list:"</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> keys(diff)</span><br><span class="line">    print(word, <span class="string">" "</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>그 결과는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Words <span class="keyword">in</span> the book that aren't <span class="keyword">in</span> the word list:</span><br><span class="line">outree quicksighted outwardly adelaide rencontre jeffereys unreserved dixons betweens ...</span><br></pre></td></tr></table></figure>
<p>위의 단어들 중에서 일부는 사람 이름과 소유물이다. 또한 “rencontre”와 같은 단어는 더이상 사용하지 않는 용어이다. 그러나 몇 개의 단어는 일반적인 단어로서 리스트에 있어야 한다.</p>
<h3 id="랜덤-단어-Random-Words"><a href="#랜덤-단어-Random-Words" class="headerlink" title="랜덤 단어 (Random Words)"></a>랜덤 단어 (Random Words)</h3><p>히스토그램으로부터 랜덤 단어를 선택하기 위해서 사용되는 가장 간편한 알고리즘은 각 단어의 복사본을 빈도만큼 만든 후 배열을 생성하여 선택하게 하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> randomword(h)</span><br><span class="line">    t = []</span><br><span class="line">    <span class="keyword">for</span> (word, freq) <span class="keyword">in</span> h</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:freq</span><br><span class="line">            push!(t, word)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    rand(t)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 알고리즘은 작동하지만, 효율적이지는 않다. 랜덤 단어를 선택할 때마다 책만큼 큰 크기의 배열을 다시 만든다. 효율을 향상시키기 위해서 배열을 한번만 만들고 여러 번 선택하는 방법도 좋지만, 배열의 크기는 여전히 크다.</p>
<p>대안으로는 다음과 같다.</p>
<ul>
<li>책에 있는 단어의 배열을 가져와라.</li>
<li>단어 빈도의 누적 합계를 요소로 하는 배열을 만들어라. 이 배열의 마지막 요소는 책의 총 단어 수가 되어야 한다.</li>
<li>1부터 n사이의 난수를 선택하라. 난수가 있는 위치를 찾기 위해 이분법 검색(bisection search)를 사용하여 해당 인덱스를 얻어라.</li>
<li>인덱스를 사용하여 연결되어 있는 단어를 찾아라.</li>
</ul>
<p><strong>대안 해결 코드</strong><br>아래의 코드는 제가 직접 작성한 코드입니다. 필요하신 분들만 참고해주세요 :)</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> cumulsum(t)</span><br><span class="line">    cumul=[]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">1</span>:length(t)</span><br><span class="line">        temp= sum(t[<span class="number">1</span>:n])</span><br><span class="line">        cumul=push!(cumul,temp)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> cumul</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> searching_word(t)</span><br><span class="line">    words=collect(keys(t))</span><br><span class="line">    addnum=cumulsum(collect(values(t)))</span><br><span class="line">    random=rand(<span class="number">1</span>:length(t))</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">1</span>:(length(addnum)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> addnum[n] &lt; random &lt; addnum[n+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> words[n]</span><br><span class="line">        <span class="keyword">elseif</span> n+<span class="number">1</span> == addnum[<span class="keyword">end</span>]</span><br><span class="line">            <span class="keyword">return</span> words[<span class="keyword">end</span>]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="마르코프-분석-Markov-Analysis"><a href="#마르코프-분석-Markov-Analysis" class="headerlink" title="마르코프 분석 (Markov Analysis)"></a>마르코프 분석 (Markov Analysis)</h3><p>책에서 무작위로 단어를 선택하면, 어휘는 알 수 있지만 문장은 얻지 못할 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">this the small regard harriet which knightley's it most things</span><br></pre></td></tr></table></figure>
<p>위의 문장처럼 무작위로 단어를 배열하면 문법적인 문제로 어떤 의미도 갖지 못하는 경우가 많다. 예를 들어, 의미를 가진 문장이라면 “the” 다음에 명사나 형용사가 올 것으로 예상할 수 있으며 동사나 부사는 사용할 수 없다.</p>
<p>이런 관계를 파악하는 한 가지 방법은 특정 단어 이후에 나올 단어의 확률을 분석하는 마르코프 분석을 사용하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Half a bee, philosophically,</span><br><span class="line">Must, ipso facto, half not be.</span><br><span class="line">But half the bee has got to be</span><br><span class="line">Vis a vis, its entity. D’you see?</span><br><span class="line"></span><br><span class="line">But can a bee be said to be</span><br><span class="line">Or not to be an entire bee</span><br><span class="line">When half the bee is not a bee</span><br><span class="line">Due to some ancient injury?</span><br></pre></td></tr></table></figure>
<p>위의 글에서 “half the”라는 구문 뒤에는 항상 “bee”이라는 단어가 쓰이며, “bee” 뒤에는 “has”나 “is”가 쓰이는 것을 알 수 있다.</p>
<p>마르코프 분석에서는 각 접두사(“half the”,”bee”)에서 가능한 모든 접미사(“has”,”is”)로 매핑한다.</p>
<p>이 맵이 있으면 랜덤 접두사로 시작한 후 가능한 접미사에서 임의로 선택하고 이를 반복하여 글을 생성할 수 있다.</p>
<p>예를 들어, 접두사 “half a”로 시작하는 경우 다음 단어는 “bee”이여야 한다. 왜냐하면 접두사 “half a”가 글에 딱 한번 나왔기 때문에 다른 확률이 없다. 다음 접두사는 “bee”이기 때문에 그 뒤에는 접미사  “philosophically”, “be” 또는 “due”가 올 수 있다.</p>
<p>위의 예시는 접두사 길이를 두 단어로 한정시켰다. 이처럼 마르코프 분석은 접두사 길이를 사용해서도 활용할 수 있다.</p>
<p><strong>마르코프 분석 연습문제</strong><br>다음 장으로 가기 전에 해당 연습문제를 꼭 시도해보기를 추천한다.</p>
<ul>
<li><p>파일에서 텍스트를 읽고 마르코프 분석을 수행하는 프로그램을 작성하라. 결과는 접두사에서 가능한 접미사 모음으로 매핑되는 딕셔너리어야 한다. 모음은 배열, 튜플 또는 딕셔너리 어떤 것을 사용해도 상관없다. 접두사 길이와 상관없이 사용할 수 있는 프로그램을 작성하라.</p>
</li>
<li><p>마르코프 분석을 기반으로 임의의 텍스트를 생성하려면 이전 프로그램에 함수를 추가하라. 다음은 접두사 길이가 2인 Emma의 예이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">“He was very clever, be it sweetness or be angry,</span><br><span class="line">ashamed or only amused, at such a stroke.</span><br><span class="line">She had never thought of Hannah till you were never meant <span class="keyword">for</span> me?<span class="string">"</span></span><br><span class="line"><span class="string"> "I</span> cannot make speeches, Emma:<span class="string">" he soon cut it all himself.”</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>이 예시에서는 마침표를 단어로 포함했다. 결과는 거의 문법적으로 정확하지만 완벽하지는 않으며, 의미도 어느정도 있는 것 같지만 완벽하게 이해되지는 않는다.<br>만약 접두사의 길이를 늘리면 어떤 결과가 나오는가? 문장이 더 의미있는가?</p>
<ul>
<li>프로그램이 작동한다면, ‘매쉬 업(mash-up)’을 시도할 수 있다. 두 권 이상의 책을 결합하여 생성한 랜덤 텍스트는 더 흥미로운 어휘와 문장을 보여줄 것이다.</li>
</ul>
<h3 id="데이터-구조-Data-Structures"><a href="#데이터-구조-Data-Structures" class="headerlink" title="데이터 구조 (Data Structures)"></a>데이터 구조 (Data Structures)</h3><p>마르코프 분석을 사용하여 랜덤 텍스트를 만드는 것은 재미있지만 사실 연습문제에는 ‘데이터 구조 선택(data structure selection)’이라는 중요한 핵심이 있다. 위의 연습문제를 풀기 위해서는 아래의 내용들을 결정해야 한다.</p>
<ul>
<li>접두사를 나타내는 방법</li>
<li>가능한 접미사 모음을 나타내는 방법</li>
<li>각 접두사에서 가능한 접미사 모음으로 매핑을 나타내는 방법</li>
</ul>
<p>마지막 문제를 해결하는 방법은 쉽다. 딕셔너리 키에서 해당 값으로 매핑해주면 끝이다.<br>접두사의 경우 가장 좋은 방법은 문자열, 문자열 배열, 또는 문자열 튜플이다.<br>접미사는 배열이나 히스토그램(딕셔너리)이 적절하다.</p>
<p>어떻게 선택해야 할까? 첫 번째 단계는 각 데이터 구조를 위해 구현해야 하는 작업에 대해 생각하는 것이다. 접두사의 경우 사용한 접두사를 제거하고 새로운 접두사를 추가할 수 있어야 한다. 예를 들어 현재 접두사가 “half a”이고 다음 단어가 “bee”인 경우 다음 접두사 “bee”를 생성할 수 있어야 한다.</p>
<p>배열은 요소를 쉽게 추가하고 제거할 수 있기 때문에 사용하기 적절하다.</p>
<p>접미사 모음의 경우, 새 접미사 추가 및 기존 접미사 빈도 증가, 랜덤 접미사 선택 등의 일들을 수행해야 한다.</p>
<p>새 접미사를 추가하는 것은 배열 구현이나 히스토그램 둘 다 쉽다. 하지만 랜덤 요소를 선택하는 것은 히스토그램보다 배열이 더 쉽다.</p>
<p>지금까지는 어떤 구조가 구현하기 편한지에 대해서 이야기했지만 사실 데이터 구조를 선택할 때 고려해야 할 다른 중요한 부분들이 있다. 첫 번째는 런타임이다. 각각의 데이터 구조마다 소요되는 시간은 이론적으로 차이가 있다. 예를 들어 <code>in</code> 연산자는 요소가 많을 때 배열보다 딕셔너리에서 더 빠르다.</p>
<p>그러나 어떤 구현이 더 빠른지 미리 알지 못하는 경우가 종종 있다. 이럴 경우 두 가지의 선택으로 나뉘는데, 그 중 하나는 모두 구현해본 다음에 어느 것이 더 나은지를 경험해보는 것이다. 이 접근법을 벤치마킹(benchmarking)이라고 한다. 또 다른 실용적인 대안은 구현하기 가장 쉬운 데이터 구조를 선택한 다음 프로그램에 적합한 속도인지를 확인하는 것이다. 만약 적합하다면, 굳이 다른 데이터 구조를 만들 필요가 없다. 적합하지 않다면, 시간이 가장 많이 걸리는 프로그램 위치를 알려주는 <code>Profile</code> 모듈과 같은 도구들을 사용하면 된다.</p>
<p>고려해야 할 두번째 요소는 저장 공간이다. 예를 들어, 접미사 모음에 히스토그램을 사용하면 텍스트에 여러 번 나타나는지에 관계없이 각 단어를 한 번만 저장하면 되므로 저장 공간을 덜 차지할 수 있다. 경우에 따라 저장 공간을 절약하면 프로그램 실행 속도가 빨라질 수 있으며, 메모리가 부족할 경우에는 프로그램이 실행되지 않을 수 있다. 하지만 많은 응용프로그램들에서는 런타임을 우선적으로 고려한다.</p>
<p>지금까지는 마르코프 분석과 텍스트 생성을 동시에 하는 데이터 구조를 생각했다. 하지만 분석과 텍스트 생성을 별도의 단계로 나눈 각각의 데이터 구조를 사용하는 것도 가능하다. 만약 통합된 데이터 구조보다 별도로 나눈 데이터 구조가 더 빠르다면 나누는 것이 바람직하다.</p>
<p><strong>Tip</strong><br>줄리아 패키지 <a href="https://github.com/JuliaCollections/DataStructures.jl" target="_blank" rel="noopener"><code>DataStructures</code></a>는 다양한 데이터 구조를 구현한다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>프로그램을 디버깅할 때, 특히 어려운 버그를 만났을 때 아래의 5가지를 시도해보라.</p>
<ul>
<li><p>읽기(Reading)<br>코드를 검사하고 스스로 다시 코드를 읽은 후 무엇을 원하는지 확인하라.</p>
</li>
<li><p>실행(Running)<br>변경한 다른 버전을 실행하면서 실험해보라. 코드를 올바른 위치에 잘 작성하면 문제가 명확하게 보이지만, 때로는 스캐폴딩을 만들어 문제를 확인해야 한다.</p>
</li>
<li><p>반추(Ruminating)<br>시간을 두고 생각해보라. 문법, 런타임, 의미 오류가 무엇인가? 오류 메시지 또는 프로그램 출력에서 무엇을 얻을 수 있나? 어떤 종류의 문제가 발생할 수 있는가? 문제가 나타나기 전에 변경한 사항은 무엇인가?</p>
</li>
<li><p>고무오리(Rubberducking)<br>다른 사람에게 문제를 설명하면, 말이 끝나기도 전에 답을 찾을 때가 있다. 만약 다른 사람이 없다면, 우리는 고무오리와도 대화할 수 있다. 이 전략을 고무오리 디버깅이라고 한다. 이 전략을 자세히 알고 싶다면 <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging" target="_blank" rel="noopener">이 링크</a>를 참고해라.</p>
</li>
<li><p>후진(Retreating)<br>어떨 때는 오류가 나기 전의 프로그램으로 돌아오는 것이 가장 좋은 방법이다. 즉, 변경사항들을 취소한 후 프로그램을 다시 구현하는 것이다.</p>
</li>
</ul>
<p>초보 프로그래머들은 위의 5가지 방법 중 하나에 갇혀서 다른 방법들을 잊어버리곤 한다. 상황에 따라 문제에 최적화된 방법은 다르다는 것을 기억하자.</p>
<p>예를 들어, 문제가 인쇄상의 오류인 경우에는 코드를 읽는 것이 도움이 될 수 있지만 개념 오해로 비롯된 문제라면 읽는 방법은 도움이 되지 않는다. 프로그램이 어떻게 작동하는지 이해하지 못하면, 100번을 읽어도 오류를 찾을 수 없다.</p>
<p>실험 방법은 작고 간단한 테스트일 때 도움이 된다. 하지만 코드를 생각하거나 읽지 않고 실험만 진행하면 아무거나 바꿔보는 랜덤 워크 프로그래밍(random walk programming)에 빠질 수 있다. 이것은 시간이 오래 걸린다.</p>
<p>생각하려면 시간이 소요된다. 디버깅은 실험과학과 같다. 문제가 무엇인지에 대한 가설이 하나 이상은 있어야 한다. 둘 이상의 가능성이 있다면, 그 중 하나를 제거할 수 있는 테스트를 생각해보라.</p>
<p>그러나 오류가 너무 많거나 수정하려는 코드가 너무 크고 복잡하면 최고의 디버깅 기술조차 실패한다. 때로는 후진하는 것이 최선의 방법이며, 프로그램이 이해되고 작동될 때까지 단순화해야 한다.</p>
<p>초보 프로그래머는 종종 코드 라인을 삭제하는 후퇴를 꺼려한다. 불안하다면 프로그램 코드를 복사해둔 후 하나씩 수정해보라.</p>
<p>어려운 버그를 찾으려면 읽고, 실행하고, 반추하고 때로는 후진해야 한다. 한 가지 방법에서 막힌다면 다양한 방법을 시도해보라.</p>
<p><strong>연습문제 코드</strong><br>아래의 코드는 제가 직접 작성한 코드입니다. 필요하신 분들만 참고해주세요 :)</p>
<ul>
<li>연습문제 1</li>
</ul>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> letterfilter(f)</span><br><span class="line">    words=[]</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> split(f)</span><br><span class="line">        word=lowercase(word)</span><br><span class="line">        word=string(filter(isletter, word))</span><br><span class="line">        push!(words,word)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> sentencetoword(t)</span><br><span class="line">    fin = open(t)</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> eachline(t)</span><br><span class="line">    f=readline(fin)</span><br><span class="line">    replace(f,<span class="string">"-"</span> =&gt; <span class="string">" "</span>)</span><br><span class="line">    replace(f,<span class="string">","</span> =&gt; <span class="string">" "</span>)</span><br><span class="line">    t=letterfilter(f)</span><br><span class="line">    temp=append!(temp,t)</span><br><span class="line">    temp[<span class="string">""</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>연습문제 2</li>
</ul>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> sentencetoword(t)</span><br><span class="line">    fin = open(t)</span><br><span class="line">    temp = <span class="built_in">Dict</span>()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> eachline(t)</span><br><span class="line">    f=readline(fin)</span><br><span class="line">    replace(f,<span class="string">"-"</span> =&gt; <span class="string">" "</span>)</span><br><span class="line">    replace(f,<span class="string">","</span> =&gt; <span class="string">" "</span>)</span><br><span class="line">    letterfilter(f,temp)</span><br><span class="line">    temp[<span class="string">""</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> letterfilter(f,temp)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> split(f)</span><br><span class="line">        word=lowercase(word)</span><br><span class="line">        word=string(filter(isletter, word))</span><br><span class="line">        temp[word]=get!(temp,word,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> numofword(t)</span><br><span class="line">    ml= sentencetoword(t)</span><br><span class="line">    wordnum=sum(values(ml))</span><br><span class="line">    print(wordnum)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>연습문제 3</li>
</ul>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> change(t)</span><br><span class="line">    m=[]</span><br><span class="line">    <span class="keyword">for</span> (key,value) <span class="keyword">in</span> t</span><br><span class="line">        push!(m,(value,key))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    reverse!(sort(m))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> topword(t, n)</span><br><span class="line">    words=change(t)</span><br><span class="line">    top=words[<span class="number">1</span>:n]</span><br><span class="line">    print(top)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>연습문제 4</li>
</ul>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">wordlist=sentencetoword(<span class="string">"words.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> findweird(t1,t2)</span><br><span class="line">    word1=keys(t1)</span><br><span class="line">    word2=keys(t2)</span><br><span class="line">    final=[]</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> word1</span><br><span class="line">        <span class="keyword">if</span> word ∉ word2</span><br><span class="line">        push!(final,word)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> final</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 튜플</title>
    <url>/2020/03/11/Think-Julia-Chapter-12/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap12" target="_blank" rel="noopener">Tuples</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="튜플-Tuples"><a href="#튜플-Tuples" class="headerlink" title="튜플 (Tuples)"></a>튜플 (Tuples)</h2><p>이번 장에서는 또다른 내장된 데이터 타입인 튜플(Tuples)에 대해서 알아보고 배열과 딕셔너리, 튜플이 어떻게 같이 작동하는지 공부할 것이다. 또한 유용한 기능인 ‘수집과 분산 연산자(gather and scatter operators.)’와 ‘가변 인수 배열(variable-length argument arrays)’ 등을 살펴볼 것이다.</p>
<h3 id="튜플은-불변이다"><a href="#튜플은-불변이다" class="headerlink" title="튜플은 불변이다"></a>튜플은 불변이다</h3><p>튜플은 일련의 값들이다. 값은 어떤 데이터 타입도 될 수 있으며, 또한 정수로 인덱싱되기 때문에 배열과 유사한 점이 많다. 중요한 차이점은 튜플은 요소를 변경할 수 없으며 각각의 요소들은 고유한 데이터 타입을 가진다.</p>
<p>문법적으로 튜플은 쉼표로 구분된 값 목록이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span></span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>)</span><br></pre></td></tr></table></figure>
<p>하지만 필요하진 않더라도 괄호를 사용해서 튜플을 작성하는 것이 일반적이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>)</span><br></pre></td></tr></table></figure>
<p>하나의 요소로 튜플을 만들기 위해서는 마지막에 쉼표를 넣어주어야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t1 = (<span class="string">'a'</span>,)</span><br><span class="line">(<span class="string">'a'</span>,)</span><br><span class="line">julia&gt; typeof(t1)</span><br><span class="line"><span class="built_in">Tuple</span>&#123;<span class="built_in">Char</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WARNING</strong><br> 쉼표 없는 괄호 안의 값은 튜플이 아니다.</p>
 <figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t2 = (<span class="string">'a'</span>)</span><br><span class="line"><span class="string">'a'</span>: ASCII/Unicode U+<span class="number">0061</span> (category Ll: Letter, lowercase)</span><br><span class="line">julia&gt; typeof(t2)</span><br><span class="line"><span class="built_in">Char</span></span><br></pre></td></tr></table></figure>
<p>튜플을 만드는 다른 방법은 내장 함수를 이용하는 것이다. 인수가 없는 상태인 <code>tuple()</code>을 입력하면 빈 튜플이 생성된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; tuple()</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<p>여러 개의 인수들을 입력한다면, 인수들이 값인 튜플을 생성한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t3 = tuple(<span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">pi</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">π</span> = <span class="number">3.1415926535897</span>...)</span><br></pre></td></tr></table></figure>
<p><code>tuple</code>은 내장 함수의 이름이기 때문에 변수의 이름으로는 사용하지 않는 것이 좋다.</p>
<p>대부분의 배열 연산자들은 튜플에서 작동한다. 대괄호 연산자는 해당 인덱스의 요소를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; t[<span class="number">1</span>]</span><br><span class="line"><span class="string">'a'</span>: ASCII/Unicode U+<span class="number">0061</span> (category Ll: Letter, lowercase)</span><br></pre></td></tr></table></figure>
<p>슬라이스 연산자 또한 요소들의 특정 범위를 선택한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)</span><br></pre></td></tr></table></figure>
<p>그러나 튜플의 한 요소를 수정하려고 시도하면, 아래의 오류 메시지가 나타난다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t[<span class="number">1</span>] = <span class="string">'A'</span></span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching setindex!(::<span class="built_in">NTuple</span>&#123;<span class="number">5</span>,<span class="built_in">Char</span>&#125;, ::<span class="built_in">Char</span>, ::<span class="built_in">Int64</span>)</span><br></pre></td></tr></table></figure>
<p>튜플은 변하지 않기 때문에 요소들을 수정할 수 없다.</p>
<p>관계 연산자들도 튜플이나 기타 시퀀스에서 작동한다. 줄리아는 각 시퀀스에서 첫 번째 요소를 비교하며 시작한다. 동일하면 다음 요소로 진행되며 다른 요소를 찾을 때까지 계속한다. 서브시퀀스는 고려되지 않는다. (실제로 큰 경우에도)</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>) &lt; (<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">julia&gt; (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2000000</span>) &lt; (<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>첫 번째 예시에서는 뒤의 튜플의 모든 요소가 앞의 튜플의 요소보다 모두 크기 떄문에 <code>true</code>를 반환했다. 두 번째 예시는 세 번째 요소가 뒤의 튜플보다 앞의 튜플이 더 크지만 앞의 두 개의 요소가 모두 뒤의 튜플이 더 크기 때문에  <code>true</code>를 반환했다. 즉, 하나라도 큰 요소가 있다면 <code>true</code>이고 아니라면 <code>false</code>를 반환한다.</p>
<h3 id="튜플-할당"><a href="#튜플-할당" class="headerlink" title="튜플 할당"></a>튜플 할당</h3><p>이것은 두 변수의 값을 바꿀 때 유용하다. 기존 할당에서는 임시 변수를 사용해야 한다. 예를 들어 <code>a</code>와 <code>b</code>를 바꾸려고 한다면, 아래와 같이 중간에 임시 변수가 필요하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br></pre></td></tr></table></figure>
<p>위의 방식은 번거롭다. 튜플은 훨씬 간단한 방법으로 변경한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>
<p>왼쪽은 튜플의 변수들이며, 오른쪽은 튜플의 표현식이다. 각 값들은 해당 변수에 할당되며, 오른쪽의 모든 표현식은 할당 전에 평가된다.</p>
<p>왼쪽에 있는 변수의 수는 오른쪽 값의 수보다 작으면 작동하지만, 초과된 값은 사라진다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; (a, b) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">julia&gt; a, b, c = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">ERROR: <span class="built_in">BoundsError</span>: attempt to access (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  at index [<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>일반적으로 오른쪽은 문자열, 배열, 튜플 등 어떤 종류의 시퀀스도 입력될 수 있다. 예를 들어 이메일 주소를 사용자 이름과 도메인으로 나누려면 다음과 같이 작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; addr = <span class="string">"julius.caesar@rome"</span></span><br><span class="line"><span class="string">"julius.caesar@rome"</span></span><br><span class="line">julia&gt; uname, domain = split(addr, <span class="string">'@'</span>);</span><br></pre></td></tr></table></figure>
<p><code>split()</code>으로부터 반환된 두 값은 배열의 두 요소가 된다. 첫 번째 요소는 <code>uname</code>에 할당되며, 두 번째는 <code>domain</code>에 할당된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; uname</span><br><span class="line"><span class="string">"julius.caesar"</span></span><br><span class="line">julia&gt; domain</span><br><span class="line"><span class="string">"rome"</span></span><br></pre></td></tr></table></figure>
<h3 id="반환-값으로서의-튜플"><a href="#반환-값으로서의-튜플" class="headerlink" title="반환 값으로서의 튜플"></a>반환 값으로서의 튜플</h3><p>엄격하게 말하자면, 함수는 오직 한 개의 값만 반환하지만 그러나 그 한 개의 값이 튜플이라면 여러 개의 값을 반환하는 것과 같은 효과를 가진다. 예를 들어 두 정수의 나눗셈에서 몫과 나머지를 구하려 할 때, <code>x ÷ y</code>을 계산한 후 <code>x % y</code>를 계산하는 것은 비효율적이다. 두 개의 수식을 한번에 계산하는 것이 더 낫다.</p>
<p>내장 함수인 <code>divrem()</code>은 두 인수를 가져가 몫과 나머지인 두 개의 값을 가진 튜플로 반환한다. 이후 결과를 튜플로 저장할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = divrem(<span class="number">7</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>또는 요소들을 각각 저장하기 위해서 튜플 할당을 이용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; q, r = divrem(<span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@show</span> q r;</span><br><span class="line">q = <span class="number">2</span></span><br><span class="line">r = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>아래의 함수는 튜플을 결과로 반환하는 예시이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> minmax(t)</span><br><span class="line">    minimum(t), maximum(t)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>minimum()</code>과 <code>maximum()</code>은 시퀀스에서 가장 작은 수와 큰 수를 찾아주는 내장된 함수이다. <code>minmax()</code>은 두 개의 값을 튜플로 반환한다. 같은 결과를 주는 내장 함수인 <code>extrema()</code>도 효과적이다.</p>
<h3 id="가변-인수-튜플-Variable-length-Argument-Tuples"><a href="#가변-인수-튜플-Variable-length-Argument-Tuples" class="headerlink" title="가변 인수 튜플 (Variable-length Argument Tuples)"></a>가변 인수 튜플 (Variable-length Argument Tuples)</h3><p>함수들은 가변적인 개수의 인수를 받아들일 수 있다. <code>...</code>로 끝나는 매개 변수 이름은 인수를 튜플로 <strong>수집(gather)</strong>한다. 예를 들어 <code>printall()</code>은 여러 인수들을 사용하여 출력한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printall(args...)</span><br><span class="line">    println(args)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>수집 매개 변수는 어떤 이름도 사용할 수 있지만 관례 상으로 <code>args</code>를 사용된다.<br>아래의 코드는 함수가 어떻게 작동하는지 보여준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; printall(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">'3'</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">'3'</span>)</span><br></pre></td></tr></table></figure>
<p>위에서 본 수집을 보완해주는 것이 <strong>분산(scatter)</strong>이다. 만약 값의 시퀀스가 있고 여러 인수로 함수에 값을 전달하려는 경우 <code>...</code> 연산자를 사용하면 된다. 예를 들어 <code>divrem()</code>은 정확히 2개의 인수를 받으며, 2개의 요소를 가진 튜플을 넣어도 작동하지 않는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = (<span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; divrem(t) <span class="comment"># 튜플의 값은 2개이지만 여기서 인수는 1개로 인식된다.</span></span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching divrem(::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int64</span>,<span class="built_in">Int64</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>그러나 튜플에 <code>...</code> 연산자를 사용하면 작동한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; divrem(t...) <span class="comment">#튜플의 값에 가변성을 부여하여 개수를 맞춰준다.</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>많은 내장 함수들이 가변 인수 튜플을 사용한다. 예를 들어, <code>min()</code>과 <code>max()</code>은 여러 인수들을 가져올 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>하지만 <code>sum()</code>은 작동하지 않는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching sum(::<span class="built_in">Int64</span>, ::<span class="built_in">Int64</span>, ::<span class="built_in">Int64</span>)</span><br></pre></td></tr></table></figure>
<h3 id="배열과-튜플"><a href="#배열과-튜플" class="headerlink" title="배열과 튜플"></a>배열과 튜플</h3><p><code>zip()</code>은 두 개 이상의 시퀀스들을 가져온 후 시퀀스들을 요소로 가진 튜플로 반환하는 내장 함수이다. 함수의 이름은 두 줄의 치아를 연결하고 끼워 넣는 지퍼에서 가져왔다.</p>
<p>아래의 예시는 문자열과 배열을 <code>zip()</code>의 인수로 입력한 결과이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; s = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">julia&gt; t = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; zip(s, t)</span><br><span class="line">Base.Iterators.Zip&#123;<span class="built_in">Tuple</span>&#123;<span class="built_in">String</span>,<span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;&#125;&#125;((<span class="string">"abc"</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure>
<p>위의 결과는 페어 단위로 정리할 수 있는 짚(zip) 객체이다. <code>zip()</code>은 일반적으로 <code>for</code> 루프에서 사용된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> pair <span class="keyword">in</span> zip(s, t)</span><br><span class="line">           println(pair)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">(<span class="string">'a'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>짚 객체는 일종의 이터레이터(iterator)이며 시퀀스를 반복하는 객체이다. 이터레이터는 몇 가지 측면에서 배열과 비슷하지만, 배열과 달리 인덱스를 사용하여 요소를 선택할 수 없다.</p>
<p>만약 배열 연산자나 함수를 사용하고 싶다면, 짚 객체를 이용하여 배열을 만들면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; collect(zip(s, t))</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Tuple</span>&#123;<span class="built_in">Char</span>,<span class="built_in">Int64</span>&#125;,<span class="number">1</span>&#125;:</span><br><span class="line"> (<span class="string">'a'</span>, <span class="number">1</span>)</span><br><span class="line"> (<span class="string">'b'</span>, <span class="number">2</span>)</span><br><span class="line"> (<span class="string">'c'</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>위의 결과는 튜플의 배열이다. 이 예시에서 각각의 튜플은 문자열에서 온 문자와 배열에서 온 요소들을 포함한다.</p>
<p>만약 시퀀스가 다른 길이라면, 더 짧은 시퀀스를 기준으로 결과가 출력된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; collect(zip(<span class="string">"Anne"</span>, <span class="string">"Elk"</span>))</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Tuple</span>&#123;<span class="built_in">Char</span>,<span class="built_in">Char</span>&#125;,<span class="number">1</span>&#125;:</span><br><span class="line"> (<span class="string">'A'</span>, <span class="string">'E'</span>)</span><br><span class="line"> (<span class="string">'n'</span>, <span class="string">'l'</span>)</span><br><span class="line"> (<span class="string">'n'</span>, <span class="string">'k'</span>)</span><br></pre></td></tr></table></figure>
<p>튜플의 배열을 순회하기 위해서는 <code>for</code> 루프에서 튜플 할당을 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> (letter, number) <span class="keyword">in</span> t</span><br><span class="line">           println(number, <span class="string">" "</span>, letter)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure>
<p>루프가 실행될 때마다 줄리아는 배열에서 다음 튜플을 선택하고 그 요소들을 letter와 number로 할당한다. <code>for</code> 루프에서 <code>(letter, number)</code>와 같이 괄호를 사용하는 것은 의무적이다.</p>
<p>만약 <code>zip()</code>, <code>for</code> 루프, 튜플 할당을 모두 결합하면, 동시에 두 개 이상의 시퀀스를 순회하는데 유용한 관용구를 얻는다. 예를 들어, <code>hasmatch()</code>는 <code>t1</code>과 <code>t2</code> 2개의 시퀀스를 가져가서 특정 인덱스 <code>i</code>가 <code>t1[i] == t2[i]</code>라면 <code>true</code>를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> hasmatch(t1, t2)</span><br><span class="line">    <span class="keyword">for</span> (x, y) <span class="keyword">in</span> zip(t1, t2)</span><br><span class="line">        <span class="keyword">if</span> x == y</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>시퀀스의 요소와 인덱스들을 순회해야 한다면, 내장 함수인 <code>enumerate()</code>를 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> (index, element) <span class="keyword">in</span> enumerate(<span class="string">"abc"</span>)</span><br><span class="line">           println(index, <span class="string">" "</span>, element)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure>
<p><code>enumerate()</code>의 결과는 enumerate 객체이며, 일련의 쌍을 반복한다. 각 쌍에는 인덱스와 시퀀스 요소가 포함되어 있다.</p>
<h3 id="딕셔너리와-튜플"><a href="#딕셔너리와-튜플" class="headerlink" title="딕셔너리와 튜플"></a>딕셔너리와 튜플</h3><p>딕셔너리는 키-값 페어를 반복하는 이터레이터(iterator)로 사용할 수 있다. <code>for</code> 루프에서 사용한다면 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; d = <span class="built_in">Dict</span>(<span class="string">'a'</span>=&gt;<span class="number">1</span>, <span class="string">'b'</span>=&gt;<span class="number">2</span>, <span class="string">'c'</span>=&gt;<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> (key, value) <span class="keyword">in</span> d</span><br><span class="line">           println(key, <span class="string">" "</span>, value)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">a <span class="number">1</span></span><br><span class="line">c <span class="number">3</span></span><br><span class="line">b <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>딕셔너리와 동일하게 아이템들은 특정한 순서가 없다.</p>
<p>또한 튜플 배열을 사용하여 새 딕셔너리로 초기화할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">3</span>), (<span class="string">'b'</span>, <span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line">julia&gt; d = <span class="built_in">Dict</span>(t)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Char</span>,<span class="built_in">Int64</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  <span class="string">'a'</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="string">'c'</span> =&gt; <span class="number">3</span></span><br><span class="line">  <span class="string">'b'</span> =&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><code>Dict()</code>과 <code>zip()</code>을 결합하면 딕셔너리를 만드는 간결한 방법이 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; d = <span class="built_in">Dict</span>(zip(<span class="string">"abc"</span>, <span class="number">1</span>:<span class="number">3</span>))</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Char</span>,<span class="built_in">Int64</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  <span class="string">'a'</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="string">'c'</span> =&gt; <span class="number">3</span></span><br><span class="line">  <span class="string">'b'</span> =&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>이것은 튜플을 딕셔너리의 키로 사용하는 일반적인 방법이다. 예를 들어 전화 번호부는 성과 이름 쌍에서 전화 번호로 매핑될 수 있다. 우리가 이름 쌍과 전화 번호를 알고 있다면 아래와 같이 작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">directory[last, first] = number</span><br></pre></td></tr></table></figure>
<p>위의 예시에서 대활호 안에 있는 표현식은 튜플이다. 즉, 이 딕셔너리를 순회하기 위해서는 튜플 할당을 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((last, first), number) <span class="keyword">in</span> directory</span><br><span class="line">    println(first, <span class="string">" "</span>, last, <span class="string">" "</span>, number)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이 루프는 <code>directory</code>에서 튜플인 키-값 페어를 순회한다. 각 튜플의 키 요소를 <code>last</code>와 <code>first</code>에, 값을 숫자에 할당한 다음 이름과 해당 전화번호를 출력한다.</p>
<h3 id="시퀀스의-시퀀스-Sequences-of-Sequences"><a href="#시퀀스의-시퀀스-Sequences-of-Sequences" class="headerlink" title="시퀀스의 시퀀스 (Sequences of Sequences)"></a>시퀀스의 시퀀스 (Sequences of Sequences)</h3><p>지금까지는 튜플 배열(arrays of tuples)에 중점을 두었지만, 이번 장의 모든 예제들은 배열의 배열(arrays of arrays), 튜플의 튜플(tuples of tuples), 배열 튜플(tuples of arrays)에서도 작동한다. 앞과 같이 가능한 조합을 열거하지 않기 위해서 시퀀스의 시퀀스로 이야기 하는 것이 훨씬 편하다.</p>
<p>많은 상황에서 문자열, 배열 및 튜플 등 서로 다른 종류의 시퀀스들을 바꿔서 사용할 수 있다. 만약 바꾼다면 어떤 것을 선택해야 할까?</p>
<p>확실한 것부터 시작하자면, 문자열은 요소들이 문자로 이루어져야 하기 때문에 다른 시퀀스보다 제한적이다. 또한 문자열은 불변이다. 만약 문자열에서 문자를 변경하는 함수가 필요한 경우, 새 문자열을 만드는 것 대신 문자 배열을 사용할 수 있다.</p>
<p>배열은 대부분 변경이 가능하기 때문에 튜플보다는 일반적으로 사용된다. 그러나 튜플이 더 적합한 몇 가지의 경우가 있다.</p>
<ul>
<li>반환 구문과 같은 일부 코드에서는 배열보다 튜플을 만드는 것이 문법 상 더 간단하다.</li>
<li>시퀀스를 함수에 인수로 전달하는 경우 튜플을 사용하면 에일리어싱으로 인한 오류의 가능성이 줄어든다.</li>
<li>성능상의 이유로 컴파일러가 튜플 타입을 전문화할 수 있다.</li>
</ul>
<p>튜플은 변경할 수 없으므로 배열을 수정하는 <code>sort!()</code>나 <code>reverse!()</code>와 같은 함수를 제공하지 않는다. 그러나 줄리아는 배열의 요소들을 가져와 정렬된 상태의 새로운 배열을 반환하는 내장 함수 <code>sort()</code>를 제공하며, 시퀀스를 가져와 역순으로 반환하는 <code>reverse()</code>도 제공한다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>배열, 딕셔너리 그리고 튜플은 데이터 구조의 예이다. 이 장에서는 튜플 배열 또는 튜플을 키로 가진 딕셔너리와 같은 복합 데이터 구조를 보기 시작하였다. 복합 데이터 구조는 유용하지만 형태 오류(shape errors)가 나기 쉽다. 즉, 데이터 구조가 잘못된 데이터 타입이나 크기 또는 구조를 가지는 것이다. 예를 들어 함수는 하나의 정수가 있는 배열을 기대하는데 개발자가 정수 하나만 입력한다면, 그 함수는 작동하지 않는다.</p>
<p>줄리아는 시퀀스의 요소에 데이터 타입을 첨부할 수 있다. 이 작업을 수행하는 방법은 다중 디스패치 파트에서 자세하게 설명할 것이다. 데이터 타입을 지정하면 많은 형태 오류가 제거된다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>10. 딕셔너리</title>
    <url>/2020/03/10/Think-Julia-Chapter-11/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap11" target="_blank" rel="noopener">Dictionaries</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="딕셔너리-Dictionaries"><a href="#딕셔너리-Dictionaries" class="headerlink" title="딕셔너리 (Dictionaries)"></a>딕셔너리 (Dictionaries)</h2><p>이번 장에서는 줄리아에 내장된 다른 데이터 타입인 딕셔너리에 대해서 알아볼 것이다.</p>
<h3 id="딕셔너리는-매핑-mapping-이다"><a href="#딕셔너리는-매핑-mapping-이다" class="headerlink" title="딕셔너리는 매핑(mapping)이다"></a>딕셔너리는 매핑(mapping)이다</h3><p>딕셔너리는 배열 같지만 좀 더 일반적이다. 배열에서는 인덱스가 무조건 정수여야 하지만, 딕셔너리에서는 어떤 타입도 인덱스로 사용될 수 있다.</p>
<p>딕셔너리는 키(key)라고 불리는 인덱스들의 모음과 값들의 모음을 포함한다. 각각의 키는 하나의 값과 연결되어 있다. 키와 값의 연결을 키-값 페어(key-value pair) 또는 아이템(items)이라고 부른다.</p>
<p>수학적 용어에서 딕셔너리는 키에서 값으로의 매핑을 나타내므로 각 키가 값에 매핑한다고 말할 수도 있다. (여기서 <strong>매핑</strong>이란 원하는 데이터를 찾아주는 과정을 말한다) 예를 들어 영어에서 스페인어로 번역해주는 맵인 딕셔너리를 만든다면, 키와 값은 모두 문자열이어야 한다.</p>
<p><code>Dict()</code>는 아이템 없이 빈 딕셔너리를 만든다. <code>Dict</code>는 내장 함수 이름이기 때문에, 변수를 만들 때는 이 이름을 사용하면 안된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; eng2sp = <span class="built_in">Dict</span>()</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Any</span>,<span class="built_in">Any</span>&#125; with <span class="number">0</span> entries</span><br></pre></td></tr></table></figure>
<p>딕셔너리의 종류는 중괄호로 묶어서 표현된다. 위의 예시에서는 키와 값의 데이터 타입이 모두 <code>Any</code>이다.</p>
<p>위의 딕셔너리는 비어있다. 딕셔너리에 아이템을 추가하기 위해서는 대괄호를 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; eng2sp[<span class="string">"one"</span>] = <span class="string">"uno"</span>;</span><br></pre></td></tr></table></figure>
<p>위 코드는 “one”이라는 키에 “uno”라는 값을 매핑하여 아이템을 생성한다. 이후 딕셔너리를 출력해보면 키-값 사이에 <code>=&gt;</code> 화살표가 나타남을 볼 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; eng2sp</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Any</span>,<span class="built_in">Any</span>&#125; with <span class="number">1</span> entry:</span><br><span class="line">  <span class="string">"one"</span> =&gt; <span class="string">"uno"</span></span><br></pre></td></tr></table></figure>
<p>위의 출력된 형태는 입력할 때도 사용할 수 있다. 예를 들어, 3개의 아이템을 딕셔너리에 추가해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; eng2sp = <span class="built_in">Dict</span>(<span class="string">"one"</span> =&gt; <span class="string">"uno"</span>, <span class="string">"two"</span> =&gt; <span class="string">"dos"</span>, <span class="string">"three"</span> =&gt; <span class="string">"tres"</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">String</span>,<span class="built_in">String</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  <span class="string">"two"</span>   =&gt; <span class="string">"dos"</span></span><br><span class="line">  <span class="string">"one"</span>   =&gt; <span class="string">"uno"</span></span><br><span class="line">  <span class="string">"three"</span> =&gt; <span class="string">"tres"</span></span><br></pre></td></tr></table></figure>
<p>모든 키와 값은 문자열이다. 따라서 <code>Dict{String,String}</code>으로 생성된다.</p>
<p><strong>WARNING</strong><br>키-값 페어의 순서가 같지 않을 수 있다. 즉, 컴퓨터에 위의 동일한 예제를 입력해도 순서는 다르게 나타날 수 있다.</p>
<p>하지만 딕셔너리의 요소들은 정수 인덱스로 저장되지 않기 때문에 순서는 문제가 되지 않는다. 대신에 키를 통해서 값을 찾을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; eng2sp[<span class="string">"two"</span>]</span><br><span class="line"><span class="string">"dos"</span></span><br></pre></td></tr></table></figure>
<p>키 “two”는 “dos”와 매핑되어 있기 때문에 항상 같은 값을 제공한다.</p>
<p>만약 입력한 키가 딕셔너리에 없다면, 아래와 같은 오류를 만날 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; eng2sp[<span class="string">"four"</span>]</span><br><span class="line">ERROR: <span class="built_in">KeyError</span>: key <span class="string">"four"</span> not found</span><br></pre></td></tr></table></figure>
<p><code>lenth()</code>는 딕셔너리에서도 작동한다. 이 함수는 키-값 페어의 개수를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; length(eng2sp)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><code>keys()</code>는 딕셔너리의 키들(keys)만 보여준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; ks = keys(eng2sp);</span><br><span class="line"></span><br><span class="line">julia&gt; print(ks)</span><br><span class="line">[<span class="string">"two"</span>, <span class="string">"one"</span>, <span class="string">"three"</span>]</span><br></pre></td></tr></table></figure>
<p>키들의 모음을 변수로 만들었으니, 이제는 <code>∈</code> 연산자를 사용하여 해당 키가 존재하는지 여부를 살펴볼 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="string">"one"</span> ∈ ks</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">julia&gt; <span class="string">"uno"</span> ∈ ks</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>딕셔너리에 있는 값만을 보기 위해서는 값들의 모음을 반환하는 <code>values()</code>를 사용하면 된다. 그리고 <code>∈</code> 연산자를 사용하여 해당 값이 존재하는지 확인할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; vs = values(eng2sp);</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="string">"uno"</span> ∈ vs</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><code>∈</code> 연산자는 배열과 딕셔너리에서 다른 알고리즘을 사용한다. 배열에서는 <a href="https://hyeonji-ryu.github.io/2020/03/06/chapter-9/">검색</a>에서와 같이 배열의 요소들을 순서대로 검색한다. 따라서 배열이 길수록, 검색시간은 더 길어질 수밖에 없다.</p>
<p>하지만 딕셔너리에서는 줄리아가 <a href="https://ko.wikipedia.org/wiki/해시_테이블" target="_blank" rel="noopener">해시테이블(hash table)</a>이라는 알고리즘을 사용한다. 따라서 딕셔너리에서 <code>∈</code> 연산자는 어떤 아이템을 요구하던 호출하는 시간이 동일하다.</p>
<h3 id="딕셔너리로-카운팅하기"><a href="#딕셔너리로-카운팅하기" class="headerlink" title="딕셔너리로 카운팅하기"></a>딕셔너리로 카운팅하기</h3><p>만약 문자가 주어지고 각 문자가 몇 번 나타내는지를 세고 싶다고 가정해보자. 그렇다면 해결할 수 있는 방법으로는 몇 가지가 있다.</p>
<ul>
<li>알파벳마다 하나씩 26개의 변수를 만들고, 각 문자에 대해 조건문을 사용하고 문자열을 순회하여 카운터를 증가하기</li>
<li>26개의 요소로 배열을 만든 다음 내장 함수 <code>Int()</code>를 사용하여 각 문자열을 숫자로 변환한 후, 인덱스로 사용하여 카운터를 증가하기</li>
<li>문자를 키로, 카운터를 해당 값으로 사용하여 딕셔너리를 만들고 문자가 나올 때마다 값을 증가하기. 딕셔너리에 없는 문자가 나오면 키로 저장하게 설정하면 좋다.</li>
</ul>
<p>위의 세 가지의 방법들은 똑같은 결과를 보여주지만, 구현하는 방법은 모두 다르다.</p>
<p>구현(implementation)은 계산을 수행하는 방법이다. 몇몇의 구현은 다른 것들보다 더 나은 경우도 있다. 예를 들어 딕셔너리 구현의 장점은 문자열에 어떤 문자가 나타나는지 미리 알 필요가 없으며, 나타나는 문자를 위한 공간만 만들면 된다는 점이다.</p>
<p>아래의 코드가 그렇다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> histogram(s)</span><br><span class="line">    d = <span class="built_in">Dict</span>()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s</span><br><span class="line">        <span class="keyword">if</span> c ∉ keys(d)</span><br><span class="line">            d[c] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            d[c] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    d</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>함수 이름은 <code>histogram()</code>으로, 빈도 모음에 대한 통계 용어이다.<br>함수의 첫 번째 줄은 빈 딕셔너리를 만든다. <code>for</code>루프는 문자열을 통과하며, 루프는 문자 <code>c</code>가 딕셔너리에 없다면 키 <code>c</code>와 초기 값 <code>1</code>을 새 항목으로 만든다. 만약 <code>c</code>가 이미 딕셔너리에 있다면 <code>d[c]</code>를 증가시킨다.</p>
<p>위 함수를 실행한 결과는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; h = histogram(<span class="string">"brontosaurus"</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Any</span>,<span class="built_in">Any</span>&#125; with <span class="number">8</span> entries:</span><br><span class="line">  <span class="string">'n'</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="string">'s'</span> =&gt; <span class="number">2</span></span><br><span class="line">  <span class="string">'a'</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="string">'r'</span> =&gt; <span class="number">2</span></span><br><span class="line">  <span class="string">'t'</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="string">'o'</span> =&gt; <span class="number">2</span></span><br><span class="line">  <span class="string">'u'</span> =&gt; <span class="number">2</span></span><br><span class="line">  <span class="string">'b'</span> =&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>히스토그램은 위와 같이 문자가 사용된 개수를 정확하게 측정하였다.</p>
<p>딕셔너리는 키와 기본값을 사용하는 <code>get()</code>가 있다. 키가 딕셔너리에 나타나면 <code>get()</code>은 연결된 값을 보여주며, 만약 연결된 값이 없다면 기본값을 보여준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; h = histogram(<span class="string">"a"</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Any</span>,<span class="built_in">Any</span>&#125; with <span class="number">1</span> entry:</span><br><span class="line">  <span class="string">'a'</span> =&gt; <span class="number">1</span></span><br><span class="line">julia&gt; get(h, <span class="string">'a'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">julia&gt; get(h, <span class="string">'b'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="루핑과-딕셔너리"><a href="#루핑과-딕셔너리" class="headerlink" title="루핑과 딕셔너리"></a>루핑과 딕셔너리</h3><p><code>for</code>문 안에서 딕셔너리 키들을 순회할 수 있다. 예를 들어서 <code>printhist()</code>는 각 키에 연결된 값들을 출력한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printhist(h)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> keys(h)</span><br><span class="line">        println(c, <span class="string">" "</span>, h[c])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>출력 결과는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; h = histogram(<span class="string">"parrot"</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; printhist(h)</span><br><span class="line">a <span class="number">1</span></span><br><span class="line">r <span class="number">2</span></span><br><span class="line">p <span class="number">1</span></span><br><span class="line">o <span class="number">1</span></span><br><span class="line">t <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>다시 말하지만 키는 특정한 순서를 가지고 있지 않다. 키를 순서대로 순회하기 위해서는 <code>sort()</code>와 <code>collect()</code>를 결합해야 한다. <code>collect()</code>는 키들을 문자로 변경하고, <code>sort()</code>는 문자들을 순서대로 정렬한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> c <span class="keyword">in</span> sort(collect(keys(h)))</span><br><span class="line">           println(c, <span class="string">" "</span>, h[c])</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">a <span class="number">1</span></span><br><span class="line">o <span class="number">1</span></span><br><span class="line">p <span class="number">1</span></span><br><span class="line">r <span class="number">2</span></span><br><span class="line">t <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="역방향-조회"><a href="#역방향-조회" class="headerlink" title="역방향 조회"></a>역방향 조회</h3><p><code>d</code>라는 딕셔너리와 <code>k</code>라는 키가 주어졌일 때, 해당된 값을 찾는 방법은 <code>v=d[k]</code>이다. 이런 작업을 조회(lookup)라고 부른다.</p>
<p>하지만 값을 가진 상태에서 키를 찾고 싶다면 어떻게 해야할까? 이 상황에서는 두 가지의 문제가 있다.<br> 첫 번째 문제는 동일한 값을 매핑한 키가 두 개 이상일 수도 있다는 점이다. 프로그램에 따라 하나를 선택하거나 해당되는 모든 키가 포함된 배열을 만들어야 할 수도 있다.<br> 두 번째는 역방향 조회를 수행하는 간단한 문법은 없다는 점이다. 따라서 우리가 직접 검색해야 한다.</p>
<p>아래의 함수는 값을 받아서 키를 돌려준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> reverselookup(d, v)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> keys(d)</span><br><span class="line">        <span class="keyword">if</span> d[k] == v</span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    error(<span class="string">"LookupError"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위 함수는 검색 패턴의 또 다른 예이지만 이전에는 볼 수 없었던 <code>error()</code>를 보여준다. <code>error()</code>는 정상적인 제어의 흐름을 방해하는 <code>ErrorException</code>을 생성하는데 사용된다. 이번 예시에서는 키가 존재하지 않음을 나타내는 <code>&quot;LookupError&quot;</code> 메시지가 표시된다.</p>
<p>루프의 마지막까지 작동된다면 값 <code>v</code>는 딕셔너리 안에 없는 것이기 때문에 오류 메시지를 전송하는 것이다.</p>
<p>역방향 조회를 성공한 예시는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; h = histogram(<span class="string">"parrot"</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; key = reverselookup(h, <span class="number">2</span>)</span><br><span class="line"><span class="string">'r'</span>: ASCII/Unicode U+<span class="number">0072</span> (category Ll: Letter, lowercase)</span><br></pre></td></tr></table></figure>
<p>실패한 예시도 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; key = reverselookup(h, <span class="number">3</span>)</span><br><span class="line">ERROR: LookupError</span><br></pre></td></tr></table></figure>
<p>예외를 알려주는 형태는 줄리아가 예외를 알려주는 방식과 동일하다. 즉, 스택트레이스와 오류 메시지를 인쇄하는 것이다.</p>
<p>줄리아는 역방향 조회를 수행하는 최적화된 방법인 <code>findall(isequal(3), h)</code>을 제공한다.</p>
<p><strong>WARNING</strong><br>역방향 조회는 순방향 조회보다 훨씬 느리다. 만약 이 방법을 자주 실행하거나 딕셔너리가 크다면, 프로그램이 성능이 저하된다.</p>
<h3 id="딕셔너리와-배열"><a href="#딕셔너리와-배열" class="headerlink" title="딕셔너리와 배열"></a>딕셔너리와 배열</h3><p>배열은 딕셔너리에서 값들로 나타낼 수 있다. 예를 들어, 알파벳(키)이 몇 번 쓰였는지 나타낸 빈도(값)로 매핑되는 딕셔너리가 제공된 경우 이를 반대로도 매핑할 수 있다. 즉, 빈도에서 문자를 매핑한 딕셔너리를 만드는 것이다. 사용 빈도가 동일한 알파벳이 여러 개 있을 수 있으므로 반전된 딕셔너리의 각 값은 문자 배열이어야 한다.</p>
<p>아래의 함수는 딕셔너리를 뒤집어준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> invertdict(d)</span><br><span class="line">    inverse = <span class="built_in">Dict</span>()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys(d)</span><br><span class="line">        val = d[key]</span><br><span class="line">        <span class="keyword">if</span> val ∉ keys(inverse)</span><br><span class="line">            inverse[val] = [key]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            push!(inverse[val], key)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    inverse</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>루프가 실행될 때마다 <code>keys</code>는 <code>d</code>에서 <code>key</code>를 얻고, <code>val</code>은 그 <code>key</code>와 매핑된 값을 얻는다. 만약에 <code>val</code>이 <code>inverse</code>에 없다면 아직 <code>val</code>과 겹치는 키가 없다는 의미이기 때문에 새 항목을 만들고 초기화한다. 그렇지 않다면 이미 동일한 키가 있는 것이기에 해당 키를 배열에 추가해준다.</p>
<p>예시는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; hist = histogram(<span class="string">"parrot"</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; inverse = invertdict(hist)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Any</span>,<span class="built_in">Any</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  <span class="number">2</span> =&gt; [<span class="string">'r'</span>]</span><br><span class="line">  <span class="number">1</span> =&gt; [<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'o'</span>, <span class="string">'t'</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/images/16.png" alt="state diagrams"></p>
<p>위의 상태 다이어그램은 <code>hist</code>와 <code>inverse</code>를 보여준다. 딕셔너리는 키-값 페어가 한 박스 안에서 보여진다. 따라서 만약 값이 정수이거나 소수, 문자열이라면 박스 안쪽에 그려야 한다. 하지만 배열의 경우에는 모두 분리된 박스로 그려야 한다. 위의 그림에서도 딕셔너리와 배열을 구분할 수 있다.</p>
<p><strong>Note</strong><br>앞서 해시테이블을 사용하여 딕셔너리를 구현했으며, 키를 해시할 수 있어야 함을 언급했다. 해시는 값을 취하고 정수를 반환하는 함수이다. 딕셔너리는 이런 해시 함수의 원리를 사용하여 키-값 쌍을 저장하고 조회한다.</p>
<h3 id="메모"><a href="#메모" class="headerlink" title="메모"></a>메모</h3><p>우리는 <a href="https://hyeonji-ryu.github.io/2020/03/03/chapter-6/">5장 연습해보기</a>에서 피보나치 함수에 대해 살펴보았다. 위의 피보나치 함수는 인수가 클수록 함수를 실행하는 데 시간이 오래 걸린다는 걸 알 수 있다. 더욱이 런타임도 빠르게 증가한다.</p>
<p>왜 그런지 이해하기 위해 피보나치의 n값이 4일 때의 콜 그래프(Call graph)를 확인해보자.</p>
<p><img src="/images/17.png" alt="call graph"></p>
<p>콜 그래프는 함수가 호출하는 흐름을 화살표로 보여준다. 그래프 맨 위에서 <code>n = 4</code>인 피보나치가 <code>n = 3</code>, <code>n = 2</code>인 피보나치를 호출한다. 그 후 <code>n = 3</code>인 피보나치가 <code>n = 2</code>와 <code>n = 1</code>인 피보나치를 호출한다. 이런 흐름이 계속된다.</p>
<p>결국 <code>fibonacci(0)</code>과 <code>fibonacci(1)</code>가 몇 번 호출되는지 계산한다. 이것은 문제에 대한 비효율적인 해결방법이며, 인수인 <code>n</code>이 커질수록 상황은 더욱 악화된다.</p>
<p>한 가지 해결책은 딕셔너리에 저장하여 이미 계산된 값을 추적하는 것이다. 나중에 사용하기 위해 이전에 계산된 값을 메모라고 한다. 피보나치의 메모가 추가된 버전은 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">known = <span class="built_in">Dict</span>(<span class="number">0</span>=&gt;<span class="number">0</span>, <span class="number">1</span>=&gt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fibonacci(n)</span><br><span class="line">    <span class="keyword">if</span> n ∈ keys(known)</span><br><span class="line">        <span class="keyword">return</span> known[n]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    res = fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>)</span><br><span class="line">    known[n] = res</span><br><span class="line">    res</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>known</code>은 이미 사용된 피보나치 숫자들을 저장하는 딕셔너리이다. 두 개의 항목으로 시작하며, <code>0</code>은 <code>0</code>에 매핑되고 <code>1</code>은 <code>1</code>에 매핑된다.</p>
<p><code>fibonacci()</code>를 호출할 때마다 <code>known</code>을 확인한다. 만약 해당 결과가 이미 <code>known</code>에 있다면 즉시 결과를 출력한다. 결과가 없다면 새로운 값을 계산하여 딕셔너리에 추가한 후 결과를 출력한다.</p>
<p>메모가 추가된 <code>fibonacci()</code>와 원래 <code>fibonacci()</code>를 비교해보면, 무엇이 더 빠른지 확인할 수 있다.</p>
<h3 id="글로벌-변수들"><a href="#글로벌-변수들" class="headerlink" title="글로벌 변수들"></a>글로벌 변수들</h3><p>이전의 예시에서 <code>known</code>은 함수 밖에서 만들어졌기 때문에 <code>Main</code>이라는 특별한 프레임에 속한다. <code>Main</code>의 변수는 가끔 글로벌(global)이라고 불리는데, 그 이유는 그들이 어떤 함수에서 엑세스 할 수 있기 때문이다. 함수 작동이 멈추면 사라지는 로컬(local) 변수들과 달리, 글로벌 변수는 계속 유지된다.</p>
<p>플래그(flags)에 글로벌 변수를 사용하는 것은 일반적이다. 즉, 조건이 참인지 여부를 나타내는 불 변수이다. 예를 들어, 몇몇의 프로그램은 출력 세부 사항의 수준을 제어하기 위해서 <code>verbose</code>라는 플래그를 사용한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">verbose = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example1()</span><br><span class="line">    <span class="keyword">if</span> verbose</span><br><span class="line">        println(<span class="string">"Running example1"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>글로벌 변수를 재할당하려 하면 놀랄 수 있다. 다음 예제를 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">been_called = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example2()</span><br><span class="line">    been_called = <span class="literal">true</span>         <span class="comment"># WRONG</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 함수를 작동해도 <code>been_called</code>의 값은 변하지 않는다. 그 이유는 <code>example2()</code>가 <code>been_called</code>라는 새로운 로컬 변수를 작성하기 때문이다. 함수가 끝나면 로컬 변수는 사라지고 글로벌 변수에는 영향을 미치지 않는다.</p>
<p>글로벌 변수를 함수 안에서 재할당하려면 먼저 변수 앞에 <code>global</code>을 써서 선언해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">been_called = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example2()</span><br><span class="line">    <span class="keyword">global</span> been_called</span><br><span class="line">    been_called = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>글로벌 명령문은 인터프리터에게 이렇게 말하는 것과 같다. “이 함수에서 사용되는 <code>been_called</code>는 글로벌 변수를 말하는 것이다. 그러니 로컬 변수를 만들지 말아라”</p>
<p>여기 글로벌 변수를 업데이트하려고 시도하는 예시가 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example3()</span><br><span class="line">    count = count + <span class="number">1</span>          <span class="comment"># WRONG</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 예시를 실행하면 아래와 같은 오류 메시지가 출력된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; example3()</span><br><span class="line">ERROR: <span class="built_in">UndefVarError</span>: count not defined</span><br></pre></td></tr></table></figure>
<p>줄리아는 <code>count</code>를 로컬 변수로 가정했기 때문에 문제가 발생한 것이다. 따라서 해결책은 <code>count</code>를 글로벌 변수로 선언하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example3()</span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>만약 글로벌 함수가 변경 가능한 값으로 제공되면, <code>global</code> 선언 없이 수정할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">known = <span class="built_in">Dict</span>(<span class="number">0</span>=&gt;<span class="number">0</span>, <span class="number">1</span>=&gt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example4()</span><br><span class="line">    known[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>글로벌 배열이나 딕셔너리의 요소들도 추가하거나 삭제, 대체 등을 할 수 있지만, 변수를 재할당하는 것은 <code>global</code>을 선언해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">known = <span class="built_in">Dict</span>(<span class="number">0</span>=&gt;<span class="number">0</span>, <span class="number">1</span>=&gt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example5()</span><br><span class="line">    <span class="keyword">global</span> known</span><br><span class="line">    known = <span class="built_in">Dict</span>()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>성능상의 이유로 글로벌 변수는 <code>const</code>를 선언해야 한다. 더이상 변수를 재할당 할 수는 없지만 변경 가능한 값들 한해서는 값을 수정할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> known = <span class="built_in">Dict</span>(<span class="number">0</span>=&gt;<span class="number">0</span>, <span class="number">1</span>=&gt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> example4()</span><br><span class="line">    known[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>WARNING</strong><br>글로벌 변수는 유용하지만, 글로벌 변수가 너무 많고 자주 수정하면 프로그램을 디버그하는데 힘들고 성능도 저하될 수 있다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>큰 데이터셋으로 작업할 때, 직접 다 출력하여 확인하는 방식으로는 디버그하기 어려울 수 있다. 다음은 큰 데이터셋을 디버그하기 위한 몇 가지의 제안이다.</p>
<ul>
<li><p>입력을 축소해라<br>가능하다면, 데이터셋의 크기를 줄여라. 예를 들어 프로그램이 텍스트 파일을 읽은 경우 처음 10행으로 시작하는 등의 가장 작은 예를 사용하여 오류를 찾을 수 있다. 파일 자체를 편집하는 것보다 프로그램을 수정하여 첫 번째 ‘n’라인만 읽을 수 있도록 수정하는 것이 낫다.</p>
</li>
<li><p>요약 및 데이터 타입을 확인하라<br>전체 테이터셋을 인쇄하고 확인하는 대신 데이터의 요약을 인쇄해라. (예로 딕셔너리에 있는 아이템 수나 배열의 숫자 등)<br>런타임 오류의 일반적인 원인은 올바르지 못한 데이터 타입의 값 때문이다. 이런 종류의 오류를 디버깅하기 위해선 값 데이터 타입을 출력해보는 것만으로도 충분하다.</p>
</li>
<li><p>자가 점검을 작성하라<br>때로는 오류를 자동으로 확인하는 코드를 작성할 수 있다. 예를 들어 숫자 배열의 평균을 계산하는 경우 결과가 배열에서 가장 큰 요소보다 크지 않거나 가장 작은 요소보다 작지 않은지 확인할 수 있다. 이것을 분별 검사(sanity check)라고 한다.<br>다른 종류의 검사는 서로 다은 두 가지 계산 결과를 비교하여 일치하는지 확인한다. 이것을 일관성 검사(consistency check)라고 한다.</p>
</li>
<li><p>출력을 형식화해라<br>디버깅 출력 형식을 지정하면 오류를 더 쉽게 발견할 수 있다. 출력 형식을 지정하는 것을 스캐폴딩이라고 하며, 이에 대한 자세한 설명은 <a href="https://hyeonji-ryu.github.io/2020/03/03/chapter-6/">해당 페이지</a> 디버깅 파트에 있다.<br>다시 말하지만 스캐폴딩을 구축하는 데 소요되는 시간은 디버깅에 낭비되는 시간을 줄일 수 있다.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>9. 배열</title>
    <url>/2020/03/08/Think-Julia-Chapter-10/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap10" target="_blank" rel="noopener">Arrays</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="배열-Arrays"><a href="#배열-Arrays" class="headerlink" title="배열 (Arrays)"></a>배열 (Arrays)</h2><p>이번 장에서는 줄리아에서 가장 유용한 데이터 타입인 배열(Arrays)을 살펴볼 것이다. 또한 한 객체에 둘 이상의 이름이 있을 때 발생할 수 있는 작업에 대해서도 알아볼 것이다.</p>
<h3 id="배열은-시퀀스이다"><a href="#배열은-시퀀스이다" class="headerlink" title="배열은 시퀀스이다"></a>배열은 시퀀스이다</h3><p>문자열처럼 배열은 일련의 값들이다. 문자열에서는 값들이 모두 문자이지만, 배열에서는 어떤 데이터 타입이든 값이 될 수 있다. 배열에서 값은 요소(element or item)라고 한다.</p>
<p>배열을 만드는 몇 가지의 방법이 있다. 가장 간단한 방법은 대괄호<code>[]</code>로 요소들을 묶는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">[<span class="string">"crunchy frog"</span>, <span class="string">"ram bladder"</span>, <span class="string">"lark vomit"</span>]</span><br></pre></td></tr></table></figure>
<p>위의 첫 번째 예시는 4개의 정수들을 요소로 한 배열이며, 두 번째는 3개의 문자열들을 요소로 한 배열이이다. 배열의 요소들이 모두 동일한 타입일 필요는 없다. 아래의 배열은 문자열과 소수, 정수, 그리고 또 다른 배열이 요소로 구성되어 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">[<span class="string">"spam"</span>, <span class="number">2.0</span>, <span class="number">5</span>, [<span class="number">10</span>, <span class="number">20</span>]]</span><br></pre></td></tr></table></figure>
<p>위의 예시처럼 배열은 다른 배열을 <strong>중첩</strong>하여 포함할 수 있다.</p>
<p>요소들을 포함하지 않은 배열은 빈 배열(empty array)이라고 부른다. 빈 배열은 대괄호<code>[]</code>만 입력해서 만들 수 있다.</p>
<p>예상했겠지만, 배열들은 변수의 값으로 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; cheeses = [<span class="string">"Cheddar"</span>, <span class="string">"Edam"</span>, <span class="string">"Gouda"</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; numbers = [<span class="number">42</span>, <span class="number">123</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; empty = [];</span><br><span class="line"></span><br><span class="line">julia&gt; print(cheeses, <span class="string">" "</span>, numbers, <span class="string">" "</span>, empty)</span><br><span class="line">[<span class="string">"Cheddar"</span>, <span class="string">"Edam"</span>, <span class="string">"Gouda"</span>] [<span class="number">42</span>, <span class="number">123</span>] <span class="built_in">Any</span>[]</span><br></pre></td></tr></table></figure>
<p><code>typeof()</code>는 배열의 종류를 찾는 데 사용된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; typeof(cheeses)</span><br><span class="line"><span class="built_in">Array</span>&#123;<span class="built_in">String</span>,<span class="number">1</span>&#125;</span><br><span class="line">julia&gt; typeof(numbers)</span><br><span class="line"><span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;</span><br><span class="line">julia&gt; typeof(empty)</span><br><span class="line"><span class="built_in">Array</span>&#123;<span class="built_in">Any</span>,<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>배열의 종류는 중괄호로 표시되어 출력되며, 앞에는 요소들의 데이터 타입을 보여준다. 뒤에 나오는 숫자의 의미는 배열의 차원이다. 또한 빈 배열은 <code>Any</code>라는 데이터 타입을 가지고 있다. 즉, 모든 값들은 데이터 타입을 가질 수 있는 것이다.</p>
<h3 id="배열은-변할-수-있다"><a href="#배열은-변할-수-있다" class="headerlink" title="배열은 변할 수 있다"></a>배열은 변할 수 있다</h3><p>배열의 요소에 접근하는 문법은 문자열에서 문자에 접근하는 문법과 동일하게 <code>[]</code>를 사용한다. 표현식은 <code>[]</code>에 특정 인덱스를 넣어서 호출한다. 인덱스는 1부터 시작한다는 것을 기억해라</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; cheeses[<span class="number">1</span>]</span><br><span class="line"><span class="string">"Cheddar"</span></span><br></pre></td></tr></table></figure>
<p>문자열과 같이 배열들 또한 변할 수 있다. 대괄호 연산자가 할당문 왼쪽에 쓰인다면, 대괄호가 지정한 인덱스에 해당하는 배열 요소의 값이 할당된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; print(numbers)</span><br><span class="line">[<span class="number">42</span>,<span class="number">123</span>]</span><br><span class="line">julia&gt; numbers[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">julia&gt; print(numbers)</span><br><span class="line">[<span class="number">42</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>위의 코드에서는 배열의 두 번째 값이 5로 재할당되었다.</p>
<p>배열 인덱스들은 문자열 인덱스들과 같은 방식으로 작동한다.</p>
<ul>
<li>어떤 정수 표현식이나 인덱스로 사용할 수 있다.</li>
<li>만약 존재하지 않는 요소를 읽거나 사용하려고 한다면, <code>BoundsError</code>가 발생한다.</li>
<li>키워드 <code>end</code>는 배열의 마지막 인덱스를 가져온다.</li>
</ul>
<p><code>∈</code> 연산자 또한 배열에서 작동한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="string">"Edam"</span> ∈ cheeses</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">julia&gt; <span class="string">"Brie"</span> <span class="keyword">in</span> cheeses</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="배열-순회-Traversing-an-Array"><a href="#배열-순회-Traversing-an-Array" class="headerlink" title="배열 순회 (Traversing an Array)"></a>배열 순회 (Traversing an Array)</h3><p>배열 요소들을 순회하는 가장 보편적인 방법은 <code>for</code>루프를 사용하는 것이다. 문법은 문자열과 동일하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cheese <span class="keyword">in</span> cheeses</span><br><span class="line">    println(cheese)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>오로지 배열 요소들을 읽기만 하는 것은 위의 코드로 충분하다. 그러나 만약 요소를 다시 쓰거나 업데이트하기를 원한다면, 인덱스가 필요하다. 이를 해결하는 가장 일반적인 방법은 내장 함수인 <code>eachindex()</code>를 사용하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eachindex(numbers)</span><br><span class="line">    numbers[i] = numbers[i] * <span class="number">2</span> <span class="comment"># 기존 요소들에 2를 곱해주는 표현식</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 루프는 배열을 순회하여 요소들을 업데이트한다. <code>length()</code>는 배열에서 요소들의 길이를 반환한다. 루프가 한 번씩 작동할 때마다 <code>i</code>는 다음 요소의 인덱스로 갱신된다. 본문에서의 할당문은 <code>i</code>를 사용하여 요소의 이전 값을 가져온 후 새로운 값으로 재할당한다.</p>
<p>아래의 <code>for</code>루프는 절대 본문이 실행되지 않는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> []</span><br><span class="line">    println(<span class="string">"This can never happens."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>한 배열이 다른 배열을 포함하고 있을 때, 내부의 중첩 배열은 하나의 요소로 인식된다. 따라서 아래의 배열은 길이가 4이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">[<span class="string">"spam"</span>, <span class="number">1</span>, [<span class="string">"Brie"</span>, <span class="string">"Roquefort"</span>, <span class="string">"Camembert"</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="배열-슬라이스-Array-Slices"><a href="#배열-슬라이스-Array-Slices" class="headerlink" title="배열 슬라이스 (Array Slices)"></a>배열 슬라이스 (Array Slices)</h3><p>슬라이스 연산자 또한 배열에서 작동한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>];</span><br><span class="line">julia&gt; print(t[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">julia&gt; print(t[<span class="number">3</span>:<span class="keyword">end</span>])</span><br><span class="line">[<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</span><br></pre></td></tr></table></figure>
<p>슬라이스 연산자인 <code>[:]</code>는 전체 배열의 복사본을 가져온다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; print(t[:])</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</span><br></pre></td></tr></table></figure>
<p>배열은 가변적이기 때문에, 배열을 변경하기 전에 복사본을 만드는 방법은 종종 유용하게 사용된다.</p>
<p>변수 왼쪽에 사용된 슬라이스 연산자는 여러 개의 요소를 업데이트할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t[<span class="number">2</span>:<span class="number">3</span>] = [<span class="string">'x'</span>, <span class="string">'y'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; print(t)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="배열-라이브러리"><a href="#배열-라이브러리" class="headerlink" title="배열 라이브러리"></a>배열 라이브러리</h3><p>줄리아는 배열에서 작동하는 함수들을 제공한다. 예를 들어, <code>push!()</code>는 배열 끝에 새로운 요소를 추가한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; push!(t, <span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure>
<p><code>append!()</code>는 첫 번째 인수 배열 끝에 두 번째 인수인 배열을 추가한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; t2 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; append!(t1, t2);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t1)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
<p>위의 예시에서 <code>t2</code>는 수정되지 않은 채로 유지된다.</p>
<p><code>sort!()</code>는 낮은 단위에서 높은 단위 순으로 배열 요소들을 정리한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [<span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; sort!(t);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
<p><code>sort()</code>는 배열 요소들을 순서에 맞게 정리한 복사본을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t1 = [<span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; t2 = sort(t1);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t1)</span><br><span class="line">[<span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]</span><br><span class="line">julia&gt; print(t2)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
<p><code>sort()</code>와 <code>sort!()</code>의 차이점은 배열이 영구적으로 변하는지에 있다. 쉽게 이야기하면, <code>sort!()</code>를 사용하면 배열의 순서가 영구적으로 변하지만, <code>sort()</code>를 사용하면 기존 배열은 변하지 않고 순서가 변경된 배열만 보여준다.</p>
<p><strong>Note</strong><br>줄리아에서 사용되는 <code>!</code>는 인수를 변경하기 위한 함수 뒤에 추가한다.</p>
<h3 id="맵-필터-그리고-리듀스-Map-Filter-and-Reduce"><a href="#맵-필터-그리고-리듀스-Map-Filter-and-Reduce" class="headerlink" title="맵, 필터 그리고 리듀스 (Map, Filter and Reduce)"></a>맵, 필터 그리고 리듀스 (Map, Filter and Reduce)</h3><p>배열에 모든 숫자들을 더하기 위해서는 아래의 루프를 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> addall(t)</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> t</span><br><span class="line">        total += x</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    total</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>total</code>은 0으로 시작한다. 각 루프가 실행될 때마다 <code>+=</code>는 배열로부터 한 개의 요소를 얻는다. <code>+=</code> 연산자는 변수를 업데이트하는 간단한 방법을 제공한다.<br>아래의 코드는 ‘증강 할당문(augmented assignment statement)’이며,</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">total += x</span><br></pre></td></tr></table></figure>
<p>위의 코드는 아래의 코드와 같은 의미이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">total = total + x</span><br></pre></td></tr></table></figure>
<p>루프가 실행될 때, <code>total</code>은 요소들의 합을 누적한다. 이런 방식으로 사용되는 변수를 ‘누적 계산기(accumulator)’라고 부른다.</p>
<p>배열 요소를 합산하는 것은 줄리아가 제공하는 내장 함수인 <code>sum()</code>을 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; sum(t)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>시퀀스로 연결되어 있는 요소들을 하나의 요소로 결합하는 작업을 리듀스 작업(reduce operation)이라고 한다.</p>
<p>다른 배열을 만들기 위해서 한 배열을 순회하는 경우도 있다. 예를 들어, 아래의 함수는 기존 문자열들의 대문자를 반환하여 새로운 배열을 만든다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> capitalizeall(t)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> t</span><br><span class="line">        push!(res, uppercase(s))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    res</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>res</code>는 빈 배열을 만든다. 루프가 매번 실행될 때마다, <code>res</code>에 요소들을 추가한다. 따라서 <code>res</code>도 누적 계산기로 봐도 상관없다.</p>
<p><code>capitalizeall()</code>와 같은 작동방식은 가끔 <strong>맵(map)</strong>이라고 불린다. 왜냐하면 <code>uppercase()</code>처럼 순서대로 각 요소를 찾아 매핑(mapping)하는 함수가 있기 때문이다.</p>
<p>또다른 일반적인 작동방식은 배열에서 일부 요소를 선택하여 ‘하위 배열(subarray)’을 반환하는 것이다. 예를 들어 아래의 함수는 문자열 배열을 가져와서 대문자만 포함하는 하위 배열을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> onlyupper(t)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> t</span><br><span class="line">        <span class="keyword">if</span> s == uppercase(s)</span><br><span class="line">            push!(res, s)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    res</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 예시처럼 조건에 적합한 요소만을 선택하여 가져오는 <code>onlyupper()</code>과 같은 작동방식을 필터(filter)라고 한다.</p>
<p>가장 일반적인 배열 작동방식은 맵, 필터, 리듀스의 결합으로서 표현된다.</p>
<h3 id="도트-문법-Dot-Syntax"><a href="#도트-문법-Dot-Syntax" class="headerlink" title="도트 문법(Dot Syntax)"></a>도트 문법(Dot Syntax)</h3><p><code>^</code>와 같은 모든 이항 연산자(binary operator)에는 대응하는 도트 연산자가 있다. 아래의 코드는 요소마다 <code>^</code>연산자가 자동으로 실행되도록 정의하였다. <code>[1, 2, 3] .^ 3</code>는 자체적으로 정의되지 않았지만, 컴퓨터는 뒤의 <code>.^ 3</code>가 앞의<code>[1, 2, 3]</code>에 각각 적용되어 <code>[1^3, 2^3, 3^3]</code>의 결과를 도출한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; print([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] .^ <span class="number">3</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure>
<p>모든 줄리아 함수는 어떤 배열에서든 도트 문법을 사용하여 요소별로 적용할 수 있다 예를 들어, 문자열 배열을 루프를 사용하지 않고도 대문자로 표시할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = uppercase.([<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>]);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t)</span><br><span class="line">[<span class="string">"ABC"</span>, <span class="string">"DEF"</span>, <span class="string">"GHI"</span>]</span><br></pre></td></tr></table></figure>
<p>이것은 더 깔끔하게 맵을 만드는 방법이다. <code>capitalizeall()</code>를 한 줄로 구현할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> capitalizeall(t)</span><br><span class="line">    uppercase.(t)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="요소-삭제와-삽입"><a href="#요소-삭제와-삽입" class="headerlink" title="요소 삭제와 삽입"></a>요소 삭제와 삽입</h3><p>배열에서 요소를 삭제하는 방법은 여러 개가 있다. 만약 삭제하고 싶은 요소의 인덱스를 알고 있다면, <code>splice!()</code>를 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; splice!(t, <span class="number">2</span>)</span><br><span class="line"><span class="string">'b'</span>: ASCII/Unicode U+<span class="number">0062</span> (category Ll: Letter, lowercase)</span><br><span class="line">julia&gt; print(t)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<p><code>splice!()</code>는 배열을 수정하고 해당 요소가 제거된 배열을 반환한다.</p>
<p><code>pop!()</code>은 마지막 요소를 제거한 후 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; pop!(t)</span><br><span class="line"><span class="string">'c'</span>: ASCII/Unicode U+<span class="number">0063</span> (category Ll: Letter, lowercase)</span><br><span class="line">julia&gt; print(t)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br></pre></td></tr></table></figure>
<p><code>popfirst!()</code>은 첫 번째 요소를 제거한 후 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; popfirst!(t)</span><br><span class="line"><span class="string">'a'</span>: ASCII/Unicode U+<span class="number">0061</span> (category Ll: Letter, lowercase)</span><br><span class="line">julia&gt; print(t)</span><br><span class="line">[<span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<p><code>pushfirst!()</code>와 <code>push!()</code>는 배열의 시작과 끝에 각각 요소를 삽입한다.</p>
<p>만약 제거된 요소가 필요없다면, <code>deleteat!()</code>을 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; print(deleteat!(t, <span class="number">2</span>))</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<p><code>insert!()</code>는 주어진 인덱스에 요소를 삽입한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; print(insert!(t, <span class="number">2</span>, <span class="string">'x'</span>))</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'x'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="배열과-문자열"><a href="#배열과-문자열" class="headerlink" title="배열과 문자열"></a>배열과 문자열</h3><p>문자열을 문자의 나열이고 배열은 값들의 나열이지만, 문자 배열과 문자열은 다르다. <code>collect()</code>를 사용하면 문자열에서 문자 배열로 변환할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = collect(<span class="string">"spam"</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t)</span><br><span class="line">[<span class="string">'s'</span>, <span class="string">'p'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>]</span><br></pre></td></tr></table></figure>
<p><code>collect()</code>는 문자열을 깨고 문자들을 각각의 요소로 변경해준다.</p>
<p>만약 문장을 단어 단위로 쪼개고 싶다면, <code>split()</code>를 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = split(<span class="string">"pining for the fjords"</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t)</span><br><span class="line"><span class="built_in">SubString</span>&#123;<span class="built_in">String</span>&#125;[<span class="string">"pining"</span>, <span class="string">"for"</span>, <span class="string">"the"</span>, <span class="string">"fjords"</span>]</span><br></pre></td></tr></table></figure>
<p><code>split()</code>에서 구분 기호 등을 추가적 인수로 사용하면 구분 기호에 따라서 단어로 나눠준다. 아래의 예시는 하이픈(-)기호를 추가 인수로 사용하였다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = split(<span class="string">"spam-spam-spam"</span>, <span class="string">'-'</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t)</span><br><span class="line"><span class="built_in">SubString</span>&#123;<span class="built_in">String</span>&#125;[<span class="string">"spam"</span>, <span class="string">"spam"</span>, <span class="string">"spam"</span>]</span><br></pre></td></tr></table></figure>
<p><code>join()</code>은 <code>split()</code>의 반대이다. 단어들 사이에 구분자를 넣고 싶다면 <code>join()</code>을 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [<span class="string">"pining"</span>, <span class="string">"for"</span>, <span class="string">"the"</span>, <span class="string">"fjords"</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; s = join(t, <span class="string">' '</span>)</span><br><span class="line"><span class="string">"pining for the fjords"</span></span><br></pre></td></tr></table></figure>
<p>위의 예시에서는 구분 기호로 공백을 사용하였다. 만약 공백 없이 단어를 연결하고 싶다면 구분 기호를 인수로 추가하지 않으면 된다.</p>
<h3 id="객체와-값"><a href="#객체와-값" class="headerlink" title="객체와 값"></a>객체와 값</h3><p>객체(object)는 변수가 참고할 수 있는 어떤 것이다. 지금까지는 객체와 값을 동일시하여 사용할 수 있었다.</p>
<p>아래의 할당문을 실행해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"banana"</span></span><br><span class="line">b = <span class="string">"banana"</span></span><br></pre></td></tr></table></figure>
<p>위의 예시는 <code>a</code>와 <code>b</code>가 동일한 문자열을 가지고 있다는 것을 보여준다. 하지만 컴퓨터도 동일한 문자열로 인식하는지, 아니면 각각 다른 문자열로 인식하는지는 알 수 없다.</p>
<p><img src="/images/chap_9.png" alt="state diagrams"></p>
<p>첫 번째의 경우는 동일한 값의 다른 객체를 <code>a</code>와 <code>b</code>가 가지고 있는 경우이며, 두 번째는 <code>a</code>와 <code>b</code>가 동일한 객체를 가지고 있는 경우이다.</p>
<p>두 변수가 동일한 객체를 가지고 있는지 확인하려면, <code>===</code> 또는 <code>≡</code>(<code>\equiv TAB</code>)연산자를 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; a = <span class="string">"banana"</span></span><br><span class="line"><span class="string">"banana"</span></span><br><span class="line">julia&gt; b = <span class="string">"banana"</span></span><br><span class="line"><span class="string">"banana"</span></span><br><span class="line">julia&gt; a ≡ b</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>해당 예시에서는 줄리아가 오로지 하나의 문자열 객체를 만들었다. 하지만 배열의 경우에는 각각의 배열 객체들이 생성된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; a == b</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">julia&gt; a ≡ b</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><code>==</code> 연산자는 불 연산자로 두 변수의 값이 같은지의 여부를 <code>ture</code> 또는 <code>false</code>로 반환한다. 위의 예시를 보면 <code>a</code>와 <code>b</code>의 값은 같기 때문에 <code>==</code> 연산자의 결과는 <code>ture</code>를 반환하지만, 객체가 동일한지 판단하는 <code>===</code> 연산자의 결과는 <code>false</code>를 반환한다.</p>
<p><img src="/images/13.png" alt="state diagrams"></p>
<p>위의 예시에서 두 배열은 동일한 요소들을 가지고 있기 때문에 두 객체가 같다(same)고 설명할 수 있지만, 두 객체가 동일(identical)하다고 말할 수는 없다. 즉, 두 객체가 동일하다면 같다고 말할 수 있지만, 두 객체가 같다고 해서 동일하다고 할 수는 없다.</p>
<p>정확하게 설명하면 객체는 값을 가지고 있다. 예로 <code>[1,2,3]</code>는 값이 정수 시퀀스인 배열 객체를 얻는다. 만약 다른 배열에 동일한 요소가 있다면, 값은 같지만 동일한 객체라고 가정하지는 않는다.</p>
<h3 id="에일리어싱-Aliasing"><a href="#에일리어싱-Aliasing" class="headerlink" title="에일리어싱 (Aliasing)"></a>에일리어싱 (Aliasing)</h3><p>객체를 가진<code>a</code>로 <code>b=a</code>를 통해 <code>b</code>를 할당한다면, 두 변수는 같은 객체를 가진다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; b = a;</span><br><span class="line"></span><br><span class="line">julia&gt; b ≡ a</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/14.png" alt="state diagrams"></p>
<p>변수와 객체와의 연관성을 레퍼런스(reference)라고 한다. 이 예에서는 동일한 객체에 대한 두 개의 레퍼런스가 있다.</p>
<p>한 개 이상의 레퍼런스를 가진 객체는 둘 이상의 이름을 가지게 되므로 그 객체는 에일리어싱되었다고 설명한다.</p>
<p>에일리어싱된 객체의 값이 변하는 경우, 그 변화는 연결된 변수들에게도 적용된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">julia&gt; b[<span class="number">1</span>] = <span class="number">42</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line">julia&gt; print(a)</span><br><span class="line">[<span class="number">42</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p><strong>WARNING</strong><br>위의 방식은 유용하게 사용되지만, 동시에 오류가 발생하기 쉽다. 일반적으로 변경 가능한 객체로 작업할 때에는 에일리어싱을 피하는 것이 더 안전하다.</p>
<p>문자열과 같이 변경 불가능한 객체의 경우에는 에일리어싱이 큰 문제가 되지 않는다. 아래의 예시를 보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"banana"</span></span><br><span class="line">b = <span class="string">"banana"</span></span><br></pre></td></tr></table></figure>
<p>위의 예사에서는 <code>a</code>와 <code>b</code>가 동일한 객체를 가지는지 아닌지에 대한 여부는 큰 차이가 없다는 것을 볼 수 있다.</p>
<h3 id="배열-인수"><a href="#배열-인수" class="headerlink" title="배열 인수"></a>배열 인수</h3><p>배열을 함수에 전달하면, 함수는 배열을 참조한다. 그래서 함수가 배열을 수정하면 사용자에게 변경된 내용이 표시된다. 예를 들어 <code>deletehead!()</code>를 사용하여 첫 번째 요소를 삭제해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> deletehead!(t)</span><br><span class="line">    popfirst!(t)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> 실행 흐름을 확인해보면 인수로 입력된 배열을 가져와서 <code>popfirst!()</code>로 첫 번째 요소를 삭제한다. <code>!</code>가 입력된 함수는 기존의 배열을 수정한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; deletehead!(letters);</span><br><span class="line"></span><br><span class="line">julia&gt; print(letters)</span><br><span class="line">[<span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<p>매개변수 <code>t</code>와 변수 <code>letters</code>는 객체의 에일리어스이다. 아래의 그림에서 확인해보자.</p>
<p><img src="/images/15.png" alt="state diagrams"></p>
<p>배열을 수정하는 작업과 새 배열을 만드는 작업을 구분하는 것은 매우 중요하다. 예를들어 <code>push!()</code>는 배열을 수정하지만 <code>vcat()</code>은 새로운 배열을 만든다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; t2 = push!(t1, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t1)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p><code>t2</code>는 <code>t1</code>의 에일리어스이다.</p>
<p>아래의 코드는 <code>vcat()</code>의 예시이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">jjulia&gt; t3 = vcat(t1, [<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t1)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">julia&gt; print(t3)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><code>vcat()</code>은 <code>t3</code>라는 새로운 배열을 만들었으며, <code>t1</code>은 변하지 않았다.</p>
<p>이런 차이점은 배열을 수정해야 하는 함수를 작성할 때 매우 중요하다.</p>
<p>예를 들어, 아래의 함수는 배열의 앞부분(head)을 삭제하지 않는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> baddeletehead(t)</span><br><span class="line">    t = t[<span class="number">2</span>:<span class="keyword">end</span>]                <span class="comment"># WRONG!</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>슬라이스 연산자는 새 배열을 만들고 할당 연산자는 해당 배열을 참조하여 새 배열의 값을 정한다. 하지만 이것들은 호출된 배열에 영향을 주지는 않는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t4 = baddeletehead(t3);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t3)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">julia&gt; print(t4)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><code>baddeletehead()</code>의 시작부분에서 <code>t4</code>와 <code>t3</code>는 동일한 배열을 나타낸다. 마지막에는 <code>t4</code>는 새 배열을 나타내지만 <code>t3</code>는 이전 배열을 그대로 유지하고 있다.</p>
<p>대안은 새로운 배열을 생성하고 반환하는 함수를 작성하는 것이다. 예를 들어 <code>tail()</code>은 배열의 첫 번째 요소를 제외한 모든 요소를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> tail(t)</span><br><span class="line">    t[<span class="number">2</span>:<span class="keyword">end</span>]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 함수는 기존의 배열을 수정하지 않은 채로 유지한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; rest = tail(letters);</span><br><span class="line"></span><br><span class="line">julia&gt; print(rest)</span><br><span class="line">[<span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>배열 및 기타 변경 가능한 객체 등을 주의해서 사용하지 않으면 오랜 시간 디버깅 할 수 있다. 일반적인 함정을 피하는 방법은 아래와 같다.</p>
<ul>
<li><p>대부분의 배열 함수들은 인수를 수정한다. 이는 문자열 함수가 기존 문자열을 그대로 두고 새로운 문자열을 반환하는 것과 정확히 반대이다.</p>
<p>문자열 코드를 작성하는 데 익숙한 경우에는</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">new_word = strip(word)</span><br></pre></td></tr></table></figure>
<p>다음과 같이 배열 코드도 작성하려고 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">t2 = sort!(t1)</span><br></pre></td></tr></table></figure>
<p><code>sort!()</code>은 수정된 원래 <code>t1</code>을 반환하고 <code>t2</code>는 <code>t1</code>의 에일리언스이다. 즉, <code>sort!()</code>를 사용할 때는 원본이 수정되기 때문에 새로 할당할 필요가 없다는 것이다.</p>
<p><strong>Tip</strong><br>배열 함수와 연산자를 사용하기 전에 설명서를 주의해서 읽고 대화식 모드에서 테스트를 해보는 것이 좋다.</p>
</li>
<li><p>관용구를 선택해서 붙여라<br>배열과 관련된 문제 중 하나는 작업을 수행하는 방법이 너무 많다는 것이다. 예를 들어 배열에서 요소를 제거하려면 <code>pop!</code>, <code>popfirst!</code>, <code>delete_at</code> 또는 슬라이스 할당을 사용할 수도 있다. 요소를 추가하는 것은 <code>push!</code>, <code>pushfirst!</code>, <code>insert!</code> 또는 <code>vcat</code>을 사용한다. <code>t</code>가 배열이고 <code>x</code>가 배열 요소라고 가정하여 배열에 추가한다면 아래의 코드와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">insert!(t, <span class="number">4</span>, x)</span><br><span class="line">push!(t, x)</span><br><span class="line">append!(t, [x])</span><br></pre></td></tr></table></figure>
<p>그리고 아래는 올바르지 못한 코드이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">insert!(t, <span class="number">4</span>, [x])         <span class="comment"># WRONG!</span></span><br><span class="line">push!(t, [x])              <span class="comment"># WRONG!</span></span><br><span class="line">vcat(t, [x])               <span class="comment"># WRONG!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>에일리언싱을 피하기 위해 복사본을 만들어라<br><code>sort!</code>와 같은 함수를 사용하려면 인수를 수정하지만 원래 배열도 가지고 있어야 한다. 복사본을 만들어서 가지고 있는 것이 좋다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; t2 = t[:]; <span class="comment"># t2 = copy(t)</span></span><br><span class="line"></span><br><span class="line">julia&gt; sort!(t2);</span><br><span class="line"></span><br><span class="line">julia&gt; print(t)</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">julia&gt; print(t2)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>위의 예시에서는 내장 함수인 기존의 배열은 유지하며 새로운 배열로 반환하는 <code>sort</code>를 사용하는 것이 좋다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; t2 = sort(t);</span><br><span class="line"></span><br><span class="line">julia&gt; println(t)</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">julia&gt; println(t2)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>1. Hexo에 NexT 테마 적용하기</title>
    <url>/2020/03/08/about_hexo-1/</url>
    <content><![CDATA[<p>Hexo 블로그를 만든 다음 NexT 테마를 적용하고자 합니다.</p>
<p>아직 블로그를 만들지 않았다면 <a href="https://hyeonji-ryu.github.io/2020/02/27/test/">이전 글</a>을 참고해주시기 바랍니다.</p>
<a id="more"></a>
<p>만들어진 블로그에 테마를 적용하는 방법은 간단합니다.</p>
<ul>
<li><p>우선 <a href="https://github.com/theme-next/hexo-theme-next/releases" target="_blank" rel="noopener">NexT</a> 사이트에 들어가서 원하는 버전의 소스 코드(source code)를 다운받아 주세요.<br><strong>Tip</strong><br>다운받을 수 있는 버전 중에서 가장 최신 버전을 다운받는 것이 좋습니다. 제 경우엔 <code>v7.7.2</code>를 다운받았습니다.</p>
</li>
<li><p>다운받은 알집을 풀고 폴더 명을 <code>next</code>로 변경해주세요.</p>
</li>
<li><p>이름을 변경한 폴더를 hexo 블로그 폴더에 있는 <code>themes</code>폴더에 넣어주세요.</p>
</li>
<li><p>Hexo 블로그 폴더에서 <code>/_config.yml</code>를 열어주세요. (저의 경우에는 visual studio code를 사용합니다.)</p>
</li>
<li><p>파일 내부에 <code>themes</code> 설정으로 들어가서 <code>next</code>로 변경하고 저장해주세요.</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<ul>
<li><code>NexT</code>는 4가지의 레이아웃 테마를 가지고 있습니다. <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">이 링크</a>에서 4가지를 미리 볼 수 있습니다. 레이아웃을 결정했다면 <code>/_config.yml</code>에서 아래의 파트를 찾고, 해당 레이아웃 이름의 주석(#)을 풀어주세요. (원래 있던 코드에는 주석을 달아주세요)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>
<ul>
<li>터미널에 아래의 코드를 입력해서 잘 적용되었는지 확인해보세요. 코드를 입력하면 잘 적용되었는지 확인할 수 있는 임시 사이트를 열 수 있습니다.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line"></span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<ul>
<li>적용이 되었다면 아래의 코드를 입력해서 적용과 배포를 진행해주세요.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>이제 NexT 테마 적용이 완료되었습니다! 본인의 블로그에 들어가면 변화를 확인할 수 있습니다.</p>
]]></content>
      <categories>
        <category>about Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>blog</tag>
        <tag>헥소</tag>
        <tag>깃허브</tag>
        <tag>블로그</tag>
        <tag>NexT</tag>
        <tag>next</tag>
        <tag>테마</tag>
        <tag>themes</tag>
      </tags>
  </entry>
  <entry>
    <title>8. 사례 연구 - 워드 플레이</title>
    <url>/2020/03/06/Think-Julia-Chapter-9/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap09" target="_blank" rel="noopener">Case Study: Word Play</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="사례-연구-워드-플레이-Case-Study-Word-Play"><a href="#사례-연구-워드-플레이-Case-Study-Word-Play" class="headerlink" title="사례 연구: 워드 플레이 (Case Study: Word Play)"></a>사례 연구: 워드 플레이 (Case Study: Word Play)</h2><p>이번 장에서는 특정 속성을 가진 단어를 검색하여 단어 퍼즐을 해결하는 사례 연구를 할 것이다. 예를 들어, 영어로 된 가장 긴 회문(palindrome)을 찾아 알파벳순으로 글자가 나타나는 단어를 검색하는 것이다. 그리고 위의 방식을 축소할 수 있는 다른 프로그램들도 제시할 것이다.</p>
<h3 id="단어-리스트-불러오기"><a href="#단어-리스트-불러오기" class="headerlink" title="단어 리스트 불러오기"></a>단어 리스트 불러오기</h3><p>위의 연구를 시작하기에 앞서 우리는 단어 리스트들이 필요하다. 웹에는 많은 단어 리스트들이 있지만, 우리는 그 중 Moby lexicon project에서 사용된 단어 리스트인 Grady Ward를 사용할 것이다. 이 리스트에는 총 113809개의 단어가 저장되어 있으며, 우리는 이 단어들을 전부 사용할 수 있다. 파일의 이름은 113809.of.fic이며, 다운로드는 <a href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/data/words.txt" target="_blank" rel="noopener">이 링크</a>에서 할 수 있다.</p>
<p>줄리아로 텍스트 파일을 여는 방법은 다음과 같다. 우선 내장 함수인 <code>open()</code>에 인수로 텍스트 파일 이름을 넣어서 파일을 가져올 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fin = open(<span class="string">"words.txt"</span>)</span><br><span class="line"><span class="built_in">IOStream</span>(&lt;file words.txt&gt;)</span><br></pre></td></tr></table></figure>
<p><strong>Tip</strong><br>만약 위의 코드 실행 시 오류가 발생한다면, 대부분은 디렉토리 설정 오류일 것이다. 해결 방법은 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; pwd() <span class="comment"># 현재 디렉토리 확인</span></span><br><span class="line">julia&gt; cd ($(pwd())/단어 리스트 파일 위치)</span><br><span class="line">julia&gt; pwd() <span class="comment"># 다시 확인</span></span><br></pre></td></tr></table></figure>
<p><code>fin</code>은 입력에 사용되는 파일 스트림이며, 더 이상 필요하지 않은 경우에는 <code>close(fin)</code>으로 닫아야 한다.</p>
<p>줄리아는 <code>readline()</code>을 포함하여 몇 가지의 읽기 함수를 제공한다. <code>readline()</code>은 <code>NEWLINE</code>에 도달할 때까지 파일에서 문자를 읽고 결과를 문자열로 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; readline(fin)</span><br><span class="line"><span class="string">"aa"</span></span><br></pre></td></tr></table></figure>
<p>가져온 단어 리스트 중에 첫 번째 단어는 “aa”이며, 용암의 이름이다.<br>파일 스트림은 파일에서의 위치와 경로를 파악하고 있기 때문에 <code>readline()</code>을 한번 더 호출하면 다음 단어를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; readline(fin)</span><br><span class="line"><span class="string">"aah"</span></span><br></pre></td></tr></table></figure>
<p>다음 단어는 “aah”이다. 좀 이상하지만 실제 있는 단어이다.</p>
<p>또한 <code>for</code>루프를 사용하여 파일 내부의 단어들을 모두 가져올 수 있다. 아래의 프로그램은 words.txt를 읽고 한 줄에 한 단어씩 출력한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> eachline(<span class="string">"words.txt"</span>)</span><br><span class="line">    println(line)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="검색-Search"><a href="#검색-Search" class="headerlink" title="검색 (Search)"></a>검색 (Search)</h3><p>검색 패턴으로 해결할 수 있는 가장 간단한 예는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> hasno_e(word)</span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> word</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">'e'</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>for</code>루프는 단어의 알파벳들을 순회한다. 알파벳 <code>e</code>를 찾으면 즉시 거짓을 반환하며, 그렇지 않다면 다음 알파벳으로 이동한다. 만약 단어에서 <code>e</code>를 못찾았다면 <code>true</code>를 반환하고 종료한다.</p>
<p><code>∉(\notin TAB)</code> 연산자를 사용하여 위의 코드를 더 간결하게 작성할 수 있다. 다만 위의 함수는 검색 패턴이 어떻게 작동하는지 확인하기 위해서 먼저 살펴본 것이다.</p>
<p><code>avoids()</code>는 <code>hasno_e()</code>를 일반화시킨 함수이며, 안의 구조는 똑같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> avoids(word, forbidden)</span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> word</span><br><span class="line">        <span class="keyword">if</span> letter ∈ forbidden</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>두 번째 인수인 <code>forbidden</code>이 <code>word</code>에 속해 있다면 <code>false</code>를 반환하며, 루프가 끝까지 진행되면 <code>true</code>가 반환된다.</p>
<p><code>usesonly()</code>는 <code>avoids()</code>과 조건만 반대이고 나머지 구조는 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> usesonly(word, available)</span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> word</span><br><span class="line">        <span class="keyword">if</span> letter ∉ available</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>usesonly()</code>는 <code>forbidden</code> 문자 배열 대신에 <code>available</code> 문자 배열이 들어가며, <code>word</code> 알파벳 중에서 <code>available</code>에 속한 문자가 없다면 <code>false</code>를 반환한다.</p>
<p>또한 포함되어야 하는 알파벳 문자열을 사용한 <code>usesall()</code>은 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> usesall(word, required)</span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> required</span><br><span class="line">        <span class="keyword">if</span> letter ∉ word</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>usesall()</code>은 루프에서 <code>word</code>의 알파벳을 가져오는 것이 아니라 <code>required</code>에서 알파벳을 가져온다. 만약 <code>required</code> 알파벳이 <code>word</code>에 없다면 <code>false</code>를 반환한다.</p>
<p>만약 실제 컴퓨터 과학자처럼 생각한다면, <code>usesall()</code>이 <code>usesonly()</code>와 인수 위치만 변화된 것을 파악할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> usesall(word, required)</span><br><span class="line">    usesonly(required, word)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 이전에 만들었던 함수로 프로그램 개발을 축소하는 과정의 예이다. 인자 설정만 잘하면 기존 함수들을 이용하여 문제를 해결할 수 있다.</p>
<h3 id="인덱스를-이용한-루핑"><a href="#인덱스를-이용한-루핑" class="headerlink" title="인덱스를 이용한 루핑"></a>인덱스를 이용한 루핑</h3><p>그동안은 문자열 안에 문자만 필요했기 때문에 <code>for</code> 루프를 사용해서 함수를 작성해왔다. 즉, 인덱스를 사용할 필요가 없었다.</p>
<p>하지만 아래의 <code>isabecedarian()</code>는 단어 안의 특정 문자와 인접한 문자들을 비교해야 하기 때문에 <code>for</code> 루프를 사용하면 함수 작성이 어려워진다. 참고로 <code>isabecedarian()</code>는 알파벳 순서로 작성된 단어인지를 판단하는 함수이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isabecedarian(word)</span><br><span class="line">    i = firstindex(word)</span><br><span class="line">    previous = word[i]</span><br><span class="line">    j = nextind(word, i)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> word[j:<span class="keyword">end</span>]</span><br><span class="line">        <span class="keyword">if</span> c &lt; previous</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        previous = c</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>재귀를 사용한 대안은 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isabecedarian(word)</span><br><span class="line">    <span class="keyword">if</span> length(word) &lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i = firstindex(word)</span><br><span class="line">    j = nextind(word, i)</span><br><span class="line">    <span class="keyword">if</span> word[i] &gt; word[j]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    isabecedarian(word[j:<span class="keyword">end</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>while</code> 루프를 사용한 다른 방법은 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isabecedarian(word)</span><br><span class="line">    i = firstindex(word)</span><br><span class="line">    j = nextind(word, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> j &lt;= sizeof(word)</span><br><span class="line">        <span class="keyword">if</span> word[j] &lt; word[i]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i = j</span><br><span class="line">        j = nextind(word, i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드에서 루프는 <code>i=1</code> 와 <code>j=nextind(word, 1)</code>로 시작하며, <code>j&gt;sizeof(word)</code>일 때 끝난다. 각각의 루프는 <code>i</code>(현재 알파벳)와 <code>j</code>(다음 순서의 알파벳)를 비교한다.</p>
<p>만약 <code>j</code>보다 <code>i</code>가 더 크면, 알파벳의 순서가 깨졌기 때문에 <code>false</code>를 반환한다. 그 외에 <code>while</code> 루프가 다 끝나면 그 단어는 해당 테스트를 통과한 것이다. 루프가 잘 작동하는지 확인하기 위해서 예시인 <code>&quot;flossy&quot;</code>를 넣어서 실행해보자.</p>
<p>아래의 코드는 문자열의 처음과 끝을 인덱스로 잡아 비교하는 함수 <code>ispalindrome()</code>이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> ispalindrome(word)</span><br><span class="line">    i = firstindex(word)</span><br><span class="line">    j = lastindex(word)</span><br><span class="line">    <span class="keyword">while</span> i&lt;j</span><br><span class="line">        <span class="keyword">if</span> word[i] != word[j]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i = nextind(word, i)</span><br><span class="line">        j = prevind(word, j)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>또한 우리가 함수를 이용해서 더 간결하게 작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> ispalindrome(word)</span><br><span class="line">    isreverse(word, word)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>프로그램을 테스트하는 것은 어렵다. 이 장에서 작성한 함수들은 작성자가 직접 결과를 확인할 수 있기 때문에 테스트하기 쉽게 연결된 형태이다. 그렇지만 오류 가능성을 확인하기 위한 단어를 선택하는 것은 어렵고 거의 불가능하다.</p>
<p><code>hasno_e</code>를 예시로 보면, 이 함수에는 명백하게 확인해야 할 것들이 두 가지가 있다. <code>e</code> 가 들어간 단어는 무조건 <code>false</code>를 반환해야 하며, <code>true</code>를 반환해서는 안된다. 아마 단어 각각을 대입했을 때에는 문제가 없었을 것이다.</p>
<p>각 <code>e</code>를 포함하고 있는 단어들은 <code>e</code>의 위치를 파악하기 위해서 시작점, 끝, 그리고 중간쯤에도 확인을 해야한다. 그렇기 때문에 긴 단어, 짧은 단어, 빈 문자 등을 테스트해야 한다. 빈 문자(empty string)는 에러가 어디있는지 숨겨주기 때문에 명확하지 못한 조금 특별한 경우이다.</p>
<p>게다가 일반화하기 위해 실행하는 테스트의 경우, 단어 리스트 전체를 사용해서 프로그램을 테스트해야 한다. 결괏값을 출력함으로써 오류들을 확인할 수 있다. 주의해야 할 점은 실제로 오류가 없지만 오류로 파악되는 경우, 실제로 오류가 있지만 보이지 않는 경우 등이 있을 수 있다.</p>
<p>일반적으로 테스트하는 것은 버그를 찾는 데 도움을 주지만, 몇몇의 좋은 테스트 결과만을 가지고 코드를 일반화하기는 어렵다. 심지어 테스트를 많이 해도 프로그램이 올바르게 작동되고 있다고 확신하기는 어려울 것이다.</p>
<p>전설적인 컴퓨터 사이언티스트는 아래와 같이 말했다.</p>
<p>“프로그램 테스팅은 버그를 미리 보기 위해 사용되지만, 버그가 없다는 결론을 보여주지는 않는다.”</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>7. 문자열</title>
    <url>/2020/03/05/Think-Julia-Chapter-8/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap08" target="_blank" rel="noopener">Strings</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="문자열-Strings"><a href="#문자열-Strings" class="headerlink" title="문자열 (Strings)"></a>문자열 (Strings)</h2><p>문자열은 정수나 소수, 불 표현식과는 다르다. 이 장에서는 문자열을 구성하는 문자에 접근하는 방법을 배우고, 줄리아가 제공하는 문자열 도우미 함수 중 일부에 대해서 알아볼 것이다.</p>
<h3 id="캐릭터-Characters"><a href="#캐릭터-Characters" class="headerlink" title="캐릭터 (Characters)"></a>캐릭터 (Characters)</h3><p>영어를 사용하는 사람들은 알파벳, 숫자 및 일반적인 문장 부호와 같은 문자에 익숙하다. 이런 문자들은 표준화되어 ASCII 표준에 따라 0부터 127사이의 정수 값으로 일대일 배치한다. 영어가 아닌 한국어나 중국어, 아랍어와 같아느 언어들도 ASCII 표준에 포함되어 있다.</p>
<p>유니 코드 표준은 복잡하게 구성된 문자들도 정확히 표현할 수 있도록 고안되었기 때문에 일반적으로 주요한 표준으로 사용되고 있으며, 전 세계적으로 모든 문자들에 고유 번호를 제공한다.</p>
<p><code>Char</code> 값은 단일 문자를 나타내며, 작은 따옴표로 묶는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="string">'x'</span></span><br><span class="line"><span class="string">'x'</span>: ASCII/Unicode U+<span class="number">0078</span> (category Ll: Letter, lowercase)</span><br><span class="line">julia&gt; '🍌'</span><br><span class="line">'🍌': Unicode U+<span class="number">01f34</span>c (category So: <span class="built_in">Symbol</span>, other)</span><br><span class="line">julia&gt; typeof(<span class="string">'x'</span>)</span><br><span class="line"><span class="built_in">Char</span></span><br></pre></td></tr></table></figure>
<p>위의 바나나와 같은 이모티곤 또한 유니코드 표준에 포함되어 있다. (\:banana: TAB)</p>
<h3 id="문자열은-시퀀스이다-A-String-Is-a-Sequence"><a href="#문자열은-시퀀스이다-A-String-Is-a-Sequence" class="headerlink" title="문자열은 시퀀스이다. (A String Is a Sequence)"></a>문자열은 시퀀스이다. (A String Is a Sequence)</h3><p>문자열은 일련의 문자이다. 대괄호 연산자를 사용하여 한 번에 하나씩 문자에 엑세스 할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fruit = <span class="string">"banana"</span></span><br><span class="line"><span class="string">"banana"</span></span><br><span class="line">julia&gt; letter = fruit[<span class="number">1</span>]</span><br><span class="line"><span class="string">'b'</span>: ASCII/Unicode U+<span class="number">0062</span> (category Ll: Letter, lowercase)</span><br></pre></td></tr></table></figure>
<p>두 번째 명령문은 <code>fruit</code>에서 첫 번째 문자를 선택하여 <code>letter</code>라는 변수에 할당한다.</p>
<p>위와 같이 대괄호[]를 내부에 있는 표현식을 인덱스(index)라고 부른다. 인덱스는 문자열 중에서 원하는 문자가 어느 위치에 있는지를 나타낸다.</p>
<p>줄리아는 모든 인덱싱을 1부터 시작한다. 즉, 첫 번째 문자는 인덱스 1로 찾을 수 있으며, 마지막 문자는 인덱스 <code>end</code>에서 찾을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fruit[<span class="keyword">end</span>]</span><br><span class="line"><span class="string">'a'</span>: ASCII/Unicode U+<span class="number">0061</span> (category Ll: Letter, lowercase)</span><br></pre></td></tr></table></figure>
<p>또한 인덱스는 변수나 연산자가 포함된 표현식들도 사용될 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; i = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">julia&gt; fruit[i+<span class="number">1</span>]</span><br><span class="line"><span class="string">'a'</span>: ASCII/Unicode U+<span class="number">0061</span> (category Ll: Letter, lowercase)</span><br><span class="line">julia&gt; fruit[<span class="keyword">end</span>-<span class="number">1</span>]</span><br><span class="line"><span class="string">'n'</span>: ASCII/Unicode U+<span class="number">006</span><span class="literal">e</span> (category Ll: Letter, lowercase)</span><br></pre></td></tr></table></figure>
<p>그러나 인덱스 값이 정수가 아니라면 오류 메시지가 뜬다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; letter = fruit[<span class="number">1.5</span>]</span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching getindex(::<span class="built_in">String</span>, ::<span class="built_in">Float64</span>)</span><br></pre></td></tr></table></figure>
<h3 id="length"><a href="#length" class="headerlink" title="length"></a><code>length</code></h3><p><code>length</code>는 내장 함수로 문자열 안에 있는 문자들의 개수를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fruits = <span class="string">"🍌 🍎 🍐"</span></span><br><span class="line"><span class="string">"🍌 🍎 🍐"</span></span><br><span class="line">julia&gt; len = length(fruits)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>위의 예시를 보면 <code>length</code>는 이모티콘 3개와 그 사이의 띄어쓰기를 포함하여 총 길이를 <code>5</code>라고 반환한다.</p>
<p>문자열의 마지막 문자를 얻고 싶다면, 아래의 코드를 입력하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; last = fruits[len]</span><br><span class="line"><span class="string">' '</span>: ASCII/Unicode U+<span class="number">0020</span> (category Zs: Separator, space)</span><br></pre></td></tr></table></figure>
<p>하지만 기대했던 것과는 다른 결과가 나온다. 문자열은 다양한 UTF-8 인코딩을 사용하여 인코딩되었다. UTF-8은 가변적으로 폭이 변하는 인코딩 (variable-width encoding)으로 모든 문자가 동일한 바이트 수로 인코딩되지 않는다.</p>
<p><code>sizeof()</code>는 문자의 바이트 수를 보여준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; sizeof(<span class="string">"🍌"</span>)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>위 이모티콘은 4바이트로 인코딩되었고 문자열 인덱싱은 바이트 기반이기 때문에 <code>fruits</code>의 5번째 요소는 띄어쓰기인 <code>SPACE</code> 이다.</p>
<p>이것은 UTF-8 문자열에서 모든 문자들은 정확히 몇 바이트로 인덱싱 되었는지 확인해야 한다는 것을 보여준다. 만약 눈으로 파악한 인덱스를 사용한다면, 잘못된 결과를 도출할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fruits[<span class="number">2</span>]</span><br><span class="line">ERROR: StringIndexError(<span class="string">"🍌 🍎 🍐"</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><code>fruits</code>예시에서는 <code>🍌</code>가 4바이트이기 때문에 인덱스 2,3,4는 반환되지 않으며, 그 다음 유효한 인덱스는 5이다. 다음 유효한 인덱스를 찾고 싶다면 <code>nextind(fruits, 1)</code>을 입력하면 된다. 이후 5 다음으로 유효한 인덱스를 찾고 싶다면 <code>nextind(fruits, 5)</code>를 실행하면 된다.</p>
<h3 id="순회-Traversal"><a href="#순회-Traversal" class="headerlink" title="순회 (Traversal)"></a>순회 (Traversal)</h3><p>많은 계산들은 한 번에 한 문자씩 문자열을 처리한다. 이때 컴퓨터는 하나의 문자를 선택하여 해당 명령들을 수행한 이후, 다른 문자를 선택하여 이를 반복한다. 이것을 순회(Traversal)이라고 하며, 순회를 작성하는 방법은 <code>while</code> 루프를 사용하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">index = firstindex(fruits)</span><br><span class="line"><span class="keyword">while</span> index &lt;= sizeof(fruits)</span><br><span class="line">    letter = fruits[index]</span><br><span class="line">    println(letter)</span><br><span class="line">    <span class="keyword">global</span> index = nextind(fruits, index)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 변수 <code>index</code>에 <code>fruits</code>의 첫 번째 인덱스를 할당한다. 그 후 <code>while</code>루프 조건으로 넘어간다. 조건은 <code>index</code>가 <code>fruits</code>의 인덱스 총 길이보다 작으면 <code>true</code>을 도출하여 루프를 실행하거나, 크면 <code>false</code>를 도출하여 루프를 종료한다.</p>
<p><code>firstindex()</code>는 인수의 첫 번째 인덱스를 반환한다. 키워드 <code>global</code>는 기존에 정의했던 변수에 새로운 값을 재할당한다.</p>
<h3 id="문자열-슬라이스-String-Slices"><a href="#문자열-슬라이스-String-Slices" class="headerlink" title="문자열 슬라이스 (String Slices)"></a>문자열 슬라이스 (String Slices)</h3><p>문자열의 일부를 슬라이스(Slices)라고 부른다. 슬라이스는 문자를 축출하는 것과 비슷하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; str = <span class="string">"Julius Caesar"</span>;</span><br><span class="line"></span><br><span class="line">julia&gt; str[<span class="number">1</span>:<span class="number">6</span>]</span><br><span class="line"><span class="string">"Julius"</span></span><br></pre></td></tr></table></figure>
<p>연산자 <code>[n:m]</code>은 인덱스 <code>n</code>번째 바이트부터 <code>m</code>번째 바이트까지의 문자들을 반환한다. 그렇기 때문에  인덱스 위치를 잘 파악하고 있어야 한다.</p>
<p>키워드 <code>end</code>는 마지막 문자를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; str[<span class="number">8</span>:<span class="keyword">end</span>]</span><br><span class="line"><span class="string">"Caesar"</span></span><br></pre></td></tr></table></figure>
<p>만약에 첫 번째 인덱스의 수가 두 번째 인덱스의 수보다 크다면 빈 문자(empty string)를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; str[<span class="number">8</span>:<span class="number">7</span>]</span><br><span class="line"><span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>빈 문자(empty string)는 어떤 캐릭터도 포함하지 않고 길이도 0이지만, 다른 문자열과 동일하게 사용할 수 있다.</p>
<h3 id="문자열은-변경-불가능-Strings-Are-Immutable"><a href="#문자열은-변경-불가능-Strings-Are-Immutable" class="headerlink" title="문자열은 변경 불가능 (Strings Are Immutable)"></a>문자열은 변경 불가능 (Strings Are Immutable)</h3><p>문자열을 변경하기 위해서 변수 옆에 연산자<code>[]</code>를 사용해보면 다음과 같은 결과를 얻을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; greeting = <span class="string">"Hello, world!"</span></span><br><span class="line"><span class="string">"Hello, world!"</span></span><br><span class="line">julia&gt; greeting[<span class="number">1</span>] = <span class="string">'J'</span></span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching setindex!(::<span class="built_in">String</span>, ::<span class="built_in">Char</span>, ::<span class="built_in">Int64</span>)</span><br></pre></td></tr></table></figure>
<p>위와 같은 오류가 발생하는 이유는 기존에 있던 문자열을 변경할 수 없기 때문이다. 가장 좋은 방법은 기존에 있던 문자열을 새로운 문자열로 재할당하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; greeting = <span class="string">"J"</span> * greeting[<span class="number">2</span>:<span class="keyword">end</span>]</span><br><span class="line"><span class="string">"Jello, world!"</span></span><br></pre></td></tr></table></figure>
<p>이 예시에서는 새로운 첫 글자를 <code>greeting</code>애 연결한 후 재할당한다. 원래 문자열 내부를 변경하는 것은 아니다.</p>
<h3 id="문자-보간법-String-Interpolation"><a href="#문자-보간법-String-Interpolation" class="headerlink" title="문자 보간법 (String Interpolation)"></a>문자 보간법 (String Interpolation)</h3><p>위의 예시처럼 곱셈 연산자인 <code>*</code>을 사용하여 연결하면 복잡한 변경이 요구될 때 번거로울 수 있다. 줄리아는 <code>$</code>을 사용하여 문자열 보간을 허용한다.<br>보간(Interpolation)이란 쉽게 설명하면 사이에 채워넣는 것을 의미한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; greet = <span class="string">"Hello"</span></span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line">julia&gt; whom = <span class="string">"World"</span></span><br><span class="line"><span class="string">"World"</span></span><br><span class="line">julia&gt; <span class="string">"<span class="variable">$greet</span>, <span class="subst">$(whom)</span>!"</span></span><br><span class="line"><span class="string">"Hello, World!"</span></span><br></pre></td></tr></table></figure>
<p>위의 방법은 <code>*</code>을 사용하는 것보다 더 편리하고 읽기도 쉽다.</p>
<p><code>$</code>다음에 작성되는 모든 표현식들은 문자열로 간주된다. 따라서 괄호를 사용하여 모든 표현식을 문자열로 보간할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="string">"1 + 2 = <span class="subst">$(<span class="number">1</span> + <span class="number">2</span>)</span>"</span></span><br><span class="line"><span class="string">"1 + 2 = 3"</span></span><br></pre></td></tr></table></figure>
<h3 id="검색-Searching"><a href="#검색-Searching" class="headerlink" title="검색 (Searching)"></a>검색 (Searching)</h3><p>아래의 함수는 어떤 기능을 할까?</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> find(word, letter)</span><br><span class="line">    index = firstindex(word)</span><br><span class="line">    <span class="keyword">while</span> index &lt;= sizeof(word)</span><br><span class="line">        <span class="keyword">if</span> word[index] == letter</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        index = nextind(word, index)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    -<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>find()</code>는 <code>[]</code> 연산자의 역수와 같다. 인덱스를 받아서 해당 문자를 축출하는 대신에 해당 문자를 받아서 인덱스를 축출한다. 문자를 찾지 못하면 함수는 -1을 반환한다.</p>
<p>위의 <code>while</code> 루프는 <code>word[index] == letter</code>인 경우 루프를 벗어나 값을 바로 반환한다.</p>
<p>만약 문자열에서 찾으려는 문자를 찾지 못하면, -1을 반환한다.</p>
<p>위와 같이 일련의 문자열에서 특정 문자에 대한 인덱스를 반환해주는 계산 방식을 검색(Searching)이라고 한다.</p>
<h3 id="루핑과-카운팅-Looping-and-Counting"><a href="#루핑과-카운팅-Looping-and-Counting" class="headerlink" title="루핑과 카운팅 (Looping and Counting)"></a>루핑과 카운팅 (Looping and Counting)</h3><p>아래의 코드는 해당 단어에서 <code>a</code>가 몇 번 있는지 세어서 반환해준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">word = <span class="string">"banana"</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> word</span><br><span class="line">    <span class="keyword">if</span> letter == <span class="string">'a'</span></span><br><span class="line">        <span class="keyword">global</span> counter = counter + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">println(counter)</span><br></pre></td></tr></table></figure>
<p>이 프로그램은 카운터(counter)라 불리는 다른 계산 방식이다. 변수 <code>counter</code>는 0으로 초기화되고, <code>a</code>가 나타날 때마다 1씩 증가한다. 루프에서 빠져나가면, <code>counter</code>가 가진 결과를 반환한다.</p>
<h3 id="문자열-라이브러리-String-Library"><a href="#문자열-라이브러리-String-Library" class="headerlink" title="문자열 라이브러리 (String Library)"></a>문자열 라이브러리 (String Library)</h3><p>줄리아는 물자열에서 사용할 수 있는 유용한 함수들을 제공한다. 예를 들어서 <code>uppercase()</code>는 문자열들을 인수로 받아서 대문자로 변경해준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; uppercase(<span class="string">"Hello, World!"</span>)</span><br><span class="line"><span class="string">"HELLO, WORLD!"</span></span><br></pre></td></tr></table></figure>
<p>또한 우리가 작성했던 <code>find()</code>와 유사한 함수인 <code>findfirst()</code>도 제공한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; findfirst(<span class="string">"a"</span>, <span class="string">"banana"</span>)</span><br><span class="line"><span class="number">2</span>:<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>사실은 <code>findfirst()</code>가 우리가 만든 함수보다 더 일반적이다. 이 함수는 캐릭터뿐만 아니라 문자열의 일부도 찾아준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; findfirst(<span class="string">"na"</span>, <span class="string">"banana"</span>)</span><br><span class="line"><span class="number">3</span>:<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><code>findfirst()</code>는 문자열의 첫 번째부터 특정 문자들을 찾는다. 만약 특정 지점부터 문자를 찾고 싶다면 <code>findnext()</code>를 사용하면 된다. <code>findnext()</code>는 세 번째 인수에 특정 지점 인덱스를 추가하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; findnext(<span class="string">"na"</span>, <span class="string">"banana"</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">5</span>:<span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="∈-연산자"><a href="#∈-연산자" class="headerlink" title="∈ 연산자"></a><code>∈</code> 연산자</h3><p>연산자 <code>∈(\in TAB)</code>은 불 연산자로서, 특정 문자가 문자열에 속했는지 여부를 보여준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="string">'a'</span> ∈ <span class="string">"banana"</span>    <span class="comment"># 'a' in "banana"</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>예로, 아래의 함수는 단어1과 단어2에 모두 들어 있는 문자들만 출력한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> inboth(word1, word2)</span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> word1</span><br><span class="line">        <span class="keyword">if</span> letter ∈ word2</span><br><span class="line">            print(letter, <span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>변수 이름을 잘 선택하면, 코드를 자연어처럼 읽을 수 있다.<br>“첫 번째 단어의 문자가 두 번째 단어에 속해있다면 문자를 인쇄하라”</p>
<p>아래의 코드는 <code>oranges</code>와 <code>apples</code>를 비교한 예시이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; inboth(<span class="string">"apples"</span>, <span class="string">"oranges"</span>)</span><br><span class="line">a <span class="literal">e</span> s</span><br></pre></td></tr></table></figure>
<h3 id="문자열-컴포지션-String-Comparison"><a href="#문자열-컴포지션-String-Comparison" class="headerlink" title="문자열 컴포지션 (String Comparison)"></a>문자열 컴포지션 (String Comparison)</h3><p>관계 연산자들은 문자열에서 작동한다. 다음은 두 문자가 동일한지 <code>==</code> 연산자를 사용한 예시이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">word = <span class="string">"Pineapple"</span></span><br><span class="line"><span class="keyword">if</span> word == <span class="string">"banana"</span></span><br><span class="line">    println(<span class="string">"All right, bananas."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>다른 관계 연산자들도 알파벳순으로 단어를 넣을 때 사용할 수 있다.<br>참고로 줄리아는 대문자와 소문자를 구별하며, 알파벳 순서는 대문자가 소문자보다 앞의 글자로 인식된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Your word, Pineapple, comes before banana.</span><br></pre></td></tr></table></figure>
<p><strong>Tip</strong><br>위의 문제를 해결하는 가장 보편적인 방법은 모든 문자열을 소문자와 같은 기준 형식으로 변경하는 것이다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>시퀀스에서 인덱스를 사용해 값을 순회하면 순회의 시작과 끝을 얻기가 어렵다. 다음은 두 단어를 비교하고 한 단어가 다른 단어와 반대인 경우 <code>true</code>를 반환하는 함수를 볼 것이다. 하지만 이 함수는 두 가지의 오류를 가지고 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isreverse(word1, word2)</span><br><span class="line">    <span class="keyword">if</span> length(word1) != length(word2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i = firstindex(word1)</span><br><span class="line">    j = lastindex(word2)</span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span></span><br><span class="line">        j = prevind(word2, j)</span><br><span class="line">        <span class="keyword">if</span> word1[i] != word2[j]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i = nextind(word1, i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위 함수의 첫 번째 줄인 <code>if</code>문은 두 단어의 길이가 똑같지 않으면 즉시 <code>false</code>를 반환한다. 아무것도 반환되지 않는다면 두 단어의 길이가 같다고 가정할 수 있다.</p>
<p><code>i</code>와 <code>j</code>는 인덱스이며, <code>i</code>는 <code>word1</code>에서 앞에서 뒤로 이동하며, <code>j</code>는 <code>word2</code> 뒤에서 앞으로 이동한다. <code>i</code>와 <code>j</code>가 일치하지 않는 순간 <code>while</code>문은 <code>false</code>를 반환한다. 모든 글자가 일치하여 전체 루프를 통과하면 함수는 <code>true</code>를 반환한다.</p>
<p>여기서 사용된 <code>lastindex()</code>는 문자열의 마지막 인덱스를 반환하고 <code>prevind()</code>는 이후 사용될 문자의 인덱스를 미리 반환하는 것이다.</p>
<p> 지금부터는 “pots”와 “stop” 두 단어를 사용하여 함수를 테스트 할 것이다.</p>
 <figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; isreverse(<span class="string">"pots"</span>, <span class="string">"stop"</span>)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>분명히 반대로 쓰여진 단어인데도 함수는 <code>false</code>를 반환했다.<br>이런 오류들을 디버깅하기 위해서 첫 번째로 할당된 인덱스들을 인쇄해볼 것이다.</p>
 <figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isreverse(word1, word2)</span><br><span class="line">    <span class="keyword">if</span> length(word1) != length(word2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i = firstindex(word1)</span><br><span class="line">    j = lastindex(word2)</span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span></span><br><span class="line">        j = prevind(word2, j)</span><br><span class="line">        <span class="meta">@show</span> i j</span><br><span class="line">        <span class="keyword">if</span> word1[i] != word2[j]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i = nextind(word1, i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드로 프로그램을 다시 작동해보면, 아래와 같은 정보를 얻을 수 있다.</p>
 <figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; isreverse(<span class="string">"pots"</span>, <span class="string">"stop"</span>)</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">j = <span class="number">3</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>첫 번째 루프에서 <code>j</code>의 값은 4이어야 하는데, 3이 나왔다. 이것은 <code>j = prevind(word2, j)</code>를 <code>while</code>루프 맨 끝으로 옮겨야 한다는 것을 의미한다.</p>
 <figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isreverse(word1, word2)</span><br><span class="line">    <span class="keyword">if</span> length(word1) != length(word2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i = firstindex(word1)</span><br><span class="line">    j = lastindex(word2)</span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span></span><br><span class="line">        <span class="meta">@show</span> i j</span><br><span class="line">        <span class="keyword">if</span> word1[i] != word2[j]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i = nextind(word1, i)</span><br><span class="line">        j = prevind(word2, j)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위 코드를 작동시키면 결과는 아래와 같다.</p>
 <figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; isreverse(<span class="string">"pots"</span>, <span class="string">"stop"</span>)</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">j = <span class="number">4</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">j = <span class="number">3</span></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">j = <span class="number">2</span></span><br><span class="line">i = <span class="number">4</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">ERROR: <span class="built_in">BoundsError</span>: attempt to access <span class="string">"pots"</span></span><br><span class="line">  at index [<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>이번에는 <code>BoundsError</code>가 발생하였다. <code>i</code>의 값이 5가 되고 문자열 “pots”의 범위를 벗어난다.</p>
<p><strong>Tip</strong><br>위의 오류를 해결한 코드</p>
 <figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isreverse(word1, word2)</span><br><span class="line">    <span class="keyword">if</span> length(word1) != length(word2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i = firstindex(word1)</span><br><span class="line">    j = lastindex(word2)</span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span></span><br><span class="line">        <span class="meta">@show</span> i j</span><br><span class="line">        <span class="keyword">if</span> word1[i] != word2[j]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i = nextind(word1, i)</span><br><span class="line">        j = prevind(word2, j)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>6. 반복</title>
    <url>/2020/03/05/Think-Julia-Chapter-7/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap07" target="_blank" rel="noopener">Iteration</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="반복-Iteration"><a href="#반복-Iteration" class="headerlink" title="반복 (Iteration)"></a>반복 (Iteration)</h2><p>이번 장에서는 명령문들을 반복해주는 반복문에 대해서 살펴볼 것이다. 우리는 이미 <a href="https://hyeonji-ryu.github.io/2020/03/03/chapter-5/">조건문과 재귀</a>에서 <code>for</code>루프를 사용한 반복문을 살펴보았다. 이번 장에서는 <code>while</code>문을 사용하는 방법을 배울 것이다. 그 전에 변수 할당에 대해서 조금 더 알아보자.</p>
<h3 id="재할당-Reassignment"><a href="#재할당-Reassignment" class="headerlink" title="재할당 (Reassignment)"></a>재할당 (Reassignment)</h3><p>제목에서 알 수 있듯이, 한 변수에 값을 여러 번 할당하는 것은 가능하다. 새로운 할당문은 이전의 값을 제거하고 새로운 값으로 변경한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x = <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">julia&gt; x = <span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>처음 코드에서 <code>x</code>는 값으로 <code>5</code>를 할당받았지만, 두 번째 코드가 실행된 이후에는 값이 <code>7</code>로 재할당된다.</p>
<p>이런 재할당의 방식은 다이어그램으로 보면 아래와 같다.</p>
<p><img src="/images/reassign.png" alt="state diagram"></p>
<p>줄리아는 할당에 등호(<code>=</code>)를 사용하기 때문에 수학식에서의 <code>a``=``b</code>와 같은 동일성(equal)으로 이해하는 경우가 종종 있다. 하지만 이것은 잘못된 개념 정의이다.</p>
<p>먼저 동일성은 대칭관계이지만 할당은 그렇지 않다. 예를 들어 수학에서 <code>a``=``7</code>인 경우 <code>7``=``a</code>도 성립하지만, 줄리아에서는 <code>a``=``7</code>로 할당한다고 해서 <code>7``=``a</code>가 옳은 것은 아니다.</p>
<p>또한 수학에서 ‘동일성의 속성(a proposition of equality)’은 항상 참(true) 또는 거짓(false)이다. 예를 들어 <code>a``=``b</code>가 참이라면 <code>a</code>는 항상 <code>b</code>와 같아야 한다. 하지만 줄리아는 재할당하면 위의 참 가정이 언제든지 깨질 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; a = <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">julia&gt; b = a    <span class="comment"># a 와 b 가 현재는 동일하다.</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">julia&gt; a = <span class="number">3</span>    <span class="comment"># a 를 재할당 하는 순간 동일성은 깨진다.</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">julia&gt; b</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>위의 코드에서 볼 수 있듯이 <code>a</code>을 재할당해도 <code>b</code>도 같이 재할당되지 않는다. 이는 할당과 동일성이 다르다는 것을 증명한다.</p>
<p><strong>주의</strong><br>변수를 재할당 하는 것은 종종 유용하지만, 주의해서 사용해야 한다. 너무 자주 변경하면 이후 코드를 읽고 디버깅하기 어려울 수 있다. 또한 이미 생성된 변수와 같은 이름으로 함수를 생성할 수 없다.</p>
<h3 id="변수-업데이트-Updating-Variables"><a href="#변수-업데이트-Updating-Variables" class="headerlink" title="변수 업데이트 (Updating Variables)"></a>변수 업데이트 (Updating Variables)</h3><p>일반적인 재할당 유형은 업데이트이며, 변수의 새 값은 이전 값에 따라 다르다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x = x + <span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 <code>x</code>의 현재 값을 얻고, 1을 더한 다음 <code>x</code>를 새로운 값으로 업데이트한다.</p>
<p>하지만 아직 생성되지 않은 변수를 업데이트 하려고 한다면, 줄리아는 오류를 일으킨다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; y = y + <span class="number">1</span></span><br><span class="line">ERROR: <span class="built_in">UndefVarError</span>: y not defined</span><br></pre></td></tr></table></figure>
<p>변수를 업데이트하기 전에, 간단하게 값을 할당하여 초기화를 해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; y = <span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">julia&gt; y = y + <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>1을 추가하여 변수를 업데이트 하는 것을 증가(increment)라고 하며, 1을 빼는 것을 감소(decrement)라고 한다.</p>
<h3 id="while문"><a href="#while문" class="headerlink" title="while문"></a><code>while</code>문</h3><p>컴퓨터는 종종 반복적인 일들을 자동으로 사용한다. 오류 없이 동일한 일을 반복하는 것은 컴퓨터가 가장 잘하는 일이며, 사람들이 가장 못하는 일이다.</p>
<p>우리는 이미 재귀를 사용하여 반복하는 <code>countdown()</code>, <code>printn()</code>를 보았다. 반복문은 많이 사용되기 때문에 줄리아는 반복문을 더 쉽게 만들 수 있도록 설계되었다. 그 중 하나인 <code>for</code>문은 우리가 <a href="https://hyeonji-ryu.github.io/2020/03/02/chapter-4/">간단한 반복 파트</a>에서 봤기 때문에 <code>while</code>문 먼저 볼 것이다. 아래 코드는 <code>while</code>문을 사용하여 작성한 <code>countdown()</code>이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> countdown(n)</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span></span><br><span class="line">        print(n, <span class="string">" "</span>)</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    println(<span class="string">"Blastoff!"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>while</code>문에 대해서 본 적이 없을지라도 위의 코드를 대부분 이해할 수 있을 것이다. <code>n</code>이 0보다 크다면, <code>n</code>을 보여주고 <code>n</code>에서 1을 뺀다. <code>n</code>이 0이 될 때까지 반복하다가 0이 되면, “Blastoff!”를 반환한다.</p>
<p>더 형식적으로, <code>while</code>문의 실행 흐름을 정리해보자.</p>
<ul>
<li><code>while</code>문의 조건이 참인지 거짓인지 판별하라</li>
<li>조건이 <code>true</code>인 경우 본문을 실행한 후, 다시 1단계로 돌아가라</li>
<li>조건이 <code>false</code>인 경우 <code>while</code>문을 종료하고 다음 명령문을 실행하라</li>
</ul>
<p>위와 같이 명령문을 실행한 후 다시 앞으로 올라가는 실행 흐름의 종류를 루프(loop)라고 한다.</p>
<p>루프의 본문은 조건이 결국 <code>false</code>가 되어 루프가 종료되도록 하나 이상의 변수 값을 변경해야 한다. 그러허지 않으면 루프가 영원히 반복되며, 이런 현상을 무한 루프라고 한다.</p>
<p><code>countdown()</code>의 경우에서는 루프 본문에서 <code>n</code>을 변경함으로써 <code>n</code>이 0이나 음수가 되면 루프가 종료되게 설정하였다. 이는 유한한 루프임이 확실하다.</p>
<p>이제는 다른 루프도 살펴보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> seq(n)</span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span></span><br><span class="line">        println(n)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>        <span class="comment"># n is even</span></span><br><span class="line">            n = n / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>                 <span class="comment"># n is odd</span></span><br><span class="line">            n = n*<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위 루프의 조건은 <code>n!= 1</code>이다. 따라서 이 루프는 <code>n</code>이 1이 되어 <code>false</code>가 될 때까지 반복될 것이다.</p>
<p>루프가 매번 작동할 때, 프로그램은 <code>n</code>의 값을 도출한 후 해당 <code>n</code>이 짝수인지 홀수인지 확인한다. 만약에 <code>n</code>이 짝수라면 2로 나눠지며, 홀수라면 <code>n</code>은 <code>n*3 + 1</code> 값으로 대체된다. 예를 들어 <code>seq()</code>에 인수로 3을 준다면, 결괏값으로 3,10,5,16,8,4,2,1을 도출할 것이다.</p>
<p><code>n</code>은 증가하거나 감소하기 때문에 <code>n</code>이 1이 되어 프로그램이 종료된다는 명백한 증거는 없다. 다만 위의 예시와 같이 <code>n</code>의 특정 값에 대해서는 종료를 증명할 수 있다. 예를 들어 시작 값이 2의 거듭제곱인 경우 <code>n</code>은 루프를 통과할 때마다 짝수가 되며, 결국 1이 되어 종료될 수 있다.</p>
<p>여기서 어려운 질문은 과연 프로그램은 <code>n</code>이 모든 양수 값일 때 종료되는가이다. 지금가지 누구도 저 문제를 증명하거나 반증하지 못했다.</p>
<h3 id="break문"><a href="#break문" class="headerlink" title="break문"></a><code>break</code>문</h3><p>때때로 함수를 작성하다보면 루프를 끝내는 지점을 처음에 정하지 못할 수도 있다. 그런 경우에는 <code>break</code>문을 사용하여 루프를 빠져나올 수 있다.</p>
<p>예를 들어, 만약에 사용자가 <code>done</code>이라고 작성할 때까지 사용자로부터 입력을 받고 싶다고 가정하자. 그렇다면 아래와 같이 코드를 작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    print(<span class="string">"&gt; "</span>)</span><br><span class="line">    line = readline()</span><br><span class="line">    <span class="keyword">if</span> line == <span class="string">"done"</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    println(line)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">println(<span class="string">"Done!"</span>)</span><br></pre></td></tr></table></figure>
<p>해당 루프의 조건은 항상 <code>true</code>이기 때문에, 루프는 <code>break</code>문에 도달할 때까지 계속 반복된다.</p>
<p>매번 사용자에게 “&gt; “가 표시되며, 사용자가 <code>done</code>이라고 입력하는 즉시 <code>break</code>문이 루프를 종료한다. 만약 <code>done</code>을 입력하지 않으면, 사용자가 입력한 내용을 반영하고 다시 루프의 위로 올라간다.</p>
<p>실행한 결과는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">&gt; not done</span><br><span class="line">not done</span><br><span class="line">&gt; done</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>
<p>이렇게 루프를 작성하는 방법은 루프의 어느 곳에서든 조건을 확인할 수 있고, 멈춰야 하는 지점도 정확히 설정할 수 있기 때문에 일반적으로 사용된다.</p>
<h3 id="continue문"><a href="#continue문" class="headerlink" title="continue문"></a><code>continue</code>문</h3><p><code>break</code>문이 루프를 빠져나가게 한다면, <code>continue</code>문은 명령문들 중간에서 루프의 시작점으로 올려준다. 예를 통해 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    print(i, <span class="string">" "</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위 코드 실행의 결과는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>코드를 살펴보면, <code>i</code>가 3으로 나눠지면 <code>continue</code>문을 만나서 루프의 처음으로 돌아가며, <code>i</code>가 3으로 나눠지지 않으면 그대로 <code>print()</code>로 넘어간다. 따라서 결과에서 3으로 나눠지는 수들은 다 제외되고 출력된 것이다.</p>
<h3 id="제곱근-Square-Roots"><a href="#제곱근-Square-Roots" class="headerlink" title="제곱근 (Square Roots)"></a>제곱근 (Square Roots)</h3><p>루프는 반복하여 수치 결과를 개선하는 프로그램에도 자주 사용된다.</p>
<p> 예로 제곱근을 계산하는 방법 중 하나인 뉴턴의 방법을 보자. 만약 <code>a</code>라는 수의 제곱근을 알고 싶다면, 아래의 공식을 반복하여 값을 찾을 수 있다.</p>
<script type="math/tex; mode=display">
\begin{equation}
y= \frac{1}{2}\left(x+\frac{a}{x}\right)
\end{equation}</script><p>임의로 <code>a</code>에 4을 할당하고, <code>x</code>에 3을 할당한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; a = <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">julia&gt; x = <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">julia&gt; y = (x + a/x) / <span class="number">2</span></span><br><span class="line"><span class="number">2.1666666666666665</span></span><br></pre></td></tr></table></figure>
<p>위 결과는 4의 제곱근인 2와 가깝다. 만약에 위 과정을 반복한다면, 2와 더 가까운 결과를 얻을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x = y</span><br><span class="line"><span class="number">2.1666666666666665</span></span><br><span class="line">julia&gt; y = (x + a/x) / <span class="number">2</span></span><br><span class="line"><span class="number">2.0064102564102564</span></span><br></pre></td></tr></table></figure>
<p>몇 번의 업데이트 이후, 거의 2와 같은 결과를 얻었다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x = y</span><br><span class="line"><span class="number">2.0064102564102564</span></span><br><span class="line">julia&gt; y = (x + a/x) / <span class="number">2</span></span><br><span class="line"><span class="number">2.0000102400262145</span></span><br><span class="line">julia&gt; x = y</span><br><span class="line"><span class="number">2.0000102400262145</span></span><br><span class="line">julia&gt; y = (x + a/x) / <span class="number">2</span></span><br><span class="line"><span class="number">2.0000000000262146</span></span><br></pre></td></tr></table></figure>
<p>일반적으로 정답에 도달하는데 걸리는 반복 수를 미리 예측할 수는 없지만, 일정 구간이 지나면 값이 도달하여 변하지 않는 것을 확인할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; x = y</span><br><span class="line"><span class="number">2.0000000000262146</span></span><br><span class="line">julia&gt; y = (x + a/x) / <span class="number">2</span></span><br><span class="line"><span class="number">2.0</span></span><br><span class="line">julia&gt; x = y</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line">julia&gt; y = (x + a/x) / <span class="number">2</span></span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p><code>y == x</code>에 도달했을 때는 반복문을 멈출 수 있다. 위의 과정을 <code>while</code>문으로 작성하면 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    println(x)</span><br><span class="line">    y = (x + a/x) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> y == x</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x = y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>대부분의 값은 정상적으로 작동하지만 <script type="math/tex">\sqrt{2}</script> 와 같은 수들은 <code>Float64</code>로 표현되지 않기 때문에 피하는게 좋다.</p>
<p><code>y</code>와 <code>x</code>가 정확하게 동일한지 확인하기 위해서는 내장 함수 <code>abs()</code>를 사용하여 이들의 차이를 절대 값으로 계산하는 것이 더 안전하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> abs(y-x) &lt; ε</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>여기서 <code>ε</code>(<code>\varepsilon TAB</code>)은 <code>0.0000001</code>과 같이 얼마나 가까운지 결정한다.</p>
<h3 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h3><p>뉴턴의 방법은 알고리즘 예시 중 하나이다. 알고리즘(Algorithms)은 제곱근 계산과 같이 문제들을 해결하는 기계적인 프로세스이다.</p>
<p>알고리즘이 무엇인지 이해하기 위해서는 알고리즘이 아닌 것들을 먼저 보는 것이 더 효과적일 수 있다. 예로 한 자리 숫자를 곱하는 법을 배울 때, 단순히 곱셈표를 외웠을 것이다. 이런 종류의 지식은 알고리즘이라고 할 수 없다.</p>
<p>그러나 게으른 사람이라면 몇 가지의 요령을 획득했을 것이다. 예를 들어 n과 9의 곱을 찾으려면 n−1을 첫 번째 숫자로, 10−n을 두 번째 숫자로 사용하여 답을 만들 수 있다. 이 식은 한자리 숫자와 9를 곱하는 일반적인 해결방안이다. 이것이 알고리즘이다.</p>
<p>알고리즘의 특징 중 하나는 이를 수행할 지능이 필요하지 않다는 점이다. 알고리즘들은 간단한 규칙에 따라서 진행하는 기계적인 프로세스이다.</p>
<p>알고리즘 실행은 지루하지만 알고리즘 설계는 흥미롭고 도전적이다. 또한 알고리즘 설계는 컴퓨터 과학의 핵심이다.</p>
<p>사람들이 자연스럽게 하는 것들 중 일부는 알고리즘으로 구현하기가 어렵다. 예로 자연어를 이해하는 것 등이다. 우리는 모두 자연어를 이해하고 있지만, 알고리즘적으로 어떻게 이해하는지 설명하는 것은 매우 어렵다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>더 큰 프로그램을 작성하기 시작하면 디버깅에 많은 시간을 투자하게 된다. 코드가 많을수록 오류가 발생할 확률도 올라가며 버그가 숨어있을 수 있는 공간도 많아진다.</p>
<p>디버깅 시간을 줄일 수 있는 한 가지 방법은 이분법 디버깅이다.<br>이분법 디버깅은 프로그램 코드를 중간 단위로 분해하여 확인하면서 문제점을 빠르게 찾는 방법이다. 예를 들어 프로그램 코드가 100줄이라면, 50줄 쯤에서 나눈 다음 그 근처를 확인하는 것이다. 확인하는 방법은 <code>print</code>문을 넣어 코드가 잘 작동하는지 보는 것이다. 이때 잘 작동한다면 프로그램 후반부에 문제가 있는 것이고, 아니라면 전반부에 문제가 있는 것이다. 이 방식으로 검사하면 100줄을 전부 다 볼 필요 없다.</p>
<p>하지만 실제 상황에서는 프로그램 중간이 무엇인지 명확하지 않을 수 있다. 코드 줄 개수에 맞춰 반으로 나누는 것은 합리적이지 않다. 따라서 프로그램에 오류가 있을 수 있는 장소와 코드를 먼저 점검한 후, 개발자가 생각하는 합리적인 중간점을 찾는 것이 좋다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>5. 결과 있는 함수</title>
    <url>/2020/03/03/Think-Julia-Chapter-6/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap06" target="_blank" rel="noopener">Fruitful Functions</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="결과-있는-함수-Fruitful-Functions"><a href="#결과-있는-함수-Fruitful-Functions" class="headerlink" title="결과 있는 함수 (Fruitful Functions)"></a>결과 있는 함수 (Fruitful Functions)</h2><p>줄리아가 제공하는 많은 함수들은 반환 값을 생성한다. 하지만 우리가 사용했던 <code>Turtle()</code>과 같은 결과 없는 함수(void function)는 명령을 수행하기만 하고 반환 값을 제공하지는 않는다. 이번 장에서는 결과 있는 함수를 작성하는 법을 알아볼 것이다.</p>
<h3 id="반환-값"><a href="#반환-값" class="headerlink" title="반환 값"></a>반환 값</h3><p>함수를 호출하면 일반적으로 변수에 할당하거나 표현식의 일부로 사용하는 반환 값이 생성된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="literal">e</span> = exp(<span class="number">1.0</span>)</span><br><span class="line">height = radius * sin(radians)</span><br></pre></td></tr></table></figure>
<p>결과 없는 함수는 반환 값을 가지고 있지 않다. 정확하게는 반환 값으로 <code>nothing</code>을 가지고 있다. 결과 있는 함수의 첫 번째 예시로 원의 넓이를 반환하는 <code>area()</code>를 살펴볼 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> area(radius)</span><br><span class="line">    a = <span class="literal">π</span> * radius^<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 <code>return</code>문을 사용하여 값을 보여준다. <code>return</code>문은 함수의 결괏값을 다음의 반환 값으로 사용하게 만들어주는 명령문이다. 결과 있는 함수는 <code>return</code>문을 내장하고 있기 때문에 쓸 필요가 없다. 따라서 수정된 코드는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> area(radius)</span><br><span class="line">    <span class="literal">π</span> * radius^<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>함수 본문의 마지막에 위치해 있는 표현식의 결과가 값으로 반환된다.<br>반면에 함수 내부에서 정의되는 임시 변수 <code>a</code>의 경우는 <code>return</code>문을 사용해야 디버깅하기 쉽다.<br>때때로 조건문의 조건마다 <code>return</code>문을 가지는 것은 유용하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> absvalue(x)</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이런 <code>return</code>문들은 각각의 대체 조건문에 들어가 있으며, 조건에 따라 작동된다.<br><code>return</code>문이 실행되면 뒤의 명령문들은 실행되지 않고 종료되는데, 이때 뒤에 있던 명령문들을 데드 코드(dead code)이라고 한다.</p>
<p>결과 있는 함수에서는 프로그램의 모든 경로가  <code>return</code>문으로 끝나게 작성하는 것이 좋다. 아래 예시를 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> absvalue(x)</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 함수는 <code>x</code>가 0이 되면 어떤 조건도 참이 아니고 반환할 <code>return</code>문도 없기 때문에 올바른 함수가 아니다. 만약 <code>x</code>가 0인채로 함수가 진행된다면 반환 값으로 <code>nothing</code>을 준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; show(absvalue(<span class="number">0</span>))</span><br><span class="line"><span class="literal">nothing</span></span><br></pre></td></tr></table></figure>
<p><strong>Tip</strong><br>줄리아는 절대값을 반환해주는 <code>abs()</code>를 내장하고 있다.</p>
<h3 id="점진적인-개발-Incremental-Development"><a href="#점진적인-개발-Incremental-Development" class="headerlink" title="점진적인 개발 (Incremental Development)"></a>점진적인 개발 (Incremental Development)</h3><p>크고 복잡한 함수들을 작성할수록 디버깅에 많은 시간을 쏟아야 할 것이다.<br>복잡한 프로그램들을 점점 향상시키기 위해서, 점진적인 개발이라는 과정을 배우는 것은 중요하다.<br>점진적인 개발의 목표는 작은 단위의 코드들을 계속 테스트해야하고 수정해야하는 디버깅에 소요되는 시간을 줄이는 것이다.<br>예로 두 점인 (x1,y1)와 (x2,y2)의 거리를 구하려고 한다. 피타고라스 정리에 따르면 수학식은 다음과 같다.</p>
<script type="math/tex; mode=display">\begin{equation} \label{eq1}
d= \sqrt{(x2-x1)^2+(y2-y1)^2}
\end{equation}</script><p>위의 수학식을 줄리아에서 구현하기 위해서는 어떻게 해야할까? 첫 번째로는 무엇을 인수로 제공하며, 얻으려는 반환 값은 무엇인지 정하는 것이다.<br>위의 사례에서는 두 점인 (x1,y1)와 (x2,y2)을 인수로 제공하면 된다. 반환 값의 경우는 소수로 표현된 거리를 얻을 것이다.<br>인수와 반환 값을 결정하면 바로 아래와 같은 코드를 완성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> distance(x₁, y₁, x₂, y₂)</span><br><span class="line">    <span class="number">0.0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 거리를 계산하지는 않으며, 본문에 따라 항상 0을 반환한다. 그러나 본문에 다른 명령문을 추가하기 전에 코드가 작동하는지 확인할 수 있다.<br>작동을 확인하기 위해 아래의 코드를 입력해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">distance(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 두 점은 수평 거리가 3이 되고 수직 거리가 4가 되도록 선택하였다. 그 결과 두 점의 거리 값은 5이며, 반환 값도 5가 되어야 한다. 이와 같이 코드를 테스트할 때는 정답을 알고 있는 상태에서 해야 올바르게 작동하고 있는지 확인할 수 있다.</p>
<p>위의 테스트를 통해서 해당 함수가 문법적으로는 문제가 없다고 확인하였다. 그러면 이제부터는 본문에 명령문들을 추가해보자. 다음 단계는 <code>x2−x1</code> 과 <code>y2−y1</code> 을 설정하는 것이다. 함수 내부에 임시 변수로서 두 식의 값을 저장하도록 설정해보자. 그 다음 <code>@show</code>를 사용하여 임시 변수가 올바르게 생성되는지 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> distance(x₁, y₁, x₂, y₂)</span><br><span class="line">    dx = x₂ - x₁</span><br><span class="line">    dy = y₂ - y₁</span><br><span class="line">    <span class="meta">@show</span> dx dy</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 함수가 제대로 작동했다면, <code>dx = 3</code> 과 <code>dy = 4</code> 가 보였을 것이다. 만약 그렇다면 우리는 함수가 올바른 인수를 받아 제대로 작동하고 있다고 안심할 수 있다.</p>
<p>다음 명령문으로 <code>dx</code> 와 <code>dy</code> 을 제곱하여 더하는 계산을 추가한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> distance(x₁, y₁, x₂, y₂)</span><br><span class="line">    dx = x₂ - x₁</span><br><span class="line">    dy = y₂ - y₁</span><br><span class="line">    d² = dx^<span class="number">2</span> + dy^<span class="number">2</span></span><br><span class="line">    <span class="meta">@show</span> d²</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>다시 위의 함수를 작동했을 때에는 <code>d²</code> 값이 25로 나와야 한다. 만약 올바르게 작동한다면 마지막으로 제곱근을 계산해주는 <code>sqrt()</code>를 추가해준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> distance(x₁, y₁, x₂, y₂)</span><br><span class="line">    dx = x₂ - x₁</span><br><span class="line">    dy = y₂ - y₁</span><br><span class="line">    d² = dx^<span class="number">2</span> + dy^<span class="number">2</span></span><br><span class="line">    sqrt(d²)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>코드가 제대로 작동했다면, 우리는 위의 수학식을 코드로 올바르게 구현한 것이다.</p>
<p>최종적으로 사용한 위의 함수는 반환 값을 가지고 있지만 결과를 출력하지는 않는다. 따라서 반환 값이 올바른지 체크하기 위해서는 <code>println()</code>과 같은 함수로 직접 츌력해서 확인해야 한다. 이런 작업을 스캐폴딩(scaffolding)이라고 한다. 이런 함수들은 디버깅을 할 때 도움이 되지만, 나중에 최종 프로그램을 구현할 때는 제거해야 한다.</p>
<p>초보자가 함수를 작성할 때는 명령문을 한 줄 또는 두 줄만을 추가하여 올바르게 작동하는지 확인해야 한다. 그 과정이 익숙해지면 더 큰 덩어리 단위로 명령문을 작성하고 디버깅할 수 있다.</p>
<p>요약하자면 함수를 개발하는 방법은 다음과 같다.</p>
<ul>
<li>프로그램을 작동하여 확인하면서 작은 부분들을 변경하자. 언제라도 오류가 발생하면 어느 부분에서 문제가 생긴 것인지 알고 있어야 한다.</li>
<li>함수 내부에 임시 변수를 사용하여 값들을 저장하면서 값이 올바른지 확인하자.</li>
<li>프로그램이 작동하면 스캐폴딩을 제거하고, 명령문들을 복합 표현식으로 사용하는 등 코드를 간단하게 수정하자.</li>
</ul>
<h3 id="컴포지션-composition"><a href="#컴포지션-composition" class="headerlink" title="컴포지션 (composition)"></a>컴포지션 (composition)</h3><p>함수를 작성할 때, 필요하다면 미리 작성한 함수를 가져와 사용할 수 있다. 예를 들어 원의 중심과 둘레의 점을 두 점으로 하여 원의 면적을 계산하는 함수를 살펴 보자.</p>
<p>중심점을 변수 <code>xc</code>와 <code>yc</code>로 표현하고, 둘레점을 <code>xp</code>와 <code>yp</code>로 표현한다. 그 이후 첫 번째 단계로 두 지점 사이의 거리인 원의 반경을 찾기로 한다. 우리는 윗 장에서 두 점의 거리를 구하는 <code>distance()</code>를 작성했기 때문에 이를 이용할 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">radius = distance(xc, yc, xp, yp)</span><br></pre></td></tr></table></figure>
<p>다음 단계로는 우리가 만들었던 <code>area()</code>를 사용하여 원의 면적을 구한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">result = area(radius)</span><br></pre></td></tr></table></figure>
<p>마지막으로 위의 변수들을 하나의 함수로 캡슐화해준다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> circlearea(xc, yc, xp, yp)</span><br><span class="line">    radius = distance(xc, yc, xp, yp)</span><br><span class="line">    result = area(radius)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>임시 변수인 <code>radius</code>와 <code>result</code>는 디버깅을 할 때 유용하지만, 굳이 임시 변수를 사용하지 않고 인수 자리에 함수를 바로 입력하여 더 간결하게 표현할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> circlearea(xc, yc, xp, yp)</span><br><span class="line">    area(distance(xc, yc, xp, yp))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="불-함수-Boolean-Functions"><a href="#불-함수-Boolean-Functions" class="headerlink" title="불 함수 (Boolean Functions)"></a>불 함수 (Boolean Functions)</h3><p>함수는 불(true or false)를 반환할 수 있으며, 이는 종종 복잡한 테스트를 함수 내부에 숨기는데 유용하다. 예는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isdivisible(x, y)</span><br><span class="line">    <span class="keyword">if</span> x % y == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이것은 yes/no 질문이라고 불리는 전형적인 불 함수이다. <code>isdivisible()</code>은 x값을 y값으로 나눈 나머지 값에 따라 <code>true</code> 또는 <code>false</code>를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; isdivisible(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">julia&gt; isdivisible(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><code>==</code> 연산자는 자동으로 불 표현식의 결괏값을 반환하므로 함수를 더 간결하게 작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> isdivisible(x, y)</span><br><span class="line">    x % y == <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>불 함수는 종종 조건문에 사용된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> isdivisible(x, y)</span><br><span class="line">    println(<span class="string">"x is divisible by y"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>또는 다음과 같이 작성할 수도 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> isdivisible(x, y) == <span class="literal">true</span></span><br><span class="line">    println(<span class="string">"x is divisible by y"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>하지만 위의 코드에서 <code>true</code>는 불필요하다.</p>
<h3 id="재귀-정의-More-Recursion"><a href="#재귀-정의-More-Recursion" class="headerlink" title="재귀 정의 (More Recursion)"></a>재귀 정의 (More Recursion)</h3><p>우리는 고작 줄리아의 작은 서브셋(subset)들을 배웠지만, 사실 이 서브셋들은 완벽한 프로그래밍 언어이다. 지금까지 습득한 언어로 대부분의 수학 계산식들을 표현할 수 있다. 즉, 프로그램을 작성하는데 어려움이 없다는 것이다.</p>
<p>프로그래밍 언어가 수학 계산식을 표현할 수 있다는 사실은 수학자 앨런 튜링(Alan Turing)에 의해서 증명되었으며, 해당 이론을 튜링 이론이라고 한다. 만약 튜링 이론에 관심이 있다면 Michael Sipser의 저서인 Introduction to the Theory of Computation을 추천한다.</p>
<p>지금부터는 우리가 배운 도구들을 사용하여 만들어진 몇 가지 재귀 함수를 살펴볼 것이다.<br>재귀 정의는 어떤 단어를 설명하는데 있어 그 단어를 선택한다는 점에서 순환 정의와 유사하다.</p>
<p><strong>vorpal</strong><br>An adjective used to describe something that is vorpal.</p>
<p>위의 예시를 보면 vorpal이란 단어를 정의하는데 vorpal이란 단어가 쓰이는 것을 볼 수 있다. 재귀함수도 이와 유사한 구조를 가지고 있다. 재귀 함수의 예로 계승 함수(factorial function)을 살펴보자.</p>
<script type="math/tex; mode=display">
n! =
 \begin{cases}
1 & \text{if n=0 $$}\\
n(n-1)! & \text{if n>0 $$}\\
\end{cases}</script><p>위의 정의는 <code>n</code>이 0이면 1을 반환하고, 만약 <code>n</code>이 0이상이라면 <code>n</code>과 <code>(n-1)!</code>을 곱하라고 설명한다.</p>
<p>예를 들면 3!은 3과 2!를 곱하고, 2!는 2와 1!을 곱하며, 1!는 1과 0을 곱한다.<br>따라서 3!는 3<em>2</em>1<em>1</em>0이기에 6인 것이다.</p>
<p>재귀 정의를 이용하여 위의 수학식을 함수로 작성할 수 있다. 첫 번째 단계는 인수가 무엇인지 결정하는 것이다. 이 경우에서는 정수가 인수로 사용된다는 것이 명확하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> fact(n) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>만약 인수가 0이라면, 1을 반환해야 하므로 조건문을 사용한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> fact(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이 부분이 가장 흥미로운데, 만약 인수가 0이 아니라면 우리는 <code>n</code>과 <code>(n-1)!</code>를 곱하기 위해서 재귀 함수을 사용해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> fact(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        recurse = fact(n-<span class="number">1</span>)</span><br><span class="line">        result = n * recurse</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>n</code>에 3을 부여한 위 코드의 진행 과정은 다음과 같다.</p>
<ul>
<li><code>3</code>은 <code>0</code>이 아니기 때문에, <code>else</code>문으로 넘어가 <code>3</code>과 <code>2!</code>을 곱하려고 한다.</li>
<li><code>2</code>은 <code>0</code>이 아니기 때문에, <code>else</code>문으로 넘어가 <code>2</code>과 <code>1!</code>을 곱하려고 한다.</li>
<li><code>1</code>은 <code>0</code>이 아니기 때문에, <code>else</code>문으로 넘어가 <code>1</code>과 <code>0!</code>을 곱하려고 한다.</li>
<li><code>n</code>이 <code>0</code>이기 때문에, <code>0!</code>은 첫 번째 코드를 따라 1을 반환한다.</li>
<li><code>0!</code>가 <code>1</code>을 반환했기 때문에 <code>1</code>과 곱해져 <code>1!</code>을 반환한다.</li>
<li><code>1!</code>가 <code>1</code>을 반환했기 때문에 <code>2</code>과 곱해져 <code>2!</code>을 반환한다.</li>
<li><code>2!</code>가 <code>2</code>을 반환했기 때문에 <code>3</code>과 곱해져 <code>6</code>을 반환한다.</li>
</ul>
<p>결국 마지막으로 작동된 명령문의 결과값인 6이 반환 값으로 보여준다. 또한 로컬 변수인 <code>result</code>나 <code>recurse</code>도 함수가 작동을 멈추는 동시에 사라진다.</p>
<p><strong>Tip</strong><br>줄리아는 계승 함수(factorial function)를 제공한다.</p>
<h3 id="믿음의-도약-Leap-of-Faith"><a href="#믿음의-도약-Leap-of-Faith" class="headerlink" title="믿음의 도약 (Leap of Faith)"></a>믿음의 도약 (Leap of Faith)</h3><p>실행 흐름을 따르는 것은 프로그램을 읽는 하나의 방법이다. 그러나 때에 따라선 믿음의 도약이라고 부르는 방법도 사용할 수 있다. 믿음의 도약이란 함수가 어떻게 작동하는지를 파악하기 전에 함수를 호출하여 올바른 결괏값을 도출하는지 확인하여 그 함수가 잘 작동하고 있다고 믿는 것이다. 즉, 프로그램의 실행 흐름을 보는 것이 아니라 결괏값만을 보고 프로그램이 올바르게 작동하고 있는지 파악하는 것이다.</p>
<p>실제로 내장 함수를 사용할 때 우리는 이 방법을 많이 사용한다. 예를 들어 <code>cos()</code>나 <code>exp()</code>를 사용할 때, 해당 함수의 본문을 검사하지 않으며, 결괏값만 보고 믿음을 주는 것이다. 재귀 프로그램 또한 실행 흐름을 따르는 대신에 재귀 호출이 되었다고 가정하여 결괏값을 확인한다.</p>
<h3 id="연습해보기"><a href="#연습해보기" class="headerlink" title="연습해보기"></a>연습해보기</h3><p>가장 재귀적으로 정의된 가장 보편적인 수학 표현식 중 하나인 피보나치를 작성해보자. 피보나치에 대한 정의는 <a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">이 링크</a>를 확인하면 된다.</p>
<script type="math/tex; mode=display">
fib(n) =
 \begin{cases}
0 & \text{if n=0 $$}\\
1 & \text{if n=1 $$}\\
fib(n-1)+fib(n-2) & \text{if n>1 $$}\\
\end{cases}</script><p>위 식을 줄리아 코드로 표현하면 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> fib(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elseif</span> n == <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이 함수에서 실행 흐름대로 파악하려면 <code>n</code>이 아주 작은 경우에도 머리가 복잡하다. 그렇기 때문에 믿음의 도약에 따라 재귀 함수가 올바르게 작동한다고 가정한후 <code>n</code>에 3 정도를 넣어보면 빠르게 좋은 결과를 얻을 수 있다.</p>
<h3 id="데이터-타입-확인하기"><a href="#데이터-타입-확인하기" class="headerlink" title="데이터 타입 확인하기"></a>데이터 타입 확인하기</h3><p>민약에 <code>fact()</code>에 인수로 <code>1.5</code>를 넣으면 어떻게 될까?</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fact(<span class="number">1.5</span>)</span><br><span class="line">ERROR: <span class="built_in">StackOverflowError</span>:</span><br><span class="line">Stacktrace:</span><br><span class="line"> [<span class="number">1</span>] fact(::<span class="built_in">Float64</span>) at ./REPL[<span class="number">3</span>]:<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>무한 재귀로 작동된 에러 결과가 나왔다. 어떻게 그게 가능할까?<br><code>fact()</code>는 <code>n</code>이 <code>0</code>일때 함수 작동이 끝나는 재귀 정의를 가지고 있다. <code>1.5</code>는 <code>0</code>이 아니기 때문에 <code>else</code>문으로 실행되며 첫 번째 실행 이후 <code>n</code>값이 <code>0.5</code>가 된다. 그 다음 두 번째 실행에서는 <code>n</code>값이 <code>-0.5</code>가 된다. 결국 <code>n</code>값이 <code>0</code>이 되지 못하기 때문에 무한대로 재귀가 작동하는 결과가 초래된 것이다.</p>
<p>따라서 이 문제를 해결하기 위해서는 소수점 숫자도 인수로 받을 수 있게 <code>fact()</code>를 일반화하거나, 데이터 타입을 미리 확인하라는 명령문을 추가할 수 있다. 첫 번째 방법은 <strong>감마 함수</strong>라고 하며 이 책의 범위를 벗어나기 때문에, 우리는 두 번째 방법을 선택할 것이다.</p>
<p>내장 연산자인 <code>isa</code>를 이용하여 인수 유형을 확인할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> fact(n)</span><br><span class="line">    <span class="keyword">if</span> !(n <span class="keyword">isa</span> <span class="built_in">Int64</span>)</span><br><span class="line">        error(<span class="string">"Factorial is only defined for integers."</span>)</span><br><span class="line">    <span class="keyword">elseif</span> n &lt; <span class="number">0</span></span><br><span class="line">        error(<span class="string">"Factorial is not defined for negative integers."</span>)</span><br><span class="line">    <span class="keyword">elseif</span> n == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * fact(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>첫 번째 <code>if</code>문은 정수가 아닌 수들에 대한 에러 메시지를 도출하며, 두 번째 <code>elseif</code>문은 음수에 대한 에러 메시지를 도출한다. 에러 메시지가 출력될 경우 그 함수의 결과는 <code>nothing</code>을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fact(<span class="string">"fred"</span>)</span><br><span class="line">ERROR: Factorial is only defined <span class="keyword">for</span> integers.</span><br><span class="line">julia&gt; fact(-<span class="number">2</span>)</span><br><span class="line">ERROR: Factorial is not defined <span class="keyword">for</span> negative integers.</span><br></pre></td></tr></table></figure>
<p>두 검사를 모두 통과하면 <code>n</code>이 양수이거나 0임이 증명되기 때문에, 바로 재귀 함수로 넘어갈 수 있다.</p>
<p>이런 프로그램 구조는 가이드라인을 보여준다. 처음 두 조건이 가이드 역할을 하여 오류를 일으킬 수 있는 값에서 구출하고 오류를 막아준다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>큰 프로그램들을 작은 함수들로 분해하는 것은 자연스러운 디버깅 포인트들을 만들어준다. 만약 함수가 작동하고 있지 않다면, 아래의 세 가지 가능성을 고려야봐야 한다.</p>
<ul>
<li>함수의 인수가 잘못 배정된 경우 (전제조건 오류)</li>
<li>함수 자체에 오류가 있는 경우 (사후조건 오류)</li>
<li>반환 값이나 사용되는 방식에 문제가 있는 경우 (함수의 연결부분)</li>
</ul>
<p>첫 번째의 가능성을 배제하기 위해, <code>println()</code>을 추가하고 나오는 결괏값을 확인하여 데이터 타입을 정확히 확인하라. 아니면 해당 함수의 전제 조건을 다시 정확히 확인하라.<br>인수가 양호하다면 각 <code>return</code>문 앞에 <code>println()</code>을 추가하고 반환 값을 표시해서 가능하면 결과값을 확인하라. 옳은 결과인지 확인하기 쉬운 값을 인수로 주는 것이 좋다.<br>함수가 작동하는 것 같으면 함수 호출을 보고 반환 값이 올바르게 사용되는지 확인하라. 함수의 시작과 끝에 <code>println()</code>을 추가하면 실행 흐름을 더 잘 볼 수 있다.<br>예로 아래의 함수는 <code>println()</code>문이 포함된 <code>fact()</code> 코드 이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> fact(n)</span><br><span class="line">    space = <span class="string">" "</span> ^ (<span class="number">4</span> * n)</span><br><span class="line">    println(space, <span class="string">"factorial "</span>, n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line">        println(space, <span class="string">"returning 1"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        recurse = fact(n-<span class="number">1</span>)</span><br><span class="line">        result = n * recurse</span><br><span class="line">        println(space, <span class="string">"returning "</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>space</code>는 출력의 들여 쓰기를 제어하는 공백 문자열이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; fact(<span class="number">4</span>)</span><br><span class="line">                factorial <span class="number">4</span></span><br><span class="line">            factorial <span class="number">3</span></span><br><span class="line">        factorial <span class="number">2</span></span><br><span class="line">    factorial <span class="number">1</span></span><br><span class="line">factorial <span class="number">0</span></span><br><span class="line">returning <span class="number">1</span></span><br><span class="line">    returning <span class="number">1</span></span><br><span class="line">        returning <span class="number">2</span></span><br><span class="line">            returning <span class="number">6</span></span><br><span class="line">                returning <span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>만약에 실행 흐름이 헷갈리면, 위와 같은 출력들이 도움이 될 것이다. 효과적인 스캐폴딩을 개발하는 것은 조금 시간이 걸리겠지만, 작은 스캐폴딩으로도 많은 디버깅 요소들을 찾을 수 있다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 조건문과 재귀</title>
    <url>/2020/03/03/Think-Julia-Chapter-5/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap05" target="_blank" rel="noopener">Conditionals and Recursion</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="조건문과-재귀"><a href="#조건문과-재귀" class="headerlink" title="조건문과 재귀"></a>조건문과 재귀</h2><p>이번 장의 가장 핵심적인 주제는 <code>if</code>문이지만, 그 전에 간단한 연산자 두 개를 먼저 소개하려고 한다.</p>
<h3 id="버림-나눗셈-floor-division-과-나머지-Modulus"><a href="#버림-나눗셈-floor-division-과-나머지-Modulus" class="headerlink" title="버림 나눗셈(floor division)과 나머지(Modulus)"></a>버림 나눗셈(floor division)과 나머지(Modulus)</h3><p>버림 나눗셈(floor division)이란 두 수를 나눈 후 나머지를 버리는 계산을 의미하며, 연산자 기호는 <code>÷</code>이다.<br>예를 들어, 105분동안 상영하는 영화가 있다고 해보자. 우리는 영화가 대략 몇 시간이 걸리는지 알기 위해 60분으로 나누지만, 일반적인 나눗셈은 소수점까지 모두 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; minutes = <span class="number">105</span></span><br><span class="line"><span class="number">105</span></span><br><span class="line">julia&gt; minutes / <span class="number">60</span></span><br><span class="line"><span class="number">1.75</span></span><br></pre></td></tr></table></figure>
<p>그러나 우리는 일반적으로 시간을 소수점으로 표현하지는 않는다. 버림 나눗셈은 나머지인 소수점을 모두 버리고 정수만 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; hours = minutes ÷ <span class="number">60</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>위의 1시간을 제외하고 남은 시간이 몇 분인지 알고 싶다면 105분에서 1시간을 빼면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; remainder = minutes - hours * <span class="number">60</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>
<p>이외에도 나눗셈에서 나머지만 반환해주는 나머지 연산자 <code>%</code>를 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; remainder = minutes % <span class="number">60</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>
<p><strong>Tip</strong><br>나머지 연산자는 생각보다 유용하다, 예로 한 숫자를 다른 숫자로 나눌 수 있는지 파악해야 할 때, 두 수의 나머지 연산 결과가 0인지로 확인할 수 있다.<br>또한 정수에서 가장 오른쪽의 숫자만 추출할 때도 사용가능하다. 이 경우, <code>%10</code>을 사용하면 된다.</p>
<h3 id="불-표현식"><a href="#불-표현식" class="headerlink" title="불 표현식"></a>불 표현식</h3><p>불 표현식(Boolean Expressions)은 <code>true</code> 또는 <code>false</code>를 나타내는 식이며, 연산자는 <code>==</code>이다. 불 표현식의 예시를 보면, 연산자는 <code>==</code>를 기분으로 양 옆의 두 피연산자들을 비교한 후 같으면 <code>true</code>를, 다르면 <code>false</code>를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="number">5</span> == <span class="number">5</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">julia&gt; <span class="number">5</span> == <span class="number">6</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><code>true</code>와 <code>false</code>은 문자열이 아니라 <code>Bool</code>이라는 데이터 타입에 속한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; typeof(<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">Bool</span></span><br><span class="line">julia&gt; typeof(<span class="literal">false</span>)</span><br><span class="line"><span class="built_in">Bool</span></span><br></pre></td></tr></table></figure>
<p>사용된 <code>==</code> 연산자는 관계 연산자들 중 하나이다. 다른 관계 연산자들은 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">x != y               <span class="comment"># x is not equal to y</span></span><br><span class="line">x ≠ y                <span class="comment"># (\ne TAB)</span></span><br><span class="line">x &gt; y                <span class="comment"># x is greater than y</span></span><br><span class="line">x &lt; y                <span class="comment"># x is less than y</span></span><br><span class="line">x &gt;= y               <span class="comment"># x is greater than or equal to y</span></span><br><span class="line">x ≥ y                <span class="comment"># (\ge TAB)</span></span><br><span class="line">x &lt;= y               <span class="comment"># x is less than or equal to y</span></span><br><span class="line">x ≤ y                <span class="comment"># (\le TAB)</span></span><br></pre></td></tr></table></figure>
<p><strong>주의</strong><br>줄리아 기호는 일반적인 수학 기호와는 조금 다르다. 줄리아에서 <code>=</code>는 대입 연산자이고, <code>==</code>는 관계 연산자이다. 두 기호는 비슷해 보이지만 완전히 다르다.</p>
<h3 id="논리-연산자"><a href="#논리-연산자" class="headerlink" title="논리 연산자"></a>논리 연산자</h3><p>논리 연산자는 and 연산자인 <code>&amp;&amp;</code>, or 연산자인 <code>||</code>, not 연산자인 <code>!</code> 총 세 가지가 있다.  논리 연산자들의 사용방법은 아래의 코드에서 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">x &gt; <span class="number">0</span> &amp;&amp; x &lt; <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 <code>&amp;&amp;</code> 연산자이다. 위의 예시는 x가 0보다 크고 10보다 작으면 이 문장은 <code>true</code>를 반환하는 것을 의미한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">n % <span class="number">2</span> == <span class="number">0</span> || n % <span class="number">3</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>다음 코드는 <code>||</code> 연산자이다. 위의 코드를 해석한다면, n값이 2나 3으로 나누었을 때 나머지가 0인 숫자면 해당 코드는 <code>true</code>를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">!(x &gt; y)</span><br></pre></td></tr></table></figure>
<p>마지막으로 <code>!</code> 연산자이며, 이는 불 표현식을 무효화한다. 따라서 위의 예시를 본다면 x가 y보다 작거나 같은 경우에 <code>true</code> 를 반환하고, x가 y보다 크다면 <code>false</code>를 반환한다.</p>
<h3 id="조건문-Conditional-실행"><a href="#조건문-Conditional-실행" class="headerlink" title="조건문(Conditional) 실행"></a>조건문(Conditional) 실행</h3><p>유용한 프로그램을 작성하려면 우리는 프로그램의 상태를 확인하고 그에 따라 알맞게 변경하는 기능이 필요하다. 조건문은 우리에게 이런 기능을 제공한다. 가장 간단한 형식은 <code>If</code>문이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span></span><br><span class="line">    println(<span class="string">"x is positive"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>If</code>문 뒤에 쓰여 있는 불 표현식을 조건이라고 한다. 해당 조건이 참이라면 밑의 명령문이 작동되지만, 조건이 참이 아니라면 아무 일도 일어나지 않는다.</p>
<p><code>If</code>문이 함수 정의와 동일한 구조를 가진 경우를 복합 구문(compound statements)이라고 한다. 여기서 함수 정의를 다시 상기해본다면 헤더로 시작하여 본문을 작성 한후 마지막에 키워드 <code>end</code> 끝나는 구조이다.</p>
<p>복합 구문에 들어가는 명령문의 수는 제한이 없으며, 명령문이 아예 없는 본문도 작성이 가능하다 (하지만 본문이 없으면 어떤 변화도 일어나지는 않는다).</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span></span><br><span class="line">    <span class="comment"># TODO: need to handle negative values!</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="대체-Alternative-실행"><a href="#대체-Alternative-실행" class="headerlink" title="대체(Alternative) 실행"></a>대체(Alternative) 실행</h3><p><code>If</code>문의 두 번째 형식은 대체 실행(Alternative Execution)이다. 이 구조에서는 두 가지의 조건이 있으며, 각각의 조건에 따라 실행되는 코드가 결정된다. 해당 예시는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">    println(<span class="string">"x is even"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    println(<span class="string">"x is odd"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 숫자인 x가 짝수인지 홀수인지 구분하여 알려주는 프로그램이다. x를 2로 나누어 나머지가 0이 된다면 짝수이고, 0이 아니라면 홀수이다. 이 간단한 원리를 사용하여 조건에 충족하면 <code>true</code>가 되어 첫 번째 본문을 실행하고, <code>false</code>라면 두 번째 본문을 실행한다.</p>
<h3 id="연결-조건문-Chained-Conditionals"><a href="#연결-조건문-Chained-Conditionals" class="headerlink" title="연결 조건문(Chained Conditionals)"></a>연결 조건문(Chained Conditionals)</h3><p>때로는 두 개 이상의 조건이 주어지는 경우도 있다. 이럴 때에는 조건을 연결하는 연결조건문 구조가 사용된다. 해당 구조의 코드는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; y</span><br><span class="line">    println(<span class="string">"x is less than y"</span>)</span><br><span class="line"><span class="keyword">elseif</span> x &gt; y</span><br><span class="line">    println(<span class="string">"x is greater than y"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    println(<span class="string">"x and y are equal"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위에 사용한 <code>elseif</code>문의 수는 제한이 없다. 또한 <code>else</code>문을 쓰려면 반드시 끝에 입력해야 하지만, 필요없다면 작성하지 않아도 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> choice == <span class="string">"a"</span></span><br><span class="line">    draw_a()</span><br><span class="line"><span class="keyword">elseif</span> choice == <span class="string">"b"</span></span><br><span class="line">    draw_b()</span><br><span class="line"><span class="keyword">elseif</span> choice == <span class="string">"c"</span></span><br><span class="line">    draw_c()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>각 조건들은 순서대로 작동한다. 예를 들어 첫 번째 조건이 거짓이면 다음 조건으로 넘어가며, 만약 참인 조건을 찾으면 해당 본문이 실행되며 <code>If</code>문은 종료된다.<br>그렇기 때문에 만약 2개 이상의 조건이 참인 경우에도 더 위에 작성되어 있는 조건만 실행된다.</p>
<h3 id="중첩-조건문-Nested-Conditionals"><a href="#중첩-조건문-Nested-Conditionals" class="headerlink" title="중첩 조건문(Nested Conditionals)"></a>중첩 조건문(Nested Conditionals)</h3><p>하나의 <code>If</code>문에도 다른 <code>If</code>문이 중첩될 수 있다. 이전 예제를 가져와서 확인하면 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x == y</span><br><span class="line">    println(<span class="string">"x and y are equal"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; y</span><br><span class="line">        println(<span class="string">"x is less than y"</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        println(<span class="string">"x is greater than y"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>겉에 있는 <code>If</code>문은 간단한 구조를 가지고 있다. 하지만 <code>else</code>문에 또 다시 <code>If</code>문을 작성함으로서 두 개의 조건문을 중첩시킨 것을 확인할 수 있다.</p>
<p>이럽 중첩 조건문은 들여쓰기를 통해서 연결지점들을 구분해두지만, 코드를 빠르게 이해하기는 어렵다. 그렇기에 코드를 작성할 때 중첩 조건문은 피하는 것이 좋다.</p>
<p>논리 연산자를 이용하여 중첩 조건문을 단순화할 수 있다. 아래 예시를 보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt; x</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">10</span></span><br><span class="line">        println(<span class="string">"x is a positive single-digit number."</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 조건문은 중첩 조건문으로서 두 개의 조건을 모두 충족해야만 실행된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt; x &amp;&amp; x &lt; <span class="number">10</span></span><br><span class="line">    println(<span class="string">"x is a positive single-digit number."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>하지만 <code>&amp;&amp;</code> 연산자를 사용하면 단일 조건문으로 해결할 수 있다.<br>또한 줄리아는 아래와 같이 더 간결한 구문도 제공한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt; x &lt; <span class="number">10</span></span><br><span class="line">    println(<span class="string">"x is a positive single-digit number."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="재귀-Recursion"><a href="#재귀-Recursion" class="headerlink" title="재귀(Recursion)"></a>재귀(Recursion)</h3><p>한 함수가 다른 함수를 호출하는 것은 충분히 가능한 일이다. 그렇다면 함수가 자기 자신을 호출하는 것도 가능할까?<br>위 질문에 대한 답은 가능하다는 것이다. 어떻게 가능한지 아래의 예시로 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> countdown(n)</span><br><span class="line">    <span class="keyword">if</span> n ≤ <span class="number">0</span></span><br><span class="line">        println(<span class="string">"Blastoff!"</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print(n, <span class="string">" "</span>)</span><br><span class="line">        countdown(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 함수는 <code>n</code>이 0이거나 음수인 경우 “Blastoff!”를 출력하며, 아닌 경우에는 <code>n</code>을 출역한 후 <code>n-1</code>을 인수로 갖는 <code>countdown()</code>를 호출한다.</p>
<p>위의 함수는 어떤 결과를 보여줄까?</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; countdown(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> Blastoff!</span><br></pre></td></tr></table></figure>
<p>위의 예시를 보면, 조건문 원리를 이해할 수 있다.</p>
<ul>
<li>3은 0보다 크기 때문에 <code>else</code>문으로 넘어가서 3을 출력한 후 자기 자신을 호출하여 2를 인수로 제공한다.</li>
<li>2 또한 0보다 크기 때문에 <code>else</code>문으로 넘어가고 위와 같은 과정을 반복한다.</li>
<li>1 또한 0보다 크기 때문에 위와 같다.</li>
<li>0은 <code>If</code>문 조건에 해당하기 때문에 해당 본문이 실행된다. (“Blastoff!”를 호출한다.)</li>
</ul>
<p>스스로를 호출하는 함수를 실행하는 과정을 재귀(Recursion)라고 한다.<br>다른 예로 문자열을 <code>n</code>번 출력하는 함수를 만들어보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printn(s, n)</span><br><span class="line">    <span class="keyword">if</span> n ≤ <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    println(s)</span><br><span class="line">    printn(s, n-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>해당 예시는 <code>n</code>이 <code>n &lt;= 0</code>이면 함수를 종료한다. 함수가 종료되면 그 결과가 사용자에게 반환되며, 나머지 명령문들은 실행되지 않는다.<br><code>n</code>이 양수라면 나머지 명령문들이 실행되며, 해당 명령문의 작동방식은 <code>countdown()</code>과 유사하다.</p>
<h3 id="무한-재귀-infinite-recursion"><a href="#무한-재귀-infinite-recursion" class="headerlink" title="무한 재귀(infinite recursion)"></a>무한 재귀(infinite recursion)</h3><p>도착점이 제공되지 않은 재귀는 함수 호출을 계속하며 종료되지 않는다. 이런 현상을 무한 재귀(infinite recursion)라고 한다. 실제로 무한 재귀는 일반적으로 잘 사용되지 않는다. 아래 코드는 무한재귀의 간단한 예시이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> recurse()</span><br><span class="line">    recurse()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>대부분의 프로그래밍 환경에서 무한 재귀가 있는 프로그램이 영원히 실행되지는 않는다. 줄리아는 최대 재귀 수준에 도달하면 오류 메시지를 보낸 후 실행을 중단한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; recurse()</span><br><span class="line">ERROR: <span class="built_in">StackOverflowError</span>:</span><br><span class="line">Stacktrace:</span><br><span class="line"> [<span class="number">1</span>] recurse() at ./REPL[<span class="number">1</span>]:<span class="number">2</span> (repeats <span class="number">80000</span> times)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 오류를 보면 해당 함수는 80000번을 반복했다. 대부분 무한 재귀는 함수를 잘못 사용해서 발생하기 때문에 해당 오류를 만난다면 함수의 사용법을 확인해야 한다.</p>
<h3 id="키보드-입력-Keyboard-Input"><a href="#키보드-입력-Keyboard-Input" class="headerlink" title="키보드 입력(Keyboard Input)"></a>키보드 입력(Keyboard Input)</h3><p>줄리아는 <code>readline()</code>이라는 내장 함수를 제공하여 프로그램을 중지하고 사용자가 무언가를 입력할 때까지 기다린다. 사용자가 내용을 입력하고 <code>RETURN</code> 또는 <code>ENTER</code>를 누르면 해당 변수에 값이 적용된다. 이후 <code>readline()</code>은 사용자가 문자열로 입력한 내용을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; text = readline()</span><br><span class="line">What are you waiting <span class="keyword">for</span>? <span class="comment"># 내용 입력 후 `RETURN` 또는 `ENTER`를 누르기</span></span><br><span class="line"><span class="string">"What are you waiting for?"</span></span><br></pre></td></tr></table></figure>
<p>세미 콜론(;)을 사용하면 같은 줄에 여러 문장을 넣을 수 있다. REPL에서는 마지막 명령문의 결괏값만을 호출한다.<br>또한 사용자가 정수를 입력할 것으로 예상되면, 반환 값을 정수로 변환하여 가져올 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; println(<span class="string">"What...is the airspeed velocity of an unladen swallow?"</span>); speed = readline()</span><br><span class="line">What...is the airspeed velocity of an unladen swallow?</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="string">"42"</span></span><br><span class="line">julia&gt; parse(<span class="built_in">Int64</span>, speed)</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>하지만 만약 사용자가 입력한 데이터 타입과 다른 형태로 변환하면, 오류가 발생한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; println(<span class="string">"What...is the airspeed velocity of an unladen swallow? "</span>); speed = readline()</span><br><span class="line">What...is the airspeed velocity of an unladen swallow?</span><br><span class="line">What <span class="keyword">do</span> you mean, an African or a European swallow?</span><br><span class="line"><span class="string">"What do you mean, an African or a European swallow?"</span></span><br><span class="line">julia&gt; parse(<span class="built_in">Int64</span>, speed)</span><br><span class="line">ERROR: <span class="built_in">ArgumentError</span>: invalid base <span class="number">10</span> digit <span class="string">'W'</span> <span class="keyword">in</span> <span class="string">"What do you mean, an African or a European swallow?"</span></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>나중에 위와 같은 종류의 오류들을 처리하는 방법을 살펴볼 것이다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>문법이나 런타임 오류가 발생하면, 오류 메시지는 과도하게 많은 정보들을 제공한다. 따라서 오류 메시지를 정확하게 파악하는 것도 중요하다. 가장 유용한 부분들은 다음과 같다.</p>
<ul>
<li>오류의 종류는 무엇인가?</li>
<li>어디서 발생한 오류인가?</li>
</ul>
<p>문법 오류는 찾기 쉽지만 몇 가지 문제가 있다. 일반적으로 오류 메시지들은 문제가 발견된 위치를 제공하지만, 실제 오류가 일어난 위치와 다를 수 있다.</p>
<p>런타임 오류도 마찬가지이다. 다음 예시로 확인해보자.<br>다음 예시는 신호 대 잡음비를 데시벨로 계산하는 공식을 구현한 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">signal_power = <span class="number">9</span></span><br><span class="line">noise_power = <span class="number">10</span></span><br><span class="line">ratio = signal_power ÷ noise_power</span><br><span class="line">decibels = <span class="number">10</span> * log10(ratio)</span><br><span class="line">print(decibels)</span><br></pre></td></tr></table></figure>
<p>위의 코드를 수행하면 결과는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">-<span class="literal">Inf</span></span><br></pre></td></tr></table></figure>
<p>해당 결과는 예상했던 것과 다르다.</p>
<p>오류를 찾기 위해서, 변수인 <code>ratio</code>의 값을 확인해보는 것이 좋을 것이다. 확인해보니 <code>ratio</code>는 0으로 밝혀졌다. 문제는 3번째 줄에서 버림 나눗셈을 하여 나머지들을 제거해버리는 데서 온 것으로 확인되었다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 사례 연구 - 인터페이스 디자인</title>
    <url>/2020/03/02/Think-Julia-Chapter-4/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap04" target="_blank" rel="noopener">Case Study: Interface Design</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="사례-연구-인터페이스-디자인"><a href="#사례-연구-인터페이스-디자인" class="headerlink" title="사례 연구: 인터페이스 디자인"></a>사례 연구: 인터페이스 디자인</h2><p>이번 장에서는 함수들을 설계하는 과정들을 볼 수 있는 사례 연구를 살펴볼 것이다.</p>
<p>이를 진행하기 위해서는 그림을 생성하는 거북이 그래픽(turtle graphics)을 사용해야 한다. 거북이 그래픽은 표준 라이브러리에 포함되어 있지 않기 때문에 해당 모듈을 줄리아 설정에 추가해야 한다.</p>
<h3 id="거북이"><a href="#거북이" class="headerlink" title="거북이"></a>거북이</h3><p>모듈(module)은 관련 함수들을 모아 놓은 파일이다. 줄리아는 표준 라이브러리에서 몇 가지 모듈을 제공하고 있으며, 다른 패키지들도 모듈로 추가할 수 있다.</p>
<p>패키지를 추가하는 방법은 다음과 같다. 먼저 REPL 창에 엔터 키를 눌러서 시작한다. 이후 REPL에서 <code>]</code>를 입력하면 패키지 설정 모드로 변환된다. 거북이 그래픽을 사용하기 위해서는 아래의 코드를 입력한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">(v1<span class="number">.0</span>) pkg&gt; add https://github.com/BenLauwens/ThinkJulia.jl</span><br></pre></td></tr></table></figure>
<p>모듈에 포함되어 있는 함수를 사용하려면, 먼저 <code>using</code>이라는 명령어를 사용하여 모듈을 가져와야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> ThinkJulia</span><br><span class="line">julia&gt; 🐢 = Turtle()</span><br><span class="line">Luxor.Turtle(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="literal">true</span>, <span class="number">0.0</span>, (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>))</span><br></pre></td></tr></table></figure>
<p><code>ThinkJulia</code> 모듈은 <code>Luxor.Turtle</code>이라는 객체를 생성하는 <code>Turtle</code> 함수를 제공하며, 해당 객체는 <code>🐢</code>라는 변수에 할당된다.</p>
<p>거북이를 만든 후에는 함수를 호출하여 거북이를 이동할 수 있다. 예를 들어 거북이를 앞으로 움직이려면 다음과 같은 코드를 입력하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>@svg</code> 키워드는 SVG그림을 그리는 매크로를 실행한다. 매크로는 줄리아의 고급 기능 중 하나이다.<br><code>forword</code>의 인수는 🐢와 픽셀 단위의 거리이므로 실제 크기는 각자 디스플레이에 따라 결정된다.<br>거북이와 함께 호출할 수 있는 다른 함수로는 거북이를 회전시키는 <code>turn</code>이 있으며, 해당 함수의 첫 번째 인수는 🐢가, 두 번째 인수에는 회전 각도가 들어간다.</p>
<p>또한 각각의 거북이들은 내리거나 올릴 수 있는 펜을 잡고 있다. 펜을 내린다면 거북이가 움직였던 경로들을 남기며, 반대로 펜을 올리면 경로들을 남기지 않는다. 즉, 펜이 내려간 상태에서 거북이가 앞으로 움직이면 거북이가 앞으로 간 경로가 남겨지는 것이다. 이런 함수를 <code>penup</code>, <code>pendown</code>이라고 부른다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line">    turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="간단한-반복"><a href="#간단한-반복" class="headerlink" title="간단한 반복"></a>간단한 반복</h3><p>다음과 같이 한번 써보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line">    turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line">    turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line">    turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    forward(🐢, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 예시는 사각형을 그리는 코드이다.<br>우리는 <code>for</code>문을 사용하여 위의 예시와 같은 똑같은 작업을 더 간단하게 수행할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">          println(<span class="string">"Hello!"</span>)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">Hello!</span><br><span class="line">Hello!</span><br><span class="line">Hello!</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure>
<p>해당 예시는 <code>for</code>문의 가장 간단한 예시이다. <code>for</code>문에 대한 자세한 내용은 다른 장에서 더 살펴볼 예정이다.<br>지금부터 위의 간단한 <code>for</code>문을 이용해서 사각형을 그려보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">        forward(🐢, <span class="number">100</span>)</span><br><span class="line">        turn(🐢, -<span class="number">90</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>for</code>문의 문법은 함수를 정의하는 것과 비슷하다. 헤더(header)와 본문이 있으며, 마지막에는 키워드 <code>end</code>를 사용한다.</p>
<p>또한 <code>for</code>문은 본문을 헤더에 지정된 수만큼 반복하므로 루프(loop)라고도 부른다. 위의 예시의 경우는 (<code>i in 1:4</code>처럼 4번이라고 지정했음) 4번 반복 실행한다.</p>
<h3 id="예시-풀어보기"><a href="#예시-풀어보기" class="headerlink" title="예시 풀어보기"></a>예시 풀어보기</h3><p>이번 장에서는 거북이를 사용하여 여러 가지 연습을 해볼 것이다.</p>
<ul>
<li>거북이를 <code>t</code> 매개 변수로 사용하는 <code>square()</code>를 작성하시오.</li>
</ul>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> square()</span><br><span class="line">       t=Turtle()</span><br><span class="line">       <span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">               forward(t,<span class="number">100</span>)</span><br><span class="line">               turn(t,-<span class="number">90</span>)</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>t</code>를 <code>sqaure()</code>의 인수로 전달하는 함수를 작성한 후, 매크로를 실행하시오.</li>
</ul>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> square(t)</span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">               forward(t,<span class="number">100</span>)</span><br><span class="line">               turn(t,-<span class="number">90</span>)</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">🐢=Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">           square(🐢)</span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>변의 길이가 <code>len</code>이 되도록 본문을 수정한 후, <code>len</code>이라는 다른 매개 변수를 <code>square()</code>에 추가하시오.</li>
</ul>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> square(t, len)</span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">               forward(t, len)</span><br><span class="line">               turn(t, -<span class="number">90</span>)</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">           square(🐢,<span class="number">200</span>)</span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>square()</code>의 복사본을 만들고 이름을 <code>polygon()</code>으로 변경하시오. 그 후 새로운 매개변수 <code>n</code>을 추가하고 본문을 수정하시오. (n의 외부각도는 360/n 으로 수정하면 된다.)</li>
</ul>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> polygon(t,len,n)</span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">               forward(t,len)</span><br><span class="line">               turn(t,-<span class="number">360</span>/n)</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">           polygon(🐢,<span class="number">100</span>,<span class="number">5</span>)</span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>t</code> 와 반지름 <code>r</code>를 매개 변수로 하는 <code>circle()</code>를 작성하시오.</li>
</ul>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> circle(t, r)</span><br><span class="line">    circum = <span class="number">2</span>* <span class="literal">π</span> *r</span><br><span class="line">    n=<span class="number">20</span></span><br><span class="line">    len=circum/n</span><br><span class="line">    polygon(t, len, n)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">           circle(🐢,<span class="number">50</span>)</span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h3><p>첫 번째 연습에서는 사각형 그리기 코드를 함수 정의에 넣은 후 거북이를 매개 변수를 전달하여 함수를 호출하도록 요청한다. 해당 코드는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> square(t)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">        forward(t, <span class="number">100</span>)</span><br><span class="line">        turn(t, -<span class="number">90</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    square(🐢)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>square()</code> 가장 안쪽에 있는 명령문  <code>forward</code>와 <code>turn</code>은 <code>for</code>문에 속해있다는 것을 나타내기 위해 두 번 들여쓰기로 작성한다.</p>
<p>위의 예시와 같이 코드 조각들을 함수로 감싸는 것을 캡슐화(Encapsulation)라고 한다. 캡슐화의 이점 중 하나는 코드에 이름을 첨부하여 프로그램 과정을 명확하게 정리할 수 있다는 것이다. 또한 한 번 캡슐화를 진행한 이후에는 코드를 재사용할 때 함수 하나만 호출하면 되기 때문에 간편하다.</p>
<h3 id="일반화"><a href="#일반화" class="headerlink" title="일반화"></a>일반화</h3><p>다음으로는 <code>len</code>이라는 매개 변수를 추가하는 것이다. 코드는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> square(t, len)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">        forward(t, len)</span><br><span class="line">        turn(t, -<span class="number">90</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    square(🐢, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>함수에 매개 변수를 추가하는 것은 해당 함수를 보다 다양한 환경에서 일반적으로 사용할 수 있게 만들어주기 때문에 일반화(Generalization)라고 한다. 매개 변수 <code>len</code>을 추가함으로써 <code>square()</code>는 이제 사각형의 길이를 조정할 수 있게 되었다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> polygon(t, n, len)</span><br><span class="line">    angle = <span class="number">360</span> / n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        forward(t, len)</span><br><span class="line">        turn(t, -angle)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">🐢 = Turtle()</span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    polygon(🐢, <span class="number">7</span>, <span class="number">70</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 칠각형을 그리는 코드 예시이다.</p>
<h3 id="인터페이스-디자인"><a href="#인터페이스-디자인" class="headerlink" title="인터페이스 디자인"></a>인터페이스 디자인</h3><p>다음 단계는 반지름 <code>r</code>를 매개 변수로 하는 <code>circle()</code>를 작성하는 것이다.  다음은 다각형 함수인 <code>polygon()</code>을 사용하여 20면 다각형을 그리는 코드이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> circle(t, r)</span><br><span class="line">    circumference = <span class="number">2</span> * <span class="literal">π</span> * r</span><br><span class="line">    n = <span class="number">20</span></span><br><span class="line">    len = circumference / n</span><br><span class="line">    polygon(t, n, len)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    circle(t, r)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>첫 번째 줄은 반지름이 <code>r</code>인 원의 둘레를 계산한다. <code>n</code>은 각도가 변형되는 수이며, <code>len</code>은 선분의 길이이기 때문에 둘레를 <code>n</code>으로 나눠 정의한다. 그러면 20면 다각형을 그릴 수 있다.</p>
<p>위의 해결안은 문제는 <code>n</code>이 상수라는 것이다. 즉, 매우 큰 원의 경우 선분이 너무 길고 작은 원의 경우는 작은 선분을 그리는데 시간이 낭비된다. 따라서 <code>n</code>을 매개 변수로 사용하여 일반화한다면, 이 문제를 해결할 수 있다.<br>하지만 이런 일반화는 사용자에게 더 많은 제어권을 부여하지만 인터페이스는 덜 깨끗해진다.</p>
<p>함수의 인터페이스(interface)는 어떻게 사용되는지에 대한 요약이다. 구체적으로 인터페이스는 매개 변수는 무엇인지, 반환 값은 무엇인지 등의 내용들을 포함하고 있다고 보면 된다.<br>보통 사용자가 불필요한 세부 사항을 처리할 필요 없이 작업이 수행되는 함수들을 인터페이스가 깨끗하다고 말한다.</p>
<p>예를 들어, 위의 예제에서 <code>r</code>은 그릴 원을 지정하므로 인터페이스에 속한다. 하지만 <code>n</code>은 원을 그리는 방법에 대한 세부 사항과 관련이 있기 때문에 인터페이스에 속하지 않는다.<br>따라서 인터페이스를 어지럽히지 말고 둘레에 따라 적절한 <code>n</code>값을 선택하는게 좋다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> circle(t, r)</span><br><span class="line">    circumference = <span class="number">2</span> * <span class="literal">π</span> * r</span><br><span class="line">    n = trunc(circumference / <span class="number">3</span>) + <span class="number">3</span></span><br><span class="line">    len = circumference / n</span><br><span class="line">    polygon(t, n, len)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="meta">@svg</span> <span class="keyword">begin</span></span><br><span class="line">    circle(t, r)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 <code>len</code>의 값이 3에 가까울 수 있도록 <code>n</code>을 자동 설정한 코드다. <code>len</code>의 값은 호선의 길이로서 3정도가 원 크기와 상관없이 가장 적합하기에 3으로 결정하였다.</p>
<p><code>n</code>값에 3을 더해준 것은 다각형의 선분이 적어도 3 이상이라는 것을 보장한다.</p>
<h3 id="리팩토링"><a href="#리팩토링" class="headerlink" title="리팩토링"></a>리팩토링</h3><p>이전 장에서 <code>circle()</code>를 설계할 때는 <code>polygon()</code>를 재사용할 수 있었다. 하지만 <code>arc()</code>는 지금까지 만들었던 함수들을 이용할 수 없다.<br>한가지 대안으로는 다각형의 사본을 만들고, 호선으로 변환하는 것이다. 결과는 다음 코드와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> arc(t, r, angle)</span><br><span class="line">    arc_len = <span class="number">2</span> * <span class="literal">π</span> * r * angle / <span class="number">360</span></span><br><span class="line">    n = trunc(arc_len / <span class="number">3</span>) + <span class="number">1</span></span><br><span class="line">    step_len = arc_len / n</span><br><span class="line">    step_angle = angle / n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        forward(t, step_len)</span><br><span class="line">        turn(t, -step_angle)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이 함수의 후반부는 <code>polygon()</code>와 유사해보이지만 핵심요소인 인터페이스를 변경했기 때문에 재사용한 것이라고 볼 수는 없다. 따라서 위의 예시는  <code>angle</code>이라는 변수를 추가하여 <code>polygon()</code>을 일반화하였기 때문에 해당 함수는 더 이상 <code>다각형(polygon)</code>라는 이름을 가질 수 없다.</p>
<p>지금부터는 더 일반적으로 사용할 수 있는 <code>polyline()</code>을 만들어보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> polyline(t, n, len, angle)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        forward(t, len)</span><br><span class="line">        turn(t, -angle)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의  <code>polyline()</code>을 이용하여 <code>polygon()</code>과 <code>arc()</code>을 더 간단하게 캡슐화할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> polygon(t, n, len)</span><br><span class="line">    angle = <span class="number">360</span> / n</span><br><span class="line">    polyline(t, n, len, angle)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> arc(t, r, angle)</span><br><span class="line">    arc_len = <span class="number">2</span> * <span class="literal">π</span> * r * angle / <span class="number">360</span></span><br><span class="line">    n = trunc(arc_len / <span class="number">3</span>) + <span class="number">1</span></span><br><span class="line">    step_len = arc_len / n</span><br><span class="line">    step_angle = angle / n</span><br><span class="line">    polyline(t, n, step_len, step_angle)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>마지막으로 <code>arc()</code>을 이용하여 <code>circle()</code>를 간단하게 표현할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> circle(t, r)</span><br><span class="line">    arc(t, r, <span class="number">360</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>지금까지 복잡했던 코드들을 일반화하고 캡슐화하여 정리하였다. 이와같이 인터페이스를 개선하고 코드 재사용을 위해 프로그램을  정리하는 과정을 리팩토링이라고 한다. 이 경우는 호를 구하는 <code>arc()</code>과 다각형을 구하는 <code>polygon()</code>의 유사점을 발견하여 <code>polyline()</code>으로 정리하였다.</p>
<p>프로그램을 미리 계획한 경우에는 먼저  <code>polyline()</code>을 작성하여 리팩토링을 생략했겠지만, 대부분 프로젝트 시작시에 모든 인터페이스를 설계하지 못한다. 따라서 리팩토링을 하는 법을 알아두는 것도 중요하다.</p>
<h3 id="개발-계획"><a href="#개발-계획" class="headerlink" title="개발 계획"></a>개발 계획</h3><p>개발 계획은 프로그램을 만드는 프로세스이다. 이 사례 연구에서 사용한 프로세스는 “캡슐화 및 일반화”이며, 이 프로세스의 단계는 다음과 같다.</p>
<ol>
<li>함수 정의 없이 작은 프로그램을 작성하기.</li>
<li>일단 프로그램이 작동하면, 일관된 부분을 찾아서 함수로 캡슐화하고 이름을 지정하기</li>
<li>함수에 적절한 매개 변수를 추가하여 함수를 일반화하기</li>
<li>프로그램 기능이 원하는만큼 나올 때까지 1-3단계를 반복하기</li>
<li>리팩토링을 통해 프로그램을 개선하기 (캡슐화와 일반화 다시 점검)</li>
</ol>
<p>이 프로세스에는 몇 가지 단점이 있기 때문에, 이후 단점에 대해 알아보고 대안을 논의할 것이다. 하지만 프로그램을 함수로 설정하는 방법을 모르는 경우에는 유용하게 사용할 수 있는 방법이다.</p>
<h3 id="독스트링-Docstring"><a href="#독스트링-Docstring" class="headerlink" title="독스트링(Docstring)"></a>독스트링(Docstring)</h3><p>독스트링(Docstring)의 ‘Doc’은 ‘documentation’의 줄임말이며, 이는 함수 앞에 인터페이스를 설명하는 설명을 의미한다. 아래 예시를 보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">polyline(t, n, len, angle)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Draws n line segments with the given length and</span></span><br><span class="line"><span class="string">angle (in degrees) between them.  t is a turtle.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">function</span> polyline(t, n, len, angle)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        forward(t, len)</span><br><span class="line">        turn(t, -angle)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 예시와 같은 문법(<code>“””</code>)을 사용하여 함수 앞에 작성하며, 이후 REPL에서 <code>?</code>를 입력하고 함수의 이름을 치면 문서를 확인할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">help?&gt; polyline</span><br><span class="line">search:</span><br><span class="line"></span><br><span class="line">  polyline(t, n, len, angle)</span><br><span class="line"></span><br><span class="line">  Draws n line segments with the given length and angle (<span class="keyword">in</span> degrees) between them. t is a turtle.</span><br></pre></td></tr></table></figure>
<p>독스트링에는 해당 함수를 사용하기 위한 필수적인 정보가 포함되어 있다. 따라서 팀 단위로 개발을 하는 경우에는 만든 함수에 독스트링을 붙여 다른 사람들도 쉽게 사용할 수 있도록 하는 것이 좋다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>인터페이스는 함수와 사용자 사이의 계약과 같다. 사용자는 특정 매개 변수를 제공하고 함수는 특정 작업을 수행한다.<br>예를 들어 <code>polyline()</code>에서는 4개의 인수가 필요하다. t는 <code>Turtle()</code>이어야 하며 <code>n</code>은 정수여야 하고, <code>len</code>은 양수여야 한다. <code>angle</code>은 각도로 인식되어야 하며, 도 단위로 설정되어 있다.</p>
<p>이런 요구사항들은 함수가 실행되기 전에 <code>true</code>로 간주되기 때문에 전제조건(preconditions)이라고 한다. 반대로 함수 작동 끝에 생성되는 결과 등을 사후 조건(postconditions)라고 한다.</p>
<p>전제 조건의 오류는 사용자의 책임이다. 사용자들이 전제 조건을 어겨서 함수가 제대로 작동하지 않는다면 이는 사용자측에 버그가 있는 것이다. (함수에는 버그가 없다.)</p>
<p>하지만 만약 전제 조건은 알맞게 작성했는데 사후 조건이 이상하다면, 이것은 함수에 버그가 있는 것이다. 따라서 해당 함수의 전제 조건과 사후 조건을 명확하게 아는 것은 디버깅에 많은 도움을 준다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 함수</title>
    <url>/2020/02/29/Think-Julia-Chapter-3/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap03" target="_blank" rel="noopener">Functions</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h2><p>프로그래밍에서 함수는 특정 계산을 수행하는 일련의 명령문이다. 함수를 정의할 때에는 이름과 명령문의 순서를 정하며, 이후 해당 이름을 통해서 함수를 호출할 수 있다.</p>
<h3 id="함수-호출"><a href="#함수-호출" class="headerlink" title="함수 호출"></a>함수 호출</h3><p>우리는 이미 함수를 호출해 본 경험이 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
<p>이 함수의 이름은 <code>println()</code>이다. 또한 괄호 안에 들어가는 표현식은 함수의 인수(argument)라고 부른다.<br>함수가 작동하는 과정은 일반적으로 인수를 받은 후 결과를 반환한다고 설명하며, 이런 결과를 반환 값이라고 한다.</p>
<p>줄리아는 데이터 타입을 바꿔주는 함수도 제공한다. 예로 <code>parse()</code>는 숫자로 구성된 문자열을 인수로 받은 후, 정수나 소수로 변환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; parse(<span class="built_in">Int64</span>, <span class="string">"32"</span>)</span><br><span class="line"><span class="number">32</span></span><br><span class="line">julia&gt; parse(<span class="built_in">Float64</span>, <span class="string">"3.14159"</span>)</span><br><span class="line"><span class="number">3.14159</span></span><br><span class="line">julia&gt; parse(<span class="built_in">Int64</span>, <span class="string">"Hello"</span>)</span><br><span class="line">ERROR: <span class="built_in">ArgumentError</span>: invalid base <span class="number">10</span> digit <span class="string">'H'</span> <span class="keyword">in</span> <span class="string">"Hello"</span></span><br></pre></td></tr></table></figure>
<p>또한 <code>trunc()</code>는 소수를 인수로 받아 나머지들을 제거한 후, 남은 정수만을 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; trunc(<span class="built_in">Int64</span>, <span class="number">3.99999</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">julia&gt; trunc(<span class="built_in">Int64</span>, -<span class="number">2.3</span>)</span><br><span class="line">-<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><code>float()</code>는 정수를 소수로 변환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; float(<span class="number">32</span>)</span><br><span class="line"><span class="number">32.0</span></span><br></pre></td></tr></table></figure>
<p>마지막으로, <code>string()</code>는 인수들을 모두 문자로 변환한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; string(<span class="number">32</span>)</span><br><span class="line"><span class="string">"32"</span></span><br><span class="line">julia&gt; string(<span class="number">3.14159</span>)</span><br><span class="line"><span class="string">"3.14159"</span></span><br></pre></td></tr></table></figure>
<h3 id="수학-함수"><a href="#수학-함수" class="headerlink" title="수학 함수"></a>수학 함수</h3><p>줄리아는 대부분의 기본적인 수학 함수들이 내장되어 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">ratio = signal_power / noise_power</span><br><span class="line">decibels = <span class="number">10</span> * log10(ratio)</span><br></pre></td></tr></table></figure>
<p>위의 예시에서는 <code>log10</code>을 사용하여 신호와 잡음의 비율을 데시벨 단위로 계산한다. (신호 변수인 <code>signal_power</code>과 잡음 변수인<code>noise_power</code>가 정의되었다는 전제 하에) 또한 자연로그를 계산하는 <code>log</code> 또한 제공된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">radians = <span class="number">0.7</span></span><br><span class="line">height = sin(radians)</span><br></pre></td></tr></table></figure>
<p>다음의 예시는 해당 <code>radians</code>을 <code>sin()</code>에 적용한다. 위의 예시에서 볼 수 있듯이 줄리아는 <code>sin()</code> 및 기타 삼각 함수 (cos, tan 등) 또한 제공한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; degrees = <span class="number">45</span></span><br><span class="line"><span class="number">45</span></span><br><span class="line">julia&gt; radians = degrees / <span class="number">180</span> * <span class="literal">π</span></span><br><span class="line"><span class="number">0.7853981633974483</span></span><br><span class="line">julia&gt; sin(radians)</span><br><span class="line"><span class="number">0.7071067811865475</span></span><br></pre></td></tr></table></figure>
<p>각도(degree)를 통해 <code>radians</code>을 구하기 위해서는 각도를 180으로 나누고 <code>π</code>를 곱해야 한다. 줄리아에서는 <code>π</code>도 바로 사용할 수 있으며, 소수점 16자리까지 정확하다.</p>
<h3 id="컴포지션-composition"><a href="#컴포지션-composition" class="headerlink" title="컴포지션(composition)"></a>컴포지션(composition)</h3><p>지금까지 우리는 변수, 표현식, 명령문과 같은 프로그램의 요소들이 어떻게 결합하는지에 대해서 이야기하고자 한다.<br>프로그래밍 언어의 가장 유용한 특징 중 하나는 작은 요소들을 가져와서 프로그램을 구성할 수 있다는 것이다. 예를 들어 함수의 인수로 산술연산자를 포함한 모든 종류의 표현식들을 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">x = sin(degrees / <span class="number">360</span> * <span class="number">2</span> * <span class="literal">π</span>)</span><br><span class="line">x = exp(log(x+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>할당문의 왼쪽은 무조건 변수 이름이 와야 한다. 이 한 가지의 규칙만 어기지 않는다면, 표현식 대부분에 값을 넣을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; minutes = hours * <span class="number">60</span> <span class="comment"># right</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line">julia&gt; hours * <span class="number">60</span> = minutes <span class="comment"># wrong!</span></span><br><span class="line">ERROR: syntax: <span class="string">"60"</span> is not a valid <span class="keyword">function</span> argument name</span><br></pre></td></tr></table></figure>
<h3 id="새로운-함수-만들기"><a href="#새로운-함수-만들기" class="headerlink" title="새로운 함수 만들기"></a>새로운 함수 만들기</h3><p>지금까지 우리는 줄리아가 제공하는 함수들을 사용해왔다. 하지만 그외에도 새로운 함수를 만들어 사용할 수 있다. 새로운 함수를 만드는 방법은 새로운 함수의 이름을 설정하고 실행될 일련의 명령문들의 순서를 설정하는 것이다. 예를 들면 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printlyrics()</span><br><span class="line">    println(<span class="string">"I'm a lumberjack, and I'm okay."</span>)</span><br><span class="line">    println(<span class="string">"I sleep all night and I work all day."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>function</code>은 함수를 정의하는 키워드이다. 위의 예시에서 함수의 이름은 <code>printlyrics</code>이다. 함수 이름에 대한 규칙은 변수 이름 만드는 규칙과 동일하다. (거의 모든 유니코드는 사용가능하지만 숫자를 이름의 첫 번째 문자로 사용할 수는 없다. 키워드 이름은 사용할 수 없다.)<br>이름 뒤의 빈 괄호는 함수가 인수를 가지지 않는다는 것을 나타낸다.<br>지금까지 설명한 함수의 첫 번째 줄은 헤더(header)라고 부르며, 그 외 나머지는 본문(body)라고 부른다.<br>본문에는 여러 명령문들이 포함되어 있으며, 함수는 키워드 <code>end</code>로 종료된다.<br>또한 가독성을 위해서 본문은 들여 쓰기로 작성해야 한다.</p>
<p>대화식 모드에서 함수를 정의한다면 헤더부터 본문까지 한 줄씩 작성하면 된다. 본문 작성이 끝나고 난 후에는 <code>end</code>를 입력하여 함수 정의를 끝내주어야 한다. 새로 만든 함수를 사용하는 방법은 기존에 있던 함수와 같이 이름을 사용하여 호출하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; printlyrics()</span><br><span class="line"><span class="literal">I</span>'m a lumberjack, and <span class="literal">I</span>'m okay.</span><br><span class="line"><span class="literal">I</span> sleep all night and <span class="literal">I</span> work all day.</span><br></pre></td></tr></table></figure>
<p>새로 만든 함수는 다른 함수 본문에 넣어서 사용할 수도 있다. 아래의 예시를 보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> repeatlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>repeatlyrics()</code>는 앞서 만들었던 <code>printlyrics()</code>를 두 번 실행하도록 정의하였다.<br> 이후 <code>repeatlyrics()</code>를 호출한다면 다음과 같은 결과를 얻을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; repeatlyrics()</span><br><span class="line"><span class="literal">I</span>'m a lumberjack, and <span class="literal">I</span>'m okay.</span><br><span class="line"><span class="literal">I</span> sleep all night and <span class="literal">I</span> work all day.</span><br><span class="line"><span class="literal">I</span>'m a lumberjack, and <span class="literal">I</span>'m okay.</span><br><span class="line"><span class="literal">I</span> sleep all night and <span class="literal">I</span> work all day.</span><br></pre></td></tr></table></figure>
<h3 id="함수-정의와-사용"><a href="#함수-정의와-사용" class="headerlink" title="함수 정의와 사용"></a>함수 정의와 사용</h3><p>앞 장에서 만들었던 함수 정의와 사용 코드를 결합한 전체 프로그램은 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printlyrics()</span><br><span class="line">    println(<span class="string">"I'm a lumberjack, and I'm okay."</span>)</span><br><span class="line">    println(<span class="string">"I sleep all night and I work all day."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> repeatlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">repeatlyrics()</span><br></pre></td></tr></table></figure>
<p>위의 프로그램은 <code>repeatlyrics()</code>와 <code>printlyrics()</code>를 정의한다. 함수를 정의하는 코드는 오로지 함수 객체를 만드는 역할만 하며, 함수가 호출되기 전까지는 함수 본문의 코드가 진행되지 않는다. 따라서 특정 함수를 사용하고 싶다면, 함수를 먼저 정의한 후에 함수를 호출해야 한다.</p>
<h3 id="실행-과정"><a href="#실행-과정" class="headerlink" title="실행 과정"></a>실행 과정</h3><p>함수의 정의와 사용을 올바르게 사용하기 위해서는 실행 과정을 정확히 알고 있어야 한다.<br>실행은 항상 첫 번째 문장에서 시작하며, 명령문은 위에서 아래로 한 번씩만 작동한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printlyrics()</span><br><span class="line">    println(<span class="string">"I'm a lumberjack, and I'm okay."</span>)</span><br><span class="line">    println(<span class="string">"I sleep all night and I work all day."</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> repeatlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line">    printlyrics()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">repeatlyrics()</span><br></pre></td></tr></table></figure>
<p>이 예시를 통해 실행과정을 본다면, 줄리아는 먼저 <code>printlyrics()</code>를 정의한다. 그 후 <code>repeatlyrics()</code>를 정의한 후 호출한다. 호출된  <code>repeatlyrics()</code>는 위에 정의된 본문으로 돌아가 <code>printlyrics()</code>를 호출하는 명령문을 수행한다. 다음으로 호출된 <code>printlyrics()</code>는 해당 함수의 정의된 본문으로 돌아가 명령문을 수행한다. 그 결과가 <code>repeatlyrics()</code>를 호출한 결과로 도출되는 것이다.</p>
<h3 id="매개-변수와-인수"><a href="#매개-변수와-인수" class="headerlink" title="매개 변수와 인수"></a>매개 변수와 인수</h3><p>몇 몇의 함수들은 인수를 필요로 한다. 예를 들어 <code>sin()</code>를 호출하기 위해서는 숫자 한 개를 인수로 입력해야 하며, <code>parse()</code>의 경우 숫자 유형과 문자열 두 개를 인수로 입력해야 한다.</p>
<p>함수 내부에서 인수는 매개 변수라는 변수에 할당된다. 다음 예시는 인수를 취하는 함수에 대한 정의이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> printtwice(bruce)</span><br><span class="line">    println(bruce)</span><br><span class="line">    println(bruce)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이 함수는 인수를 <code>bruce</code>라는 매개 변수에 지정하였기 때문에 함수가 호출되면 매개 변수 값을 두 번 인쇄한다.<br>또한 위의 함수는 인수에 어떤 값이 들어가든 인쇄한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; printtwice(<span class="string">"Spam"</span>)</span><br><span class="line">Spam</span><br><span class="line">Spam</span><br><span class="line">julia&gt; printtwice(<span class="number">42</span>)</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line">julia&gt; printtwice(<span class="literal">π</span>)</span><br><span class="line"><span class="literal">π</span> = <span class="number">3.1415926535897</span>...</span><br><span class="line"><span class="literal">π</span> = <span class="number">3.1415926535897</span>...</span><br></pre></td></tr></table></figure>
<p><code>printtwice()</code>에 내장되어 있는 <code>println()</code>는 모든 표현식들을 인수로 받으므로 <code>printtwice()</code> 또한 모든 표현식들을 인수로 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; printtwice(<span class="string">"Spam "</span>^<span class="number">4</span>)</span><br><span class="line">Spam Spam Spam Spam</span><br><span class="line">Spam Spam Spam Spam</span><br><span class="line">julia&gt; printtwice(cos(<span class="literal">π</span>))</span><br><span class="line">-<span class="number">1.0</span></span><br><span class="line">-<span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>인수는 함수가 호출되기 전에 우선적으로 값을 도출된다. 따라서 위의 예시에서 인수로 쓰인 표현식들은 먼저 값으로 정리 된 후 함수에 적용된다. <code>&quot;Spam &quot;^4</code>인수의 경우, 먼저 <code>Spam Spam Spam Spam</code>으로 도출된 다음에 함수의 인자로 적용된다.</p>
<p>또한 변수도 함수의 인자로 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; michael = <span class="string">"Eric, the half a bee."</span></span><br><span class="line"><span class="string">"Eric, the half a bee."</span></span><br><span class="line">julia&gt; printtwice(michael)</span><br><span class="line">Eric, the half a bee.</span><br><span class="line">Eric, the half a bee.</span><br></pre></td></tr></table></figure>
<h3 id="로컬-변수"><a href="#로컬-변수" class="headerlink" title="로컬 변수"></a>로컬 변수</h3><p>로컬 변수(local)는 함수 정의 안에서 만들어진 변수를 의미한다. 예를 들면,</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> cattwice(part1, part2)</span><br><span class="line">    concat = part1 * part2</span><br><span class="line">    printtwice(concat)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 함수는 두 개의 인수를 사용하여 곱한 다음에 그 결과를 두 번 인쇄한다. 이 함수에서 <code>conat</code>은 함수 내부에서 만들어진 로컬 변수이다.<br>위의 함수를 사용한 예시는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; line1 = <span class="string">"Bing tiddle "</span></span><br><span class="line"><span class="string">"Bing tiddle "</span></span><br><span class="line">julia&gt; line2 = <span class="string">"tiddle bang."</span></span><br><span class="line"><span class="string">"tiddle bang."</span></span><br><span class="line">julia&gt; cattwice(line1, line2)</span><br><span class="line">Bing tiddle tiddle bang.</span><br><span class="line">Bing tiddle tiddle bang.</span><br></pre></td></tr></table></figure>
<p>위의 실행에서 <code>cattwice()</code>가 종료되는 순간 로컬 변수 <code>conat</code>은 삭제된다. 그렇기 때문에  <code>conat</code>을 인쇄하려고 하면 아래와 같은 오류를 만날 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; println(concat)</span><br><span class="line">ERROR: <span class="built_in">UndefVarError</span>: concat not defined</span><br></pre></td></tr></table></figure>
<p>매개 변수 또한 로컬 변수이다. 즉, <code>printtwice()</code> 정의에 사용된 매개 변수 <code>bruce</code> 또한 인쇄할 수 없다.</p>
<h3 id="스택-다이어그램"><a href="#스택-다이어그램" class="headerlink" title="스택 다이어그램"></a>스택 다이어그램</h3><p>어디에서 어떤 변수를 사용했는지 추척하려면 스택 다이어그램을 그리는 것이 유용하다. 스택 다이어그램에는 각 변수의 값과 그 값이 속한 함수도 표시된다.<br>각 함수는 프레임 단위로 그리며, 프레임 안에는 함수의 매개 변수와 로컬 변수를 쓴다.</p>
<p>예시는 다음과 같다.</p>
<p><img src="/images/stack.png" alt="stack diagram"></p>
<p>프레임은 함수가 호출되는 순서대로 배열한다. 위의 예에서는 <code>Main</code>이 <code>cattwice()</code>를 호출하며, <code>cattwice()</code>는 <code>printtwice()</code>를 호출한다. 함수 외부에서 변수를 만들면, 이는 <code>Main</code>에 속한다.</p>
<p>각 매개 변수는 해당 인수와 동일한 값을 나타낸다. 따라서 <code>part1</code>은 <code>line1</code>과 같고 <code>part2</code>는  <code>line2</code>와 같으며, <code>bruce</code>는 <code>conat</code>과 같다.</p>
<p>함수 호출 도중에 오류가 발생가면 줄리아는 해당 오류의 위치를 알려 준다.<br>예를 들어,  <code>printtwice()</code>에서 <code>concat</code>에 액세스하려고하면 <code>UndefVarError</code>가 발생한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">ERROR: <span class="built_in">UndefVarError</span>: concat not defined</span><br><span class="line">Stacktrace:</span><br><span class="line"> [<span class="number">1</span>] printtwice at ./REPL[<span class="number">1</span>]:<span class="number">2</span> [inlined]</span><br><span class="line"> [<span class="number">2</span>] cattwice(::<span class="built_in">String</span>, ::<span class="built_in">String</span>) at ./REPL[<span class="number">2</span>]:<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>위처럼 함수 목록들을 통해 오류가 발생한 프로그램 파일과 함수를 알려주는 것을 스택 추적이라고 한다<br>스택 추척의 함수 목록 순서는 스택 다이어그램의 프레임 순서와 반대이다.</p>
<h3 id="결과-있는-함수와-결과-없는-함수"><a href="#결과-있는-함수와-결과-없는-함수" class="headerlink" title="결과 있는 함수와 결과 없는 함수"></a>결과 있는 함수와 결과 없는 함수</h3><p>우리가 사용하는 어떤 함수는 결괏값을 반환하지만 어떤 함수는 결과를 반환하지 않는다. 우리는 전자를 결과 있는 함수(fruitful function)이라고 하며, 후자를 결과 없는 함수(void function)이라고 한다.</p>
<p>예로 결과 있는 함수를 먼저 본다면,</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="literal">golden</span> = (sqrt(<span class="number">5</span>) + <span class="number">1</span>) / <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>위의 예시의 <code>sqrt()</code>는 유익한 함수로서 반환 값을 가지고 있기 때문에 바로 계산이 가능하다.<br>대화식 모드에서 함수를 호출하면, 다음과 같은 결과를 도출한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; sqrt(<span class="number">5</span>)</span><br><span class="line"><span class="number">2.23606797749979</span></span><br></pre></td></tr></table></figure>
<p>하지만 스크립트 모드에서는 위의 예시처럼 함수를 호출하면 반환 값은 손실된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">sqrt(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>위의 스크립트는 아래의 값은 산출만 한다. (저장하지 않는다.)</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="number">2.23606797749979</span></span><br></pre></td></tr></table></figure>
<p>따라서 스크립트 모드에서는 그다지 유익한 함수로서 작동하지 않는다.</p>
<p>결과 없는 함수는 화면에 값을 표시하거나 다른 영향을 줄 수는 있지만 반환 값은 없다. 아래의 예시를 보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; result = printtwice(<span class="string">"Bing"</span>)</span><br><span class="line">Bing</span><br><span class="line">Bing</span><br><span class="line">julia&gt; show(result)</span><br><span class="line"><span class="literal">nothing</span></span><br></pre></td></tr></table></figure>
<p>위의 예시는 변수 <code>result</code>에 함수의 값을 할당하였지만, 밑에 결과를 보면 아무것도 없는 것을 확인할 수 있다.  두번째 코드의 결과인 <code>nothing</code>은 그 자체로 특수한 데이터 타입이며,  문자열인 <code>”nothing”</code>과는 구분된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; typeof(<span class="literal">nothing</span>)</span><br><span class="line">Nothing</span><br></pre></td></tr></table></figure>
<h3 id="왜-함수인가"><a href="#왜-함수인가" class="headerlink" title="왜 함수인가"></a>왜 함수인가</h3><p>프로그램을 만드는데 있어 함수가 왜 유용한지 궁금할 것이다. 이에 대한 몇 가지 이유를 보자.</p>
<ul>
<li>함수는 명령문들을 묶어서 사용할 수 있으므로, 이후 프로그램을 쉽게 파악하고 디버깅을 할 수 있다.</li>
<li>함수는 반복적인 코드들을 대체하여 프로그램 코드를 더 짧게 만들어준다.</li>
<li>한번에 긴 프로그램을 설계하는 것보다 함수 단위로 나누어 설계하고 조립하는 것이 더 쉽다.</li>
<li>잘 설계된 함수는 여러 프로그램에서 사용할 수 있다. (재사용 가능)</li>
<li>줄리아에서는 함수들이 성능을 크게 향상시킬 수 있다.</li>
</ul>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>디버깅은 가장 중요한 기술 중 하나이다. 그 이유는 프로그램 진행과정을 완벽히 알고 있어야 가능한 기술이기 때문이다. 프로그램에 문제가 생긴다면 개발자는 프로그램의 진행과정에서 문제와 관련된 단서를 찾고, 해결방안을 모색해야 한다. 이런 과정들은 매우 어렵고 힘들지만, 꼭 필요한 능력이다.</p>
<p>어떤 사람들에게는 프로그래밍과 디버깅은 동일하다. 즉, 프로그래밍은 원하는 작업이 수행될 때까지 코드들을 점검하고 디버깅하는 과정이기 때문이다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>1. 변수 , 표현식과 명령문</title>
    <url>/2020/02/28/Think-Julia-Chapter-2/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap02" target="_blank" rel="noopener">Variables, Expressions and Statements</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<hr>
<h2 id="변수-표현식과-명령문"><a href="#변수-표현식과-명령문" class="headerlink" title="변수 , 표현식과 명령문"></a>변수 , 표현식과 명령문</h2><p>프로그래밍 언어의 가장 큰 특징 중 하나는 변수를 설정할 수 있다는 것이다.  변수(variables)란 값(values)을 나타내는 이름으로서, 개발자가 특정 변수에 직접 값을 할당하여 사용할 수 있다.</p>
<h3 id="할당문"><a href="#할당문" class="headerlink" title="할당문"></a>할당문</h3><p>할당문이란 새로운 변수를 만들고, 그 변수에 값을 주는 코드를 말한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; message = <span class="string">"And now for something completely different"</span></span><br><span class="line"><span class="string">"And now for something completely different"</span></span><br><span class="line">julia&gt; n = <span class="number">17</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line">julia&gt; π_val = <span class="number">3.141592653589793</span></span><br><span class="line"><span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure>
<p>위의 예시는 3개의 할당문을 보여준 것이다. 첫 번째 코드는 <code>message</code>라는 변수를 만들어 등호 뒤의 문자열을 할당한다. 두 번째 코드는 정수 <code>17</code>을 변수 <code>n</code>에 할당하며, 세 번째는 π의 근사값을 변수 <code>π_val</code>에 할당한다.</p>
<h3 id="변수-이름"><a href="#변수-이름" class="headerlink" title="변수 이름"></a>변수 이름</h3><p>변수 이름은 길이에 제약 없이 설정할 수 있으며, 프로그래머들은 일반적으로 변수 이름에 특정 의미(변수의 목적 등)를 담아 사용한다. 변수 이름은 거의 모든 유니코드 글자들을 포함하지만, 숫자를 이름의 시작으로는 사용할 수 없다. 또한 대문자를 사용하는 것이 문제가 되지는 않지만 주로 소문자를 이용하여 변수 이름을 만든다.</p>
<p>밑줄문자(_)도 변수 이름에 사용할 수 있다. 이 문자는 your_name 이나 airspeed_of_unladen_swallow 와 같이 여러 단어가 연결된 이름에 단어들을 구분하는 구분자로서 사용된다.</p>
<p>만약 위의 내용을 어긴 변수 이름을 사용하여 변수를 만든다면, 문법 에러(syntax error)가 나올 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="number">76</span>trombones = <span class="string">"big parade"</span></span><br><span class="line">ERROR: syntax: <span class="string">"76"</span> is not a valid <span class="keyword">function</span> argument name</span><br><span class="line">julia&gt; more@ = <span class="number">1000000</span></span><br><span class="line">ERROR: syntax: extra token <span class="string">"@"</span> after <span class="keyword">end</span> of expression</span><br><span class="line">julia&gt; <span class="keyword">struct</span> = <span class="string">"Advanced Theoretical Zymurgy"</span></span><br><span class="line">ERROR: syntax: unexpected <span class="string">"="</span></span><br></pre></td></tr></table></figure>
<p><code>76trombones</code>는 숫자로 시작했기 때문에 변수 이름으로 사용할 수 없으며, <code>more@</code>는 마지막 @기호로 인해서 변수 이름으로 사용할 수 없다. 그렇다면 <code>struct</code>는 뭐가 문제일까?</p>
<p>사실 <code>struct</code>은 줄리아의 키워드이다. REPL에서는 프로그램의 구조를 이해하기 위해서 몇 가지의 키워드를 사용하는데, 이 키워드 또한 변수 이름으로 사용할 수 없다. 줄리아는 아래의 그림과 같은 키워드들을 가지고 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract type</span>     <span class="keyword">baremodule</span>     <span class="keyword">begin</span>       <span class="keyword">break</span>         <span class="keyword">catch</span></span><br><span class="line"><span class="keyword">const</span>             <span class="keyword">continue</span>       <span class="keyword">do</span>          <span class="keyword">else</span>          <span class="keyword">elseif</span></span><br><span class="line"><span class="keyword">end</span>               <span class="keyword">export</span>         <span class="keyword">finally</span>     <span class="keyword">for</span>           <span class="keyword">function</span></span><br><span class="line"><span class="keyword">global</span>            <span class="keyword">if</span>             <span class="keyword">import</span>      <span class="keyword">importall</span>     <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span>               <span class="keyword">local</span>          <span class="keyword">macro</span>       <span class="keyword">module</span>        <span class="keyword">mutable struct</span></span><br><span class="line"><span class="keyword">primitive type</span>    <span class="keyword">quote</span>          <span class="keyword">return</span>      <span class="keyword">try</span>           <span class="keyword">using</span></span><br><span class="line"><span class="keyword">struct</span>            <span class="keyword">where</span>          <span class="keyword">while</span></span><br></pre></td></tr></table></figure>
<p>위의 키워드들을 모두 외울 필요는 없다. 만약 키워드로 변수 이름을 설정하려고 해도 대부분의 개발 환경에서는 키워드들을 다른 색깔로 보여주기 때문에 키워드임을 알 수 있다.</p>
<h3 id="표현식과-명령문들"><a href="#표현식과-명령문들" class="headerlink" title="표현식과 명령문들"></a>표현식과 명령문들</h3><p>표현식(expression)은 값, 변수 및 연산자들의 조합이다. 값이나 변수 그자체는 모두 표현식으로 간주되기 때문에 아래의 코드들은 모두 표현식이라고 볼 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="number">42</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line">julia&gt; n</span><br><span class="line"><span class="number">17</span></span><br><span class="line">julia&gt; n + <span class="number">25</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>위의 세 번째 코드와 같은 표현식을 작동시키면, REPL은 변수인 <code>n</code>의 값을 찾아서 연산을 진행한다. <code>n</code>의 값은 17이기 때문에 <code>n + 25</code>의 표현식 값은 12+25인 42이다.</p>
<p>명령문(statement)은 변수를 작성하거나 변수를 보여주는 등의 특정 효과를 가지는 코드를 말한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; n = <span class="number">17</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line">julia&gt; println(n)</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>첫 번째 코드는 변수 <code>n</code>에 17이라는 값을 할당하는 명령문이며, 두 번째 코드는 변수 <code>n</code>의 값을 보여주는 함수를 가진 명령문이다.</p>
<p>명령문을 입력하면, REPL이 명령문이 요청하는대로 수행한다.</p>
<h3 id="스크립트-모드"><a href="#스크립트-모드" class="headerlink" title="스크립트 모드"></a>스크립트 모드</h3><p>지금까지는 REPL에 코드를 한 줄씩 직접 입력하여 실행하는 대화식 모드를 사용해왔다. 하지만 이 방법은 긴 코드를 작업하는 경우에는 매우 불편할 것이다.  그렇기에 대안으로서 스크립트 모드를 사용하고자 한다.  <strong>스크립트 모드</strong>란 코드들을 파일에 저장한 후, 줄리아를 실행하여 한번에 작동시키는 것이다. 줄리아의 스크립트 파일은 <code>.ji</code>이라는 확장자명을 가진다.</p>
<p>줄리아는 두 모드를 모두 제공하기 때문에 스크립트에 배치하기 전에 대화식 모드에서 코드를 테스트 해볼 수 있다.</p>
<p>하지만 두 모드 사이에는 혼동하기 쉬운 차이점이 있다.<br>예를 들어 만약 줄리아를 계산기로 사용하여 아래 코드와 같이 입력하면,</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; miles = <span class="number">26.2</span></span><br><span class="line"><span class="number">26.2</span></span><br><span class="line">julia&gt; miles * <span class="number">1.61</span></span><br><span class="line"><span class="number">42.182</span></span><br></pre></td></tr></table></figure>
<p>첫 번째 코드에서는 변수 <code>miles</code>에 값을 할당하고 보여준다. 그리고 두 번째는 표현식이기 때문에 REPL은 변수<code>miles</code>의 값을 찾아 계산을 한 뒤에 결괏값을 보여 준다.<br>그러나 위의 코드를 스크립트로 입력하여 작동시키면, 어떠한 결괏값도 나오지 않는다. 그 이유는 스크립트 모드에서는 표현식 그 자체가 결과를 보여주는 기능을 가지고 있지 않기 때문이다. 즉, 아래의 코드와 같이 입력하지 않으면 값을 표시하지 않는다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">miles = <span class="number">26.2</span></span><br><span class="line">println(miles * <span class="number">1.61</span>)</span><br></pre></td></tr></table></figure>
<p>이런 규칙은 초반에 헷갈릴 수 있다.</p>
<p>스크립트는 보통 일련의 명령문들을 포함한다. 명령문이 둘 이상의 요청을 가진 경우에는 보통 명령문 하나당 하나의 요청만 실행된다.<br>예로, 아래의 코드를 스크립트 모드로 작동시킨다면,</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">println(<span class="number">1</span>)</span><br><span class="line">x = <span class="number">2</span></span><br><span class="line">println(x)</span><br></pre></td></tr></table></figure>
<p>결과는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>두번째 줄 코드인 할당문은 2라는 결과를 도출하지 않았다. 할당문은 단지 변수에 값은 할당해주는 한 가지 역할만 한 것이다.</p>
<h3 id="연산자-우선순위"><a href="#연산자-우선순위" class="headerlink" title="연산자 우선순위"></a>연산자 우선순위</h3><p>만약 표현식이 많은 연산자들은 포함하고 있다면, 그 결괏값은 연산자 우선순위에 따라서 결정된다. 줄리아는 수학연산자의 규칙을 따른다. 약어인 PEMDAS는 규칙을 기억하는 유용한 방법이다.</p>
<ul>
<li>괄호(Parentheses)가장 높은 우선순위를 가지며 원하는 순서를 표현하는데 사용할 수 있다.</li>
<li>지수(Exponentiation)가 그 다음으로 높은 우선순위를 가진다.</li>
<li>곱셈(Multiplication)과 나눗셈(Division)이 그 다음으로 작동된다.</li>
<li>마지막으로 덧셈(Addition)과 뺄셈(Subtraction)이 작동한다.<br>-우선순위가 동일한 연산자의 경우 왼쪽에서 오른쪽으로 진행된다.</li>
</ul>
<h3 id="문자열-연산"><a href="#문자열-연산" class="headerlink" title="문자열 연산"></a>문자열 연산</h3><p>일반적으로 수학 연산자들은 문자열에 사용할 수 없다. 심지어 그 문자가 숫자처럼 보일지라도 데이터 타입이 문자열이라면 불가능하다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="string">"2"</span> - <span class="string">"1"</span>    <span class="string">"eggs"</span> / <span class="string">"easy"</span>    <span class="string">"third"</span> + <span class="string">"a charm"</span></span><br></pre></td></tr></table></figure>
<p>그러나 예외로 <code>*</code>와 <code>^</code>는 사용할 수 있다.</p>
<p> <code>*</code> 연산자는 문자를 연결해준다. 즉, 문자열 2개의 끝과 끝을 연결하여 하나의 문자열로 만드는 것을 의미한다.<br>예로 아래의 코드를 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; first_str = <span class="string">"throat"</span></span><br><span class="line"><span class="string">"throat"</span></span><br><span class="line">julia&gt; second_str = <span class="string">"warbler"</span></span><br><span class="line"><span class="string">"warbler"</span></span><br><span class="line">julia&gt; first_str * second_str</span><br><span class="line"><span class="string">"throatwarbler"</span></span><br></pre></td></tr></table></figure>
<p><code>^</code>연산자는 해당 문자열을 반복한다. 예를 들어서 <code>”Spam”^3</code>는 <code>”SpamSpamSpam”</code>로 작동한다. 즉 문자열에서 <code>^</code>연산자는 지수와 유사하게 작동하는 것을 알 수 있다.</p>
<h3 id="주석"><a href="#주석" class="headerlink" title="주석"></a>주석</h3><p>프로그램이 커지고 복잡해지면, 코드를 보고 어떤 작업을 하는지 또는 왜 그 작업을 하는지 알아내기 어려울 때가 많다. 그렇기 때문에 프로그램을 수행함에 있어서 각각의 작업에 대한 설명을 메모해두는 것이 좋다. 이러한 메모를 주석(comment)라고 하며 <code>#</code>기호를 사용한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="comment"># compute the percentage of the hour that has elapsed</span></span><br><span class="line">percentage = (minute * <span class="number">100</span>) / <span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>위의 경우는 주석이 한 줄을 차지하고 있다. 만약 코드와 같은 줄에 주석을 작성하고 싶다면 코드 끝에 쓰면 된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">percentage = (minute * <span class="number">100</span>) / <span class="number">60</span>   <span class="comment"># percentage of an hour</span></span><br></pre></td></tr></table></figure>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>프로그램에서는 세 가지 종류의 오류가 발생할 수 있다. 오류를 빠르게 파악하기 위해서는 이 세 가지 오류에 대해서 알아두는 편이 좋다.</p>
<p><strong>문법 오류(syntax error)</strong><br>문법은 프로그램 구조에 대한 규칙을 나타낸다. 예를 들어서 괄호는 쌍을 이뤄야 하므로 (1+2)는 올바르지만 8)은 문법 오류이다.<br>프로그램 어딘가에 문법오류가 있는 경우 줄리아는 오류 메시지를 도출하고 종료 되며 프로그램은 실행되지 않는다.<br>문법 오류를 추적하는 것은 많은 시간이 필요하지만, 경험이 쌓이면 오류를 빠르게 찾을 수 있다.</p>
<p><strong>런타임 오류(runtime error)</strong><br>런타임 오류는 프로그램이 실행되기 전까지는 나타나지 않는다. 그렇기 때문에 프로그램을 테스트 할 때 파악할 수 있으며, 대부분 인지하지 못한 예외적인 문제들이 이 오류에 포함된다.<br>간단한 프로그램에서 해당 오류는 드물다.</p>
<p><strong>의미 오류(semantic error)</strong><br>의미 오류는 개발자의 의도와는 다른 방향으로 프로그램이 작동되는 현상이다. 이는 문법오류와 같이 컴퓨터가 파악할 수 있는 오류가 아니기 때문에 오류 메시지가 나타나지 않는다.<br>그렇기에 해당 오류를 찾기 위해서는 프로그램의 출력을 보고 수행중인 작업에서 예측가능한 결과인지를 파악하여 역으로 찾는 수밖에 없다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
  <entry>
    <title>0. Github Page와 Hexo를 이용하여 블로그 만들기</title>
    <url>/2020/02/27/about_hexo-0/</url>
    <content><![CDATA[<p>Hexo 블로그를 만들기 위해서는 Github계정을 사용하는 것이 가장 편합니다. Github계정이 없는 분들은 <a href="https://github.com" target="_blank" rel="noopener">Github</a>에서 만들어 주세요! Github계정이 있는 분들이라면 바로 Hexo 블로그를 만들 수 있습니다.</p>
<a id="more"></a>
<p>Hexo 블로그를 만들기 위해서는 크게 2가지의 과정이 필요합니다.</p>
<h2 id="Github-repository-만들기"><a href="#Github-repository-만들기" class="headerlink" title="Github repository 만들기"></a>Github repository 만들기</h2><p>Github repository 만드는 방법은 다음과 같습니다.</p>
<ul>
<li>Github계정에 들어가면 상단바에서 <code>Repositories</code>를 클릭한 후, <code>New</code>를 눌러주세요</li>
<li>그 다음 <code>Repository name</code>에 <code>사용자이름.github.io</code>로 작성하고, <code>Public 모드</code>으로 설정한 다음 <code>create repository</code>를 눌러주세요</li>
<li><p><code>repository</code>생성이 완료되면, 터미널을 켜서 원하는 디렉토리에 아래의 코드를 입력해주세요</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/사용자이름/사용자이름.github.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>디렉토리를 설정하는 방법은 터미널에 <code>pwd</code>를 입력하여 현재 위치를 파악하고, <code>cd 이동하려는 위치 이름</code>을 입력하여 이동하면 됩니다. (Mac 기준)</p>
</li>
<li><p>해당 디렉토리에 <code>사용자이름.github.io</code> 파일이 생성되었다면, 아래의 코드를 입력해주세요.</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 사용자이름.github.io</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; index.html</span><br><span class="line">git add --all</span><br><span class="line">git commit -m <span class="string">"Initial commit"</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>완성입니다! 마지막으로 브라우저에서 <code>https://USERNAME.github.io</code>에 접속되는지 확인해보면 됩니다.</p>
<h2 id="Hexo-만들기"><a href="#Hexo-만들기" class="headerlink" title="Hexo 만들기"></a>Hexo 만들기</h2><p>Hexo 셋팅을 하는 것은 몇 줄의 코드면 끝납니다. 이제부터 아래의 코드를 순서대로 입력해주세요.</p>
<h3 id="설치-전-준비해야-할-것"><a href="#설치-전-준비해야-할-것" class="headerlink" title="설치 전 준비해야 할 것"></a>설치 전 준비해야 할 것</h3><p>Hexo를 설치하기 전에 아래의 요소들을 다운로드 해야 합니다. 이미 다운을 받았다면 넘어가도 좋습니다.<br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a><br><a href="https://git-scm.com" target="_blank" rel="noopener">Git</a></p>
<h3 id="Hexo-설치-코드"><a href="#Hexo-설치-코드" class="headerlink" title="Hexo 설치 코드"></a>Hexo 설치 코드</h3><p>설치를 시작하기에 앞서 터미널에서 Hexo파일을 저장할 디렉토리를 먼저 설정해주셔야 합니다.<br>디렉토리를 설정하는 방법은 <code>Github repository 만들기</code>에 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init myBlog <span class="comment">#`myBlog`라는 파일을 만들기</span></span><br><span class="line"><span class="built_in">cd</span> myBlog <span class="comment">#myBlog로 디렉토리 설정</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>설치가 완료되었습니다.</p>
<h3 id="블로그-기본-설정"><a href="#블로그-기본-설정" class="headerlink" title="블로그 기본 설정"></a>블로그 기본 설정</h3><p>Hexo를 설치하면서 생성한 폴더를 오픈합니다. 그 다음 블로그의 기본적인 설정을 바꾸기 위해서 <code>_config.yml</code>를 열어줍니다.<br>텍스트 파일로 오픈해도 되지만 저의 경우는 <a href="https://code.visualstudio.com" target="_blank" rel="noopener">Visual studio code</a>를 통해서 파일을 열었습니다.<br>해당 파일에서 아래와 같은 부분을 수정하고 저장하면 됩니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># site 정보 수정</span></span><br><span class="line">title: AI&amp;ML <span class="comment"># 블로그 이름</span></span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">author: Hyeonji Ryu <span class="comment"># 사용자 이름</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 정보 수정</span></span><br><span class="line">url: https://사용자이름.github.io <span class="comment"># 이 부분 수정</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/사용자이름/사용자이름.github.io.git</span><br></pre></td></tr></table></figure>
<h3 id="테스트-및-배포하기"><a href="#테스트-및-배포하기" class="headerlink" title="테스트 및 배포하기"></a>테스트 및 배포하기</h3><p>테스트를 위해서 터미널에 아래의 코드를 입력해주세요.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 테스트</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>서버가 작동된 후에는 <code>http://localhost:4000</code>에서 변경사항이 적용된 블로그를 미리 볼 수 있습니다.<br>테스트도 완료했다면 Github repository에서 배포해주시면 블로그 완성입니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 해당 리소스 생성</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 배포하기</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>about Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>blog</tag>
        <tag>헥소</tag>
        <tag>깃허브</tag>
        <tag>블로그</tag>
      </tags>
  </entry>
  <entry>
    <title>0. Why Julia?</title>
    <url>/2020/02/27/Think-Julia-Chapter-0/</url>
    <content><![CDATA[<blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#_why_julia" target="_blank" rel="noopener">Why Julia?</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<hr>
<h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>Julia(이하 줄리아)는 2012년에 개발되었으며, 무료로 사용할 수 있는 오픈소스 프로그래밍 언어 중 하나이다. 사실 프로그래밍 언어를 선택하는 것은 부차적인 문제지만, 이 언어는 선택할만한 가치가 있다. 다음으로 해당 언어의 장점에 대해서 알아보자.</p>
<ul>
<li>줄리아는 높은 성능을 위해 개발된 프로그래밍 언어이다.</li>
<li>줄리아는 다른 데이터 타입에 대한 함수나 메서드도 동적으로 사용 가능한 다중 디스패치(multiple dispatch)를 사용한다.<br>(다중 디스패치는 이후 17장에서 자세히 다룰 예정입니다.)</li>
<li>줄리아는 상호작용하기 쉬운 동적 타입의 언어이다.</li>
<li>줄리아는 배우기 쉬운 수준의 문법을 가진다.</li>
<li>줄리아는 데이터 타입이 정의된 언어(typed programming language)이기 때문에, 사용자의 코드를 더욱 깔끔하고 견고하게 만들어준다.</li>
<li>줄리아는 확장된 표준 라이브러리들이 있으며, 수많은 다른 패키지들도 사용할 수 있다.</li>
</ul>
<p>특히 줄리아는 “두 개의 언어 문제(two language problem)”를 해결하기 때문에 매우 독특한 프로그래밍 언어이다.</p>
<p><strong>두 개의 언어 문제란?</strong> R과 Python과 같은 고수준 언어들은 성능(속도 등)이 떨어지기 때문에, 결국 실용화하기 위에서는 C나 C++로 다시 코드를 작성해야 하는 문제를 말한다.</p>
<p>줄리아는 고성능 코드를 작성하기 위해서 다른 프로그래밍 언어가 필요하지 않다. 즉, 줄리아는 병목현상을 자동으로 최적화해줌으로써 프로그래머들의 어려움을 덜어준다.</p>
<h2 id="프로그램의-방식"><a href="#프로그램의-방식" class="headerlink" title="프로그램의 방식"></a>프로그램의 방식</h2><p>이 책은 독자들이 ‘컴퓨터 사이언티스트’처럼 생각할 수 있도록 안내한다. 그들처럼 생각하는 방식은 수학, 공학, 자연과학 등의 특징들을 결합하는 것이다. 구체적인 방식을 확인해보자. 먼저 컴퓨터 사이언티스트들은 수학자처럼 공식을 사용하여 아이디어(구체적인 계산들)를 표현한다. 그 이후 엔지니어와 마찬가지로 필요한 부품을 시스템에 조립하고 여러 대안들의 장단점을 평가하여 해당 아이디어를 설계한다. 마지막으로 과학자처럼 그들은 복잡한 시스템들의 작동을 관찰하고, 가설을 형성하며 검증한다.</p>
<p>컴퓨터 사이언티스트에게 가장 중요한 능력은 바로 “문제해결(problem solving)” 이다. 문제해결이란 문제를 형식화하고 창의적으로 생각하여 문제에 대한 정확하고 명확한 해결방안을 표현할 수 있는 능력을 말한다. 결론적으로 프로그램을 배우는 과정은 문제해결기술을 연습하는 데 매우 훌륭한 기회라는 것이다. 이것이 이번 챕터의 제목을 “프로그램의 방식”이라고 정한 이유이다.</p>
<h3 id="프로그램이란"><a href="#프로그램이란" class="headerlink" title="프로그램이란"></a>프로그램이란</h3><p>프로그램은 계산을 수행하는 방법을 구체화하는 연속적인 명령이다. 계산은 방정식을 풀거나 다항식의 근을 찾는 것과 같이 수학적인 의미도 있지만, 동시에 문서에서 텍스트를 검색하거나 이미지 처리와 같은 상징적인 의미도 가지고 있다. 명령문 코드의 세부적인 요소들은 언어마다 다르지만, 몇 개의 기본 명령은 모든 언어에서 똑같이 나타난다.</p>
<ul>
<li>Input : 파일이나 인터넷, 다른 디바이스 등에서 데이터를 가져오는 것</li>
<li>Output: 데이터를 스크린에 띄우거나 파일을 저장하는 것, 네트워크를 통해 보내는 것 등을 의미</li>
<li>Math: 덧셈이나 곱셈처럼 기본적인 수학 작동들을 수행하는 것.</li>
<li>Conditional execution: 특정 환경들을 확인하고 알맞은 코드를 적용하는 것.</li>
<li>Repetition: 약간의 변화를 주고 작업을 반복하는 것</li>
</ul>
<p>믿거나 말거나 이것이 프로그램의 거의 전부이다 당신이 사용해왔던 모든 프로그램은 얼마나 복잡한지와는 상관없이 위와 같은 명령들로 만들어졌다.<br>따라서 프로그래밍은 크고 복잡한 기본 명령들을 충분히 수행될 할 수 있을만한 하위 작업들로 나누어 가는 과정으로 생각할 수 있다.</p>
<h3 id="줄리아-시작하기"><a href="#줄리아-시작하기" class="headerlink" title="줄리아 시작하기"></a>줄리아 시작하기</h3><p>줄리아를 배우기 전에, 먼저 해당 소프트웨어를 설치해야 한다. 만약 당신이 컴퓨터의 OS체제를 알고 있다면, 홈페이지에 들어가 알맞은 소프트웨어를 다운로드 받으면 된다.</p>
<p>Julia의 REPL(Read-Eval-Print-Loop)는 Julia 코드를 읽고 실행하는 프로그램이다. 해당 창에 Enter키를 입력하면 아래와 같은 그림이 나타난다.</p>
<p><img src="/images/2020-02-25.png" alt="julia intro"></p>
<p>해당 그림의 마지막 줄에 있는 <code>Julia&gt;</code>는 명령을 입력하는 프롬프트(prompt)이며, 이곳에 코드를 입력하면 결괏값(Output)을 받을 수 있다.</p>
<h3 id="첫-번째-프로그램"><a href="#첫-번째-프로그램" class="headerlink" title="첫 번째 프로그램"></a>첫 번째 프로그램</h3><p>첫 번째 프로그램으로 우리가 작성할 코드는 “Hello, World!” 이다. 코드는 아래 그림과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
<p>위 그림은 <code>print</code>코드의 예시이다. 여기서 <code>print</code>코드는 종이에 글씨를 복사하는 것이 아니라, 단지 입력한 코드에 대한 결괏값을 스크린에 보여주는 것을 의미한다. 인용구 기호(“”)는 글자의 시작과 끝에 사용하며, 결괏값에는 나타나지 않는다. 또한 괄호는 <code>println</code>이 함수라는 것을 알려준다. 함수에 대해서는 3장에서 배울 것이다.</p>
<h3 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a>산술 연산자</h3><p>“Hello, world!” 다음으로는 사칙연산이다. 줄리아는 덧셈이나 곱셈과 같은 기본적인 연산자들을 제공한다. 연산자 기호들은 <code>+</code>는 덧셈, <code>-</code>는 뺄셈, <code>*</code>는 곱셈, <code>/</code>는 나눗셈이다. 해당 기호들을 사용한 예시는 아래의 그림과 같다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="number">40</span>+<span class="number">2</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="number">43</span>-<span class="number">1</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="number">6</span>*<span class="number">7</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="number">84</span>/<span class="number">2</span></span><br><span class="line"><span class="number">42.0</span></span><br></pre></td></tr></table></figure>
<p>위의 계산식에서 유일하게 나눗셈만 답이 소수점으로 나오는데, 그 이유는 바로 다음 글인 데이터 타입에서 설명할 것이다.</p>
<p>마지막으로 연산자 <code>^</code>는 거듭제곱에 대한 기호이다. 즉, 앞의 수를 뒤의 수만큼 제곱하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="number">6</span>^<span class="number">2</span>+<span class="number">6</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="number">2</span>^<span class="number">5</span>+<span class="number">10</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<h3 id="값-그리고-데이터-타입들"><a href="#값-그리고-데이터-타입들" class="headerlink" title="값 그리고 데이터 타입들"></a>값 그리고 데이터 타입들</h3><p>값(value)은 프로그램이 일할 때 사용하는 가장 기본적인 문자나 숫자를 말한다. 예로 우리가 이미 본 “Hello, World!”나 42.0, 2 등이 있다.</p>
<p>위에서 제시한 3개의 값은 모두 다른 데이터 타입을 가지고 있다. 각각의 데이터 타입을 살펴보면2는 정수(integer)이며, 42.0은 소수(floating-point number), “Hello, World!”는 문자(string)이다. 위의 데이터 타입을 영어로 기재한 이유는 코드에서 영어의 축약으로 사용되기에 영어로 알아두는 것이 더 편리하기 때문이다.</p>
<p>만약에 해당 값이 어떤 데이터 타입인지 모르겠다면, REPL에 아래의 코드를 입력해보자.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; typeof(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">Int64</span></span><br><span class="line"></span><br><span class="line">julia&gt; typeof(<span class="number">42.0</span>)</span><br><span class="line"><span class="built_in">Float64</span></span><br><span class="line"></span><br><span class="line">julia&gt; typeof(<span class="string">"Hello, World!"</span>)</span><br><span class="line"><span class="built_in">String</span></span><br></pre></td></tr></table></figure>
<p>정수는 <code>int64</code>로 표시되며, 소수는 <code>float64</code>로 표현된다. 또한 문자의 경우는<code>string</code>로 표시된다.</p>
<p>그렇다면 값 “2”나 “42.0” 의 데이터 타입은 어떨까? 두 값은 숫자처럼 보이지만 인용구를 사용했기 때문에 문자로 인식된다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; typeof(<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">String</span></span><br><span class="line"></span><br><span class="line">julia&gt; typeof(<span class="string">"42.0"</span>)</span><br><span class="line"><span class="built_in">String</span></span><br></pre></td></tr></table></figure>
<p>큰 정수를 값으로 사용할 때 자연스럽게 1,000,000와 같이 콤마를 넣어 수를 사용한다면, 줄리아에서는 이를 정수로 인식하지 못한다. 줄리아는 콤마를 연속된 정수들을 분리하는 기호로서 인식한다. 그렇기 때문에 만약 위와 같은 효과를 주고 싶다면 1_000_000 와 같이 언더바를 사용해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">julia&gt; <span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(<span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span>)</span><br><span class="line">ERROR: <span class="built_in">ArgumentError</span>: typeof: too many arguments (expected <span class="number">1</span>)</span><br><span class="line">Stacktrace:</span><br><span class="line"> [<span class="number">1</span>] top-level scope at none:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="number">1_000_000</span></span><br><span class="line"><span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">julia&gt; typeof(<span class="number">1_000_000</span>)</span><br><span class="line"><span class="built_in">Int64</span></span><br></pre></td></tr></table></figure>
<h3 id="형식-언어와-자연어"><a href="#형식-언어와-자연어" class="headerlink" title="형식 언어와 자연어"></a>형식 언어와 자연어</h3><p>자연어는 영어, 스페인어, 한국어와 같이 사람들이 사용하는 언어를 말한다. 이런 언어들은 특정 사람들로부터 인위적으로 발명된 것이 아니라 자연스럽게 진화된 형태이다.</p>
<p>형식 언어는 특정 필요에 의해서 사람들이 고안한 언어들을 의미한다. 예를 들어, 수학자들이 사용하는 표기법은 숫자와 기호 사이의 관계를 나타내는 데 적합한 형식 언어이며, 화학자들은 형식 언어를 사용하여 분자의 화학구조를 나타낸다. 이와 같이 프로그래밍 언어 또한 계산을 표현하도록 설계된 형식 언어이다.</p>
<p>형식 언어는 엄격한 문법을 가진다. 예를 들어서 3+3=6은 올바른 구문이지만, 3+=3$6은 올바르지 않다. 또한</p>
<p>문법은 크게 토큰과 구조로 구성되어 있는데, 토큰은 단어나 숫자, 화학 원소와 같은 언어의 기본 요소이며 구조는 토큰 간의 올바른 연결이 전제된 문장을 의미한다.</p>
<p>즉, 올바른 문법을 사용했는지 확인하려면,</p>
<p>적절한 토큰을 사용하였는가?</p>
<p>올바른 연결로 적절한 구조를 설정였는가?</p>
<p>위의 두 질문을 잊지 말자.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>프로그래머들은 실수를 하며, 각가지의 이유로 인해 버그(bug)라고 불리는 프로그래밍 에러가 발생한다. 이런 버그들을 추적하는 과정을 디버깅이라고 한다.</p>
<p>디버깅을 할 때 어려운 버그를 만난다면, 컴퓨터에 대한 분노로 인해 개발자를 그만두고 싶을 수 있다. 하지만 디버깅을 배우는 것은 어렵지만 프로그래밍 이외의 많은 활동에도 유용한 기술이기에 포기하지 않기를 바란다.</p>
]]></content>
      <categories>
        <category>Think Julia</category>
      </categories>
      <tags>
        <tag>줄리아</tag>
        <tag>Julia</tag>
        <tag>Think Julia</tag>
        <tag>기초 강의</tag>
      </tags>
  </entry>
</search>
