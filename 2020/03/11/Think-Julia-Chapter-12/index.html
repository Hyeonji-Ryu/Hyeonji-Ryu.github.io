<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://hyeonji-ryu.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.  이 포스트는 Tuples를 한글로 요약 정리한 글입니다.">
<meta property="og:type" content="article">
<meta property="og:title" content="11. 튜플">
<meta property="og:url" content="https://hyeonji-ryu.github.io/2020/03/11/Think-Julia-Chapter-12/index.html">
<meta property="og:site_name" content="AI &amp; ML">
<meta property="og:description" content="글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.  이 포스트는 Tuples를 한글로 요약 정리한 글입니다.">
<meta property="og:locale" content="ko_KR">
<meta property="article:published_time" content="2020-03-10T16:31:08.000Z">
<meta property="article:modified_time" content="2020-03-16T17:04:59.881Z">
<meta property="article:author" content="Hyeonji Ryu">
<meta property="article:tag" content="줄리아">
<meta property="article:tag" content="Julia">
<meta property="article:tag" content="Think Julia">
<meta property="article:tag" content="기초 강의">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hyeonji-ryu.github.io/2020/03/11/Think-Julia-Chapter-12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>11. 튜플 | AI & ML</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-163411677-2"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-163411677-2');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AI & ML</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Julia, Python, R</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>홈</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>태그</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>카테고리</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>아카이브</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>검색
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Hyeonji-Ryu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="ko">
    <link itemprop="mainEntityOfPage" href="https://hyeonji-ryu.github.io/2020/03/11/Think-Julia-Chapter-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hyeonji Ryu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AI & ML">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          11. 튜플
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-03-11 01:31:08" itemprop="dateCreated datePublished" datetime="2020-03-11T01:31:08+09:00">2020-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-17 02:04:59" itemprop="dateModified" datetime="2020-03-17T02:04:59+09:00">2020-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Think-Julia/" itemprop="url" rel="index">
                    <span itemprop="name">Think Julia</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap12" target="_blank" rel="noopener">Tuples</a>를 한글로 요약 정리한 글입니다.<br><a id="more"></a></p>
<h2 id="튜플-Tuples"><a href="#튜플-Tuples" class="headerlink" title="튜플 (Tuples)"></a>튜플 (Tuples)</h2><p>이번 장에서는 또다른 내장된 데이터 타입인 튜플(Tuples)에 대해서 알아보고 배열과 딕셔너리, 튜플이 어떻게 같이 작동하는지 공부할 것이다. 또한 유용한 기능인 ‘수집과 분산 연산자(gather and scatter operators.)’와 ‘가변 인수 배열(variable-length argument arrays)’ 등을 살펴볼 것이다.</p>
<h3 id="튜플은-불변이다"><a href="#튜플은-불변이다" class="headerlink" title="튜플은 불변이다"></a>튜플은 불변이다</h3><p>튜플은 일련의 값들이다. 값은 어떤 데이터 타입도 될 수 있으며, 또한 정수로 인덱싱되기 때문에 배열과 유사한 점이 많다. 중요한 차이점은 튜플은 요소를 변경할 수 없으며 각각의 요소들은 고유한 데이터 타입을 가진다.</p>
<p>문법적으로 튜플은 쉼표로 구분된 값 목록이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span></span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>)</span><br></pre></td></tr></table></figure>
<p>하지만 필요하진 않더라도 괄호를 사용해서 튜플을 작성하는 것이 일반적이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>)</span><br></pre></td></tr></table></figure>
<p>하나의 요소로 튜플을 만들기 위해서는 마지막에 쉼표를 넣어주어야 한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t1 = (<span class="string">'a'</span>,)</span><br><span class="line">(<span class="string">'a'</span>,)</span><br><span class="line">julia&gt; typeof(t1)</span><br><span class="line"><span class="built_in">Tuple</span>&#123;<span class="built_in">Char</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WARNING</strong><br> 쉼표 없는 괄호 안의 값은 튜플이 아니다.</p>
 <figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t2 = (<span class="string">'a'</span>)</span><br><span class="line"><span class="string">'a'</span>: ASCII/Unicode U+<span class="number">0061</span> (category Ll: Letter, lowercase)</span><br><span class="line">julia&gt; typeof(t2)</span><br><span class="line"><span class="built_in">Char</span></span><br></pre></td></tr></table></figure>
<p>튜플을 만드는 다른 방법은 내장 함수를 이용하는 것이다. 인수가 없는 상태인 <code>tuple()</code>을 입력하면 빈 튜플이 생성된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; tuple()</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<p>여러 개의 인수들을 입력한다면, 인수들이 값인 튜플을 생성한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t3 = tuple(<span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">pi</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">π</span> = <span class="number">3.1415926535897</span>...)</span><br></pre></td></tr></table></figure>
<p><code>tuple</code>은 내장 함수의 이름이기 때문에 변수의 이름으로는 사용하지 않는 것이 좋다.</p>
<p>대부분의 배열 연산자들은 튜플에서 작동한다. 대괄호 연산자는 해당 인덱스의 요소를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; t[<span class="number">1</span>]</span><br><span class="line"><span class="string">'a'</span>: ASCII/Unicode U+<span class="number">0061</span> (category Ll: Letter, lowercase)</span><br></pre></td></tr></table></figure>
<p>슬라이스 연산자 또한 요소들의 특정 범위를 선택한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)</span><br></pre></td></tr></table></figure>
<p>그러나 튜플의 한 요소를 수정하려고 시도하면, 아래의 오류 메시지가 나타난다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t[<span class="number">1</span>] = <span class="string">'A'</span></span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching setindex!(::<span class="built_in">NTuple</span>&#123;<span class="number">5</span>,<span class="built_in">Char</span>&#125;, ::<span class="built_in">Char</span>, ::<span class="built_in">Int64</span>)</span><br></pre></td></tr></table></figure>
<p>튜플은 변하지 않기 때문에 요소들을 수정할 수 없다.</p>
<p>관계 연산자들도 튜플이나 기타 시퀀스에서 작동한다. 줄리아는 각 시퀀스에서 첫 번째 요소를 비교하며 시작한다. 동일하면 다음 요소로 진행되며 다른 요소를 찾을 때까지 계속한다. 서브시퀀스는 고려되지 않는다. (실제로 큰 경우에도)</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>) &lt; (<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">julia&gt; (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2000000</span>) &lt; (<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>첫 번째 예시에서는 뒤의 튜플의 모든 요소가 앞의 튜플의 요소보다 모두 크기 떄문에 <code>true</code>를 반환했다. 두 번째 예시는 세 번째 요소가 뒤의 튜플보다 앞의 튜플이 더 크지만 앞의 두 개의 요소가 모두 뒤의 튜플이 더 크기 때문에  <code>true</code>를 반환했다. 즉, 하나라도 큰 요소가 있다면 <code>true</code>이고 아니라면 <code>false</code>를 반환한다.</p>
<h3 id="튜플-할당"><a href="#튜플-할당" class="headerlink" title="튜플 할당"></a>튜플 할당</h3><p>이것은 두 변수의 값을 바꿀 때 유용하다. 기존 할당에서는 임시 변수를 사용해야 한다. 예를 들어 <code>a</code>와 <code>b</code>를 바꾸려고 한다면, 아래와 같이 중간에 임시 변수가 필요하다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br></pre></td></tr></table></figure>
<p>위의 방식은 번거롭다. 튜플은 훨씬 간단한 방법으로 변경한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>
<p>왼쪽은 튜플의 변수들이며, 오른쪽은 튜플의 표현식이다. 각 값들은 해당 변수에 할당되며, 오른쪽의 모든 표현식은 할당 전에 평가된다.</p>
<p>왼쪽에 있는 변수의 수는 오른쪽 값의 수보다 작으면 작동하지만, 초과된 값은 사라진다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; (a, b) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">julia&gt; a, b, c = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">ERROR: <span class="built_in">BoundsError</span>: attempt to access (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  at index [<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>일반적으로 오른쪽은 문자열, 배열, 튜플 등 어떤 종류의 시퀀스도 입력될 수 있다. 예를 들어 이메일 주소를 사용자 이름과 도메인으로 나누려면 다음과 같이 작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; addr = <span class="string">"julius.caesar@rome"</span></span><br><span class="line"><span class="string">"julius.caesar@rome"</span></span><br><span class="line">julia&gt; uname, domain = split(addr, <span class="string">'@'</span>);</span><br></pre></td></tr></table></figure>
<p><code>split()</code>으로부터 반환된 두 값은 배열의 두 요소가 된다. 첫 번째 요소는 <code>uname</code>에 할당되며, 두 번째는 <code>domain</code>에 할당된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; uname</span><br><span class="line"><span class="string">"julius.caesar"</span></span><br><span class="line">julia&gt; domain</span><br><span class="line"><span class="string">"rome"</span></span><br></pre></td></tr></table></figure>
<h3 id="반환-값으로서의-튜플"><a href="#반환-값으로서의-튜플" class="headerlink" title="반환 값으로서의 튜플"></a>반환 값으로서의 튜플</h3><p>엄격하게 말하자면, 함수는 오직 한 개의 값만 반환하지만 그러나 그 한 개의 값이 튜플이라면 여러 개의 값을 반환하는 것과 같은 효과를 가진다. 예를 들어 두 정수의 나눗셈에서 몫과 나머지를 구하려 할 때, <code>x ÷ y</code>을 계산한 후 <code>x % y</code>를 계산하는 것은 비효율적이다. 두 개의 수식을 한번에 계산하는 것이 더 낫다.</p>
<p>내장 함수인 <code>divrem()</code>은 두 인수를 가져가 몫과 나머지인 두 개의 값을 가진 튜플로 반환한다. 이후 결과를 튜플로 저장할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = divrem(<span class="number">7</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>또는 요소들을 각각 저장하기 위해서 튜플 할당을 이용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; q, r = divrem(<span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@show</span> q r;</span><br><span class="line">q = <span class="number">2</span></span><br><span class="line">r = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>아래의 함수는 튜플을 결과로 반환하는 예시이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> minmax(t)</span><br><span class="line">    minimum(t), maximum(t)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>minimum()</code>과 <code>maximum()</code>은 시퀀스에서 가장 작은 수와 큰 수를 찾아주는 내장된 함수이다. <code>minmax()</code>은 두 개의 값을 튜플로 반환한다. 같은 결과를 주는 내장 함수인 <code>extrema()</code>도 효과적이다.</p>
<h3 id="가변-인수-튜플-Variable-length-Argument-Tuples"><a href="#가변-인수-튜플-Variable-length-Argument-Tuples" class="headerlink" title="가변 인수 튜플 (Variable-length Argument Tuples)"></a>가변 인수 튜플 (Variable-length Argument Tuples)</h3><p>함수들은 가변적인 개수의 인수를 받아들일 수 있다. <code>...</code>로 끝나는 매개 변수 이름은 인수를 튜플로 <strong>수집(gather)</strong>한다. 예를 들어 <code>printall()</code>은 여러 인수들을 사용하여 출력한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> printall(args...)</span><br><span class="line">    println(args)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>수집 매개 변수는 어떤 이름도 사용할 수 있지만 관례 상으로 <code>args</code>를 사용된다.<br>아래의 코드는 함수가 어떻게 작동하는지 보여준다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; printall(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">'3'</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">'3'</span>)</span><br></pre></td></tr></table></figure>
<p>위에서 본 수집을 보완해주는 것이 <strong>분산(scatter)</strong>이다. 만약 값의 시퀀스가 있고 여러 인수로 함수에 값을 전달하려는 경우 <code>...</code> 연산자를 사용하면 된다. 예를 들어 <code>divrem()</code>은 정확히 2개의 인수를 받으며, 2개의 요소를 가진 튜플을 넣어도 작동하지 않는다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = (<span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; divrem(t) <span class="comment"># 튜플의 값은 2개이지만 여기서 인수는 1개로 인식된다.</span></span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching divrem(::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int64</span>,<span class="built_in">Int64</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>그러나 튜플에 <code>...</code> 연산자를 사용하면 작동한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; divrem(t...) <span class="comment">#튜플의 값에 가변성을 부여하여 개수를 맞춰준다.</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>많은 내장 함수들이 가변 인수 튜플을 사용한다. 예를 들어, <code>min()</code>과 <code>max()</code>은 여러 인수들을 가져올 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>하지만 <code>sum()</code>은 작동하지 않는다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching sum(::<span class="built_in">Int64</span>, ::<span class="built_in">Int64</span>, ::<span class="built_in">Int64</span>)</span><br></pre></td></tr></table></figure>
<h3 id="배열과-튜플"><a href="#배열과-튜플" class="headerlink" title="배열과 튜플"></a>배열과 튜플</h3><p><code>zip()</code>은 두 개 이상의 시퀀스들을 가져온 후 시퀀스들을 요소로 가진 튜플로 반환하는 내장 함수이다. 함수의 이름은 두 줄의 치아를 연결하고 끼워 넣는 지퍼에서 가져왔다.</p>
<p>아래의 예시는 문자열과 배열을 <code>zip()</code>의 인수로 입력한 결과이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; s = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">julia&gt; t = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">julia&gt; zip(s, t)</span><br><span class="line">Base.Iterators.Zip&#123;<span class="built_in">Tuple</span>&#123;<span class="built_in">String</span>,<span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;&#125;&#125;((<span class="string">"abc"</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure>
<p>위의 결과는 페어 단위로 정리할 수 있는 짚(zip) 객체이다. <code>zip()</code>은 일반적으로 <code>for</code> 루프에서 사용된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> pair <span class="keyword">in</span> zip(s, t)</span><br><span class="line">           println(pair)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">(<span class="string">'a'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>짚 객체는 일종의 이터레이터(iterator)이며 시퀀스를 반복하는 객체이다. 이터레이터는 몇 가지 측면에서 배열과 비슷하지만, 배열과 달리 인덱스를 사용하여 요소를 선택할 수 없다.</p>
<p>만약 배열 연산자나 함수를 사용하고 싶다면, 짚 객체를 이용하여 배열을 만들면 된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; collect(zip(s, t))</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Tuple</span>&#123;<span class="built_in">Char</span>,<span class="built_in">Int64</span>&#125;,<span class="number">1</span>&#125;:</span><br><span class="line"> (<span class="string">'a'</span>, <span class="number">1</span>)</span><br><span class="line"> (<span class="string">'b'</span>, <span class="number">2</span>)</span><br><span class="line"> (<span class="string">'c'</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>위의 결과는 튜플의 배열이다. 이 예시에서 각각의 튜플은 문자열에서 온 문자와 배열에서 온 요소들을 포함한다.</p>
<p>만약 시퀀스가 다른 길이라면, 더 짧은 시퀀스를 기준으로 결과가 출력된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; collect(zip(<span class="string">"Anne"</span>, <span class="string">"Elk"</span>))</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Tuple</span>&#123;<span class="built_in">Char</span>,<span class="built_in">Char</span>&#125;,<span class="number">1</span>&#125;:</span><br><span class="line"> (<span class="string">'A'</span>, <span class="string">'E'</span>)</span><br><span class="line"> (<span class="string">'n'</span>, <span class="string">'l'</span>)</span><br><span class="line"> (<span class="string">'n'</span>, <span class="string">'k'</span>)</span><br></pre></td></tr></table></figure>
<p>튜플의 배열을 순회하기 위해서는 <code>for</code> 루프에서 튜플 할당을 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = [(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> (letter, number) <span class="keyword">in</span> t</span><br><span class="line">           println(number, <span class="string">" "</span>, letter)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure>
<p>루프가 실행될 때마다 줄리아는 배열에서 다음 튜플을 선택하고 그 요소들을 letter와 number로 할당한다. <code>for</code> 루프에서 <code>(letter, number)</code>와 같이 괄호를 사용하는 것은 의무적이다.</p>
<p>만약 <code>zip()</code>, <code>for</code> 루프, 튜플 할당을 모두 결합하면, 동시에 두 개 이상의 시퀀스를 순회하는데 유용한 관용구를 얻는다. 예를 들어, <code>hasmatch()</code>는 <code>t1</code>과 <code>t2</code> 2개의 시퀀스를 가져가서 특정 인덱스 <code>i</code>가 <code>t1[i] == t2[i]</code>라면 <code>true</code>를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> hasmatch(t1, t2)</span><br><span class="line">    <span class="keyword">for</span> (x, y) <span class="keyword">in</span> zip(t1, t2)</span><br><span class="line">        <span class="keyword">if</span> x == y</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>시퀀스의 요소와 인덱스들을 순회해야 한다면, 내장 함수인 <code>enumerate()</code>를 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> (index, element) <span class="keyword">in</span> enumerate(<span class="string">"abc"</span>)</span><br><span class="line">           println(index, <span class="string">" "</span>, element)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure>
<p><code>enumerate()</code>의 결과는 enumerate 객체이며, 일련의 쌍을 반복한다. 각 쌍에는 인덱스와 시퀀스 요소가 포함되어 있다.</p>
<h3 id="딕셔너리와-튜플"><a href="#딕셔너리와-튜플" class="headerlink" title="딕셔너리와 튜플"></a>딕셔너리와 튜플</h3><p>딕셔너리는 키-값 페어를 반복하는 이터레이터(iterator)로 사용할 수 있다. <code>for</code> 루프에서 사용한다면 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; d = <span class="built_in">Dict</span>(<span class="string">'a'</span>=&gt;<span class="number">1</span>, <span class="string">'b'</span>=&gt;<span class="number">2</span>, <span class="string">'c'</span>=&gt;<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> (key, value) <span class="keyword">in</span> d</span><br><span class="line">           println(key, <span class="string">" "</span>, value)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">a <span class="number">1</span></span><br><span class="line">c <span class="number">3</span></span><br><span class="line">b <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>딕셔너리와 동일하게 아이템들은 특정한 순서가 없다.</p>
<p>또한 튜플 배열을 사용하여 새 딕셔너리로 초기화할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; t = [(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">3</span>), (<span class="string">'b'</span>, <span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line">julia&gt; d = <span class="built_in">Dict</span>(t)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Char</span>,<span class="built_in">Int64</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  <span class="string">'a'</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="string">'c'</span> =&gt; <span class="number">3</span></span><br><span class="line">  <span class="string">'b'</span> =&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><code>Dict()</code>과 <code>zip()</code>을 결합하면 딕셔너리를 만드는 간결한 방법이 된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; d = <span class="built_in">Dict</span>(zip(<span class="string">"abc"</span>, <span class="number">1</span>:<span class="number">3</span>))</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Char</span>,<span class="built_in">Int64</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  <span class="string">'a'</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="string">'c'</span> =&gt; <span class="number">3</span></span><br><span class="line">  <span class="string">'b'</span> =&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>이것은 튜플을 딕셔너리의 키로 사용하는 일반적인 방법이다. 예를 들어 전화 번호부는 성과 이름 쌍에서 전화 번호로 매핑될 수 있다. 우리가 이름 쌍과 전화 번호를 알고 있다면 아래와 같이 작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directory[last, first] = number</span><br></pre></td></tr></table></figure>
<p>위의 예시에서 대활호 안에 있는 표현식은 튜플이다. 즉, 이 딕셔너리를 순회하기 위해서는 튜플 할당을 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((last, first), number) <span class="keyword">in</span> directory</span><br><span class="line">    println(first, <span class="string">" "</span>, last, <span class="string">" "</span>, number)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>이 루프는 <code>directory</code>에서 튜플인 키-값 페어를 순회한다. 각 튜플의 키 요소를 <code>last</code>와 <code>first</code>에, 값을 숫자에 할당한 다음 이름과 해당 전화번호를 출력한다.</p>
<h3 id="시퀀스의-시퀀스-Sequences-of-Sequences"><a href="#시퀀스의-시퀀스-Sequences-of-Sequences" class="headerlink" title="시퀀스의 시퀀스 (Sequences of Sequences)"></a>시퀀스의 시퀀스 (Sequences of Sequences)</h3><p>지금까지는 튜플 배열(arrays of tuples)에 중점을 두었지만, 이번 장의 모든 예제들은 배열의 배열(arrays of arrays), 튜플의 튜플(tuples of tuples), 배열 튜플(tuples of arrays)에서도 작동한다. 앞과 같이 가능한 조합을 열거하지 않기 위해서 시퀀스의 시퀀스로 이야기 하는 것이 훨씬 편하다.</p>
<p>많은 상황에서 문자열, 배열 및 튜플 등 서로 다른 종류의 시퀀스들을 바꿔서 사용할 수 있다. 만약 바꾼다면 어떤 것을 선택해야 할까?</p>
<p>확실한 것부터 시작하자면, 문자열은 요소들이 문자로 이루어져야 하기 때문에 다른 시퀀스보다 제한적이다. 또한 문자열은 불변이다. 만약 문자열에서 문자를 변경하는 함수가 필요한 경우, 새 문자열을 만드는 것 대신 문자 배열을 사용할 수 있다.</p>
<p>배열은 대부분 변경이 가능하기 때문에 튜플보다는 일반적으로 사용된다. 그러나 튜플이 더 적합한 몇 가지의 경우가 있다.</p>
<ul>
<li>반환 구문과 같은 일부 코드에서는 배열보다 튜플을 만드는 것이 문법 상 더 간단하다.</li>
<li>시퀀스를 함수에 인수로 전달하는 경우 튜플을 사용하면 에일리어싱으로 인한 오류의 가능성이 줄어든다.</li>
<li>성능상의 이유로 컴파일러가 튜플 타입을 전문화할 수 있다.</li>
</ul>
<p>튜플은 변경할 수 없으므로 배열을 수정하는 <code>sort!()</code>나 <code>reverse!()</code>와 같은 함수를 제공하지 않는다. 그러나 줄리아는 배열의 요소들을 가져와 정렬된 상태의 새로운 배열을 반환하는 내장 함수 <code>sort()</code>를 제공하며, 시퀀스를 가져와 역순으로 반환하는 <code>reverse()</code>도 제공한다.</p>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><p>배열, 딕셔너리 그리고 튜플은 데이터 구조의 예이다. 이 장에서는 튜플 배열 또는 튜플을 키로 가진 딕셔너리와 같은 복합 데이터 구조를 보기 시작하였다. 복합 데이터 구조는 유용하지만 형태 오류(shape errors)가 나기 쉽다. 즉, 데이터 구조가 잘못된 데이터 타입이나 크기 또는 구조를 가지는 것이다. 예를 들어 함수는 하나의 정수가 있는 배열을 기대하는데 개발자가 정수 하나만 입력한다면, 그 함수는 작동하지 않는다.</p>
<p>줄리아는 시퀀스의 요소에 데이터 타입을 첨부할 수 있다. 이 작업을 수행하는 방법은 다중 디스패치 파트에서 자세하게 설명할 것이다. 데이터 타입을 지정하면 많은 형태 오류가 제거된다.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%EC%A4%84%EB%A6%AC%EC%95%84/" rel="tag"># 줄리아</a>
              <a href="/tags/Julia/" rel="tag"># Julia</a>
              <a href="/tags/Think-Julia/" rel="tag"># Think Julia</a>
              <a href="/tags/%EA%B8%B0%EC%B4%88-%EA%B0%95%EC%9D%98/" rel="tag"># 기초 강의</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/10/Think-Julia-Chapter-11/" rel="prev" title="10. 딕셔너리">
      <i class="fa fa-chevron-left"></i> 10. 딕셔너리
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/12/Think-Julia-Chapter-13/" rel="next" title="12. 사례 연구 - 데이터 구조 선택">
      12. 사례 연구 - 데이터 구조 선택 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          훑어보기
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#튜플-Tuples"><span class="nav-number">1.</span> <span class="nav-text">튜플 (Tuples)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#튜플은-불변이다"><span class="nav-number">1.1.</span> <span class="nav-text">튜플은 불변이다</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#튜플-할당"><span class="nav-number">1.2.</span> <span class="nav-text">튜플 할당</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#반환-값으로서의-튜플"><span class="nav-number">1.3.</span> <span class="nav-text">반환 값으로서의 튜플</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#가변-인수-튜플-Variable-length-Argument-Tuples"><span class="nav-number">1.4.</span> <span class="nav-text">가변 인수 튜플 (Variable-length Argument Tuples)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#배열과-튜플"><span class="nav-number">1.5.</span> <span class="nav-text">배열과 튜플</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#딕셔너리와-튜플"><span class="nav-number">1.6.</span> <span class="nav-text">딕셔너리와 튜플</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#시퀀스의-시퀀스-Sequences-of-Sequences"><span class="nav-number">1.7.</span> <span class="nav-text">시퀀스의 시퀀스 (Sequences of Sequences)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#디버깅"><span class="nav-number">1.8.</span> <span class="nav-text">디버깅</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hyeonji Ryu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">카테고리</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">111</span>
        <span class="site-state-item-name">태그</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hyeonji Ryu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
