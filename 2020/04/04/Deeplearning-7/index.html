<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://hyeonji-ryu.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.">
<meta property="og:type" content="article">
<meta property="og:title" content="7. 인공신경망 구현 - 순전파 알고리즘">
<meta property="og:url" content="https://hyeonji-ryu.github.io/2020/04/04/Deeplearning-7/index.html">
<meta property="og:site_name" content="DEV AnythinG">
<meta property="og:description" content="해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://hyeonji-ryu.github.io/images/41.png">
<meta property="og:image" content="https://hyeonji-ryu.github.io/images/42.png">
<meta property="og:image" content="https://hyeonji-ryu.github.io/images/46.png">
<meta property="og:image" content="https://hyeonji-ryu.github.io/images/45.png">
<meta property="article:published_time" content="2020-04-03T17:22:48.000Z">
<meta property="article:modified_time" content="2020-06-08T03:40:42.728Z">
<meta property="article:author" content="Hyeonji Ryu">
<meta property="article:tag" content="딥러닝">
<meta property="article:tag" content="Deeplearning">
<meta property="article:tag" content="머신러닝">
<meta property="article:tag" content="줄리아">
<meta property="article:tag" content="신경망">
<meta property="article:tag" content="순전파">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hyeonji-ryu.github.io/images/41.png">

<link rel="canonical" href="https://hyeonji-ryu.github.io/2020/04/04/Deeplearning-7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>7. 인공신경망 구현 - 순전파 알고리즘 | DEV AnythinG</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-163411677-2"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-163411677-2');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DEV AnythinG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Welcome :)</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>홈</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>태그</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>카테고리</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>아카이브</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>검색
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Hyeonji-Ryu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="ko">
    <link itemprop="mainEntityOfPage" href="https://hyeonji-ryu.github.io/2020/04/04/Deeplearning-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hyeonji Ryu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DEV AnythinG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          7. 인공신경망 구현 - 순전파 알고리즘
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-04-04 02:22:48" itemprop="dateCreated datePublished" datetime="2020-04-04T02:22:48+09:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-06-08 12:40:42" itemprop="dateModified" datetime="2020-06-08T12:40:42+09:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-learning-in-Julia/" itemprop="url" rel="index">
                    <span itemprop="name">Deep learning in Julia</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.<br><a id="more"></a></p>
<hr>
<p>이전 글에서 인공신경망을 학습한다는 것이 어떤 의미인지 살펴보았다. 이번에는 인공신경망을 직접 설계하고 학습하여 손글씨 숫자를 분류하는 인공신경망을 만들 것이다. 인공신경망을 설계하는 것은 앞전에 살펴봤던 도식을 만드는 것이다. 은닉층 개수를 정하여 인공신경망의 깊이를 설정하고, 사용되는 활성화 함수들을 정한다. <strong>그 후 인공신경망을 ‘어떻게’ 학습시킬 것인가를 정해야 한다.</strong> 오늘 같이 구현할 ‘순전파’는 경사하강법에서 기울기를 구하는 방법 중 하나이다.</p>
<h2 id="순전파란"><a href="#순전파란" class="headerlink" title="순전파란"></a>순전파란</h2><p>순전파는 기울기를 구하는 과정이 입력값에서 예측값으로 진행되는 것을 의미한다. 즉, 순서대로 이행되는 정직한 미분 알고리즘이다. 우리가 앞서 <a href="https://hyeonji-ryu.github.io/2020/03/31/Deeplearning-4/">경사하강법</a> 파트에서 살펴봤던 미분 방법을 사용한다.</p>
<p>순전파 알고리즘의 편미분 원리는 다음과 같다.</p>
<ol>
<li>편미분 대상(가중치와 편향)에 아주 작은 수(1e-50)를 더해준다.</li>
<li>손실 함수 값인 $f1$을 구한다.</li>
<li>편미분 대상(가중치와 편향)에 아주 작은 수(1e-50)를 빼준다.</li>
<li>손실 함수 값인 $f2$ 구한다.</li>
<li>$\frac{(f1 - f2)}{2h}$를 한다. -&gt; 편미분값 완성</li>
<li>위의 식 결과를 미분값 객체에 저장한다.</li>
</ol>
<p>하지만 순전파 알고리즘은 너무 느리다. 그 이유는 매개 변수인 가중치와 편향을 업데이트한 후 다시 처음부터 신경망을 계산하여 손실함수 값을 갱신하기 때문이다. 다음 글에서는 이를 좀 더 빨리 진행할 수 있는 역전파 알고리즘을 살펴볼 것이다.</p>
<p>아래의 수식은 이전 글에서 우리가 만들었던 인공신경망의 프로세스를 나타낸 것이다.</p>
<script type="math/tex; mode=display">\hat{y}=\sigma(h(XW1+B1)\times W2+B2)</script><p>순전파는 위의 수식에서 합성 함수들 가장 안쪽에 위치한 입력값부터 계산이 진행된다. 즉, 안쪽에서 바깥쪽으로 계산된다고도 볼 수 있다. 도식에서는 왼쪽에서 오른쪽으로 이동하며, 수식에서는 안쪽에서 바깥쪽으로 이동한다.</p>
<h2 id="‘MNIST’-Project"><a href="#‘MNIST’-Project" class="headerlink" title="‘MNIST’ Project"></a>‘MNIST’ Project</h2><p>‘MNIST’는 손글씨로 쓴 숫자를 예측하는 인공신경망을 만드는 프로젝트이다. 해당 프로젝트에 대해 더 알고싶다면 <a href="https://juliaml.github.io/MLDatasets.jl/latest/datasets/MNIST/#MLDatasets.MNIST.testtensor" target="_blank" rel="noopener">이 링크</a>를 참고하면 된다. MNIST는 대부분의 교재에서 사용하는 예시 중 하나이며, 해당 데이터셋이 패키지 안에 준비되어 있다. 먼저 아래의 코드를 입력해서 데이터를 가져오자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import Pkg           # 패키지를 처음 사용할 때 입력해야 한다.</span></span><br><span class="line">Pkg.add(<span class="string">"MNIST"</span>)</span><br><span class="line"><span class="keyword">using</span> MLDatasets</span><br><span class="line">train_x, train_y = MNIST.traindata()</span><br><span class="line">test_x,  test_y  = MNIST.testdata()</span><br></pre></td></tr></table></figure>
<p>해당 데이터의 입력값 <code>train_x</code>는 $28 \times 28$ 이미지 데이터가 60000개 들어 있으며, <code>train_y</code>는 정답 숫자가 $60000 \times 1$ 형태로 들어 있다. 우리는 이를 신경망 모델에 알맞게 전처리해주어야 한다. 특히 <code>train_y</code>는 <code>7</code>이나 <code>8</code>같은 숫자로 들어가 있는데 이를 ‘원-핫 인코딩’형태로 변환해야 한다. 이를 위해 아래의 함수를 먼저 정의하자.</p>
<p><strong>Note</strong><br> 원-핫 인코딩이란?<br> 원-핫 인코딩은 숫자의 형태를 분류하기 위해 사용되는 데이터 형태로 <code>7</code>을 [0,0,0,0,0,0,0,1,0,0]로 변경해준다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    원-핫 인코딩 레이블을 만드는 함수</span></span><br><span class="line"><span class="string">    예를 들어 0~9까지의 숫자 중 3을 원-핫 레이블로 만들면</span></span><br><span class="line"><span class="string">    [0  0  0  1  0  0  0  0  0  0]과 같이 출력할 것이다.</span></span><br><span class="line"><span class="string">    x : 만들려는 숫자</span></span><br><span class="line"><span class="string">    y: 메트릭스의 길이, 주의할 점은 이것은 0부터 시작한다!</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">function</span> making_one_hot_label(x, y)</span><br><span class="line"></span><br><span class="line">    temp = x + <span class="number">1</span></span><br><span class="line">    temp_matrix = zeros(<span class="built_in">Int8</span>, <span class="number">1</span>, y)</span><br><span class="line">    temp_matrix[temp] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span>(temp_matrix)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> making_one_hot_labels(y_train)</span><br><span class="line">    t = making_one_hot_label.(y_train, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> (reduce(vcat, t))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 함수를 사용하면 숫자로 입력된 <code>train_y</code>가 원-핫 레이블로 변경된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 훈련데이터 입력값 전처리</span></span><br><span class="line">train_x = reshape(train_x,<span class="number">784</span>, <span class="number">60000</span>)</span><br><span class="line">train_x = <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>&#125;(train_x)</span><br><span class="line">train_x=train_x'</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실제 실험데이터 입력값 전처리</span></span><br><span class="line">test_x = reshape(test_x,<span class="number">784</span>, <span class="number">10000</span>)</span><br><span class="line">test_x = <span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>&#125;(test_x)</span><br><span class="line">test_x=test_x'</span><br><span class="line"></span><br><span class="line"><span class="comment"># 훈련데이터 정답 레이블 전처리 (원-핫 인코딩)</span></span><br><span class="line">t = making_one_hot_labels(train_y)</span><br><span class="line">typeof(t), size(t)</span><br></pre></td></tr></table></figure>
<p>이제 신경망 모델을 학습하기 위해 필요한 데이터는 모두 준비되었다. 우리가 만들 신경망은 이전 글에서 정리했던 ‘2층 신경망(TwoLayerNet)’이다. 신경망 모델에서는 네트워크에서 가중치와 편향이 계속 업데이트되어야 하기 때문에 딕셔너리로 정의한다. 만약 딕셔너리에 대해서 모르거나 더 알고 싶다면 <a href="https://hyeonji-ryu.github.io/2020/03/10/Think-Julia-Chapter-11/">해당 글</a>을 참고하자. 또한 네트워크가 정확히 무엇인지 궁금하다면 <a href="https://hyeonji-ryu.github.io/2020/04/02/Deeplearning-6/">이전 글</a>을 참고하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params = <span class="built_in">Dict</span>()</span><br><span class="line">grads = <span class="built_in">Dict</span>()</span><br></pre></td></tr></table></figure>
<p>가중치를 할당할 딕셔너리를 정의하였다. <code>params</code>는 기존 매개 변수를 저장하며, <code>grads</code>는 매개 변수의 미분값들을 저장한다. 이제 가중치와 편향의 초기값을 생성하는 함수를 정의하자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> making_network(input_size, hidden_size, output_size, weight_init_std =<span class="number">0.01</span>)</span><br><span class="line">    params[<span class="string">"W1"</span>] = weight_init_std * randn(<span class="built_in">Float64</span>, input_size, hidden_size)</span><br><span class="line">    params[<span class="string">"b1"</span>] = zeros(<span class="built_in">Float32</span>, <span class="number">1</span>, hidden_size)</span><br><span class="line">    params[<span class="string">"W2"</span>] = weight_init_std * randn(<span class="built_in">Float64</span>, hidden_size, output_size)</span><br><span class="line">    params[<span class="string">"b2"</span>] = zeros(<span class="built_in">Float32</span>, <span class="number">1</span>, output_size)</span><br><span class="line">    <span class="keyword">return</span>(params)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 함수는 입력 데이터의 행렬 크기, 은닉층의 행렬 크기, 결과값의 행렬 크기를 받아서 그에 알맞는 가중치와 편향 행렬을 생성해준다. 가중치는 오버피팅을 막기 위해 가장 작게 셋팅하는 것이 좋기 때문에 <code>weight_init_std</code>을 곱해준다. 가중치인 <code>W1</code>, <code>W2</code>는 정규분포를 따라 랜덤 수를 생성해주는 <code>randn()</code>를 사용하였으며, 편향인 <code>b1</code>, <code>b2</code>는 초기값인 크기에 맞게 제로 행렬로 만들어준다. 제로 행렬을 만드는 방법은 <code>zeros()</code>를 사용한다.</p>
<p>우리가 사용하는 데이터는 입력값이 $60000 \times 784$이며, 결과값은 $60000 \times 10$이다. 따라서 <code>W1</code>은 $784 \times 50$이며, <code>W2</code>는 $50 \times 10$이다. <code>b1</code>은 $1 \times 50$이고, <code>b2</code>는 $1 \times 10$이다. 따라서 다음과 같이 함수를 사용하면 알맞은 가중치와 행렬 초기값을 만들 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">making_network(<span class="number">784</span>, <span class="number">50</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>초기값 설정이 끝났다면 이제 신경망을 학습할 차례이다. 학습을 진행하기 전에 필요한 변수들을 미리 세팅해준다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_loss_list = <span class="built_in">Float64</span>[]</span><br><span class="line">accuracy = <span class="built_in">Float64</span>[]</span><br></pre></td></tr></table></figure>
<p><code>train_loss_list</code>는 학습이 진행되는 동안 제공되는 손실 함수의 값을 저장할 리스트이다. 모델의 정확도 또한 <code>accuracy</code>에 저장하여 값이 변화하는 과정을 살펴볼 예정이다.</p>
<p>지금부터는 순전파 기반 경사하강법에 사용되는 함수들을 정의할 것이다. 대부분의 함수들은 우리가 이전 글들에서 살펴봤던 원리와 같으며, 단지 신경망 모델에 맞게 부분적인 수정이 이루어졌다.</p>
<p>먼저 기본적인 활성화 함수를 정의한다. 우리는 이번 신경망 모델에 시그모이드와 소프트맥스를 사용할 예정이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sigmoid(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+exp(-x))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> softmax_single(a)</span><br><span class="line">    c = maximum(a)</span><br><span class="line">    exp.(a .- c) / sum(exp.(a .- c))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 배치 데이터에 사용하는 소프트맥스</span></span><br><span class="line"><span class="keyword">function</span> softmax(a)</span><br><span class="line">    temp = map(softmax_single, eachrow(a))</span><br><span class="line">    <span class="keyword">return</span>(transpose(hcat(temp ...)))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>시그모이드 함수는 그대로 사용하며, 소프트맥스의 경우는 배치 데이터에 사용하는 함수를 따로 생성해준다. 배치 데이터는 각 행이 하나의 이미지이기 때문에 행 하나의 요소 합이 1이어야 한다. 위의 <code>softmax()</code>는 각 행 별로 <code>softmax_single()</code>를 계산하여 배열로 반환한다.</p>
<p><strong>Note</strong><br>배치(batch)란?<br>배치는 모델이 한번에 처리하는 데이터의 개수를 의미한다. 예를 들어 MNIST 데이터를 본다면, 입력데이터 $1 \times 784$는 하나의 이미지이다. 만약 모델에 투입하는 입력데이터가 $100 \times 784$라면 이미지 100개를 한번에 사용한 것이며, 이는 배치 데이터이다.</p>
<p>그 다음 예측값 $\hat{y}$을 반환하는 <code>predict()</code>를 정의한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> predict(x)</span><br><span class="line">    a1 = (x * params[<span class="string">"W1"</span>]) .+ params[<span class="string">"b1"</span>]</span><br><span class="line">    z1 = sigmoid.(a1)</span><br><span class="line">    a2 = (z1 * params[<span class="string">"W2"</span>]) .+ params[<span class="string">"b2"</span>]</span><br><span class="line">    <span class="keyword">return</span> softmax(a2)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>predict()</code>는 <code>params</code>에 있는 초기값 가중치와 편향을 사용하여 계산한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> cross_entropy_error(y,t)</span><br><span class="line">    delta = <span class="number">1e-7</span></span><br><span class="line">    batch_size = length(y[:,<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> (-sum(log.(y.+delta).*t) / batch_size)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loss(x, t)</span><br><span class="line">    y = predict(x)</span><br><span class="line">    <span class="keyword">return</span> cross_entropy_error(y, t)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>loss()</code>는 예측값을 계산하고 손실 함수의 결과까지 도출해주는 함수이며, 손실 함수로는 ‘교차 엔트로피 오차’를 사용하였다. <code>cross_entropy_error()</code>은 배치데이터 손실함수 값의 평균을 제공할 수 있도록 수정하였다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    f는 손실함수, x는 입력값, t는 정답, w는 대상</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">function</span> numerical_gradient(f, x, t, w)</span><br><span class="line">    h=<span class="number">10</span>^-<span class="number">4</span></span><br><span class="line">    vec=zeros(<span class="built_in">Float64</span>,size(w))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>:length(w))</span><br><span class="line">        origin=w[i]</span><br><span class="line">        w[i]+=h</span><br><span class="line">        fx1=f(x,t)</span><br><span class="line">        w[i]-=<span class="number">2</span>*h</span><br><span class="line">        fx2=f(x,t)</span><br><span class="line">        vec[i]=(fx1-fx2)/<span class="number">2</span>h</span><br><span class="line">        w[i]=origin</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span>  vec</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>기존의 <code>numerical_gradient()</code>는 매개 변수로 <code>f()</code>와 미분 대상인 <code>x</code>값만 받았다. 하지만 우리가 적용하려는 <code>loss()</code>는 매개 변수가 <code>x, t</code>로 2개가 들어가기 때문에 이 또한 <code>numerical_gradient()</code>의 매개 변수로 추가하였다. 그 다음 <code>loss()</code>에서 편미분되는 변수가 가중치와 편향이기 때문에 이 또한 매개 변수로 추가하였다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> TwoLayerNet_numerical_gradient(f, x, t)</span><br><span class="line">    grads[<span class="string">"W1"</span>] = numerical_gradient(f, x, t,params[<span class="string">"W1"</span>])</span><br><span class="line">    grads[<span class="string">"W2"</span>] = numerical_gradient(f, x, t,params[<span class="string">"W2"</span>])</span><br><span class="line">    grads[<span class="string">"b1"</span>] = numerical_gradient(f, x, t,params[<span class="string">"b1"</span>])</span><br><span class="line">    grads[<span class="string">"b2"</span>] = numerical_gradient(f, x, t,params[<span class="string">"b2"</span>])</span><br><span class="line">    <span class="keyword">return</span>(grads)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 <code>TwoLayerNet_numerical_gradient()</code>는 가중치와 편향을 모두 편미분하여 <code>grads</code>에 값을 저장한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> SGD(params,grads)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys(params)</span><br><span class="line">        params[key] -= learning_rate * grads[key]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> params</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>SGD()</code>는 ‘확률적 경사하강법’으로 기존 가중치와 편향에서 ‘학습률 $\times$ 편미분값’을 빼서 갱신한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> evaluate(test_x,test_y)</span><br><span class="line">    temp = (sum((argmax.(eachrow(predict(test_x))).-<span class="number">1</span>) .== test_y)/size(test_x)[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> (temp * <span class="number">100</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>마지막으로 정의할 함수 <code>evaluate()</code>는 정확도를 계산한다. 정확도란 실제 실험데이터들을 사용하여 해당 신경망 모델이 얼마나 맞추는지를 확률로 반환한다. 이후 신경망을 직접 학습시키고 정확도를 확인할 것이다.</p>
<p>이제 학습을 진행하기 전에 배치 사이즈와 학습률, 반복 횟수를 지정한다. 보통 학습률은 0.01이나 0.1을 사용한다. 또한 배치 사이즈는 입력 데이터의 형태에 따라 최적화된 크기가 다르지만 이번에는 임의로 배치사이즈를 100으로 지정할 것이다. 그리고 반복 횟수는 100개의 배치데이터 기준으로 1에폭(epoch)인 600을 지정하였다. 에폭이라는 기준에 대해 자세히 알고 싶다면 아래 Note를 확인해보자.</p>
<p><strong>Note</strong><br>에폭이란?<br>에폭(epoch)은 훈련데이터 전체의 개수를 의미한다. MNIST 데이터를 예시로 본다면 훈련데이터는 60000개이다. 배치 사이즈가 100인 경우 한번에 100개의 훈련데이터가 사용되므로 모델에 1에폭을 훈련시키려면 600번을 반복해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_size = size(train_x)[<span class="number">1</span>]</span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">learning_rate = <span class="number">0.1</span></span><br><span class="line">iters_num = <span class="number">600</span></span><br></pre></td></tr></table></figure>
<p>이제 모든 준비가 완료되었다. 아래의 코드를 입력하여 학습을 실행해보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@time</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:iters_num</span><br><span class="line">        batch_mask = rand(<span class="number">1</span>:train_size, <span class="number">100</span>)</span><br><span class="line">        x_batch = train_x[batch_mask, :]</span><br><span class="line">        t_batch = t[batch_mask, :]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 편미분값 구하기</span></span><br><span class="line">        TwoLayerNet_numerical_gradient(loss, x_batch, t_batch)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 확률적 경사하강법</span></span><br><span class="line">        SGD(params, grads)</span><br><span class="line"></span><br><span class="line">        temp_loss = loss(x_batch, t_batch)</span><br><span class="line">        print(<span class="string">"NO.<span class="variable">$i</span>: "</span>)</span><br><span class="line">        println(temp_loss)</span><br><span class="line">        append!(train_loss_list, temp_loss)</span><br><span class="line">        append!(accuracy, evaluate(test_x, test_y))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 순전파 기반 경사하강법을 구현한 것이다. 프로세스는 다음과 같다.</p>
<ul>
<li><p>먼저 입력 데이터 60000개 중에 100개를 무작위로 뽑아서 배치 데이터셋을 생성한다.</p>
</li>
<li><p>그 다음 가중치와 편향을 편미분한다.(순전파) <code>grads</code>에 가중치와 편향의 편미분 값들을 저장한다.</p>
</li>
<li><p>기존 신경망인 <code>params</code>의 가중치와 편향에서 ‘학습률 $\times$ 편미분값’을 빼서 갱신한다. (SGD)</p>
</li>
<li><p>갱신한 가중치와 편향으로 다시 손실 함수의 값을 구한 후 <code>train_loss_list</code>에 추가한다.</p>
</li>
<li><p>해당 모델을 사용하여 실제 실험데이터를 얼마나 맞추는지 확률을 계산하고, <code>accuracy</code>에 추가한다.</p>
</li>
<li><p><code>iters_num</code>만큼 위의 프로세스를 반복한다.</p>
</li>
</ul>
<p>편미분을 진행하는 파트에서 순전파는 역전파보다 시간이 매우 많이 소요된다. 따라서 비교적 시간이 여유로울 때 코드를 진행하기를 추천한다.</p>
<p>위의 학습 결과는 다음과 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NO<span class="number">.1</span>: <span class="number">2.292942018493531</span></span><br><span class="line">NO<span class="number">.2</span>: <span class="number">2.288184723441353</span></span><br><span class="line">NO<span class="number">.3</span>: <span class="number">2.2987287770939293</span></span><br><span class="line">NO<span class="number">.4</span>: <span class="number">2.3000466383158993</span></span><br><span class="line">NO<span class="number">.5</span>: <span class="number">2.2887273179016963</span></span><br><span class="line">NO<span class="number">.6</span>: <span class="number">2.2926579888410235</span></span><br><span class="line">NO<span class="number">.7</span>: <span class="number">2.29624786295159</span></span><br><span class="line">NO<span class="number">.8</span>: <span class="number">2.2953948065780376</span></span><br><span class="line">NO<span class="number">.9</span>: <span class="number">2.2990271264453774</span></span><br><span class="line">NO<span class="number">.10</span>: <span class="number">2.2735668193617418</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">NO<span class="number">.590</span>: <span class="number">0.9584272233933265</span></span><br><span class="line">NO<span class="number">.591</span>: <span class="number">0.8445645939069023</span></span><br><span class="line">NO<span class="number">.592</span>: <span class="number">0.9125098806007815</span></span><br><span class="line">NO<span class="number">.593</span>: <span class="number">0.8713494631790804</span></span><br><span class="line">NO<span class="number">.594</span>: <span class="number">0.8839853719315479</span></span><br><span class="line">NO<span class="number">.595</span>: <span class="number">0.88424914270352</span></span><br><span class="line">NO<span class="number">.596</span>: <span class="number">0.8817506678094389</span></span><br><span class="line">NO<span class="number">.597</span>: <span class="number">0.9543049814512449</span></span><br><span class="line">NO<span class="number">.598</span>: <span class="number">0.867151437734806</span></span><br><span class="line">NO<span class="number">.599</span>: <span class="number">0.9474920771844572</span></span><br><span class="line">NO<span class="number">.600</span>: <span class="number">0.8690392628614342</span></span><br><span class="line"><span class="number">17654.229691</span> seconds (<span class="number">20.70</span> G allocations: <span class="number">9.067</span> TiB, <span class="number">6.94</span>% gc time)</span><br></pre></td></tr></table></figure>
<p>100 단위의 배치 데이터를 600번 반복한 결과, 처음 2.29였던 손실 함수 값이 0.86까지 떨어졌다. 이는 오답률이 많이 감소되었다는 것을 의미한다. 시간은 대략 17600초가 걸렸으며, 환산해보면 약 5시간 정도 소요되었다.</p>
<p>위의 학습 과정에서 저장했던 <code>train_loss_list</code>와 <code>accuracy</code>를 그래프로 나타내보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Plots</span><br><span class="line">x = range(<span class="number">1</span>,length(train_loss_list),step=<span class="number">1</span>)</span><br><span class="line">y = train_loss_list</span><br></pre></td></tr></table></figure>
<p><img src="\../images/41.png" alt="손실 함수 그래프"></p>
<p>저장된 손실 함수 값을 그래프로 그려본 결과, 지속적으로 감소하는 양상을 확인할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = range(<span class="number">1</span>,length(accuracy),step=<span class="number">1</span>)</span><br><span class="line">y = accuracy</span><br><span class="line"></span><br><span class="line">plot(x,y)</span><br></pre></td></tr></table></figure>
<p><img src="\../images/42.png" alt="정확도 그래프"></p>
<p>저장된 정확도 또한 계속 상승하는 것을 볼 수 있다. 가장 높은 정확도는 아래의 코드를 통해 확인하자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">argmax(accuracy)   <span class="comment"># 최대값 인덱스 반환</span></span><br><span class="line"><span class="number">598</span></span><br><span class="line">accuracy[<span class="number">598</span>]</span><br><span class="line"><span class="number">80.15</span></span><br></pre></td></tr></table></figure>
<p>정확도는 80%를 웃돈다. 여기서 추가로 더 학습하면 정확도는 90%도 넘을 수 있다.</p>
<p>위의 코드를 돌려보면 알겠지만 순전파는 매우 느리다. 아마 1에폭을 돌리면 더이상 학습을 진행하고 싶지 않을 것이다. 하지만 학습을 더 진행하고 싶진 않지만 90%가 넘는지 확인하고 싶은 이들을 위해 순전파로 3에폭을 돌려보았다. 결과는 다음과 같다.</p>
<p><img src="\../images/46.png" alt="손실 함수 그래프"></p>
<p>손실 함수 그래프이다. 손실 함수의 값이 0.5 아래로 떨어진 것을 확인할 수 있다.</p>
<p><img src="\../images/45.png" alt="정확도 그래프"></p>
<p>정확도는 80%를 훨씬 넘었다. 가장 높은 정확도를 확인하기 위해 아래의 코드를 입력해보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">argmax(accuracy)   <span class="comment"># 최대값 인덱스 반환</span></span><br><span class="line"><span class="number">1709</span></span><br><span class="line">accuracy[<span class="number">1709</span>]</span><br><span class="line"><span class="number">90.16999999999999</span></span><br></pre></td></tr></table></figure>
<p>정확도가 90%가 넘은 것을 확인할 수 있다.</p>
<p>순전파는 반복되는 매 횟수마다 활성화 함수를 미분하기 때문에 시간이 오래 걸린다. 그렇기에 실상 사용되는 미분법은 아니지만, 신경망의 원리를 파악하기 위해서는 알아야 한다. 다음 글에서는 5시간을 3분으로 줄여주는 마법같은 역전파를 살펴볼 것이다.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/" rel="tag"># 딥러닝</a>
              <a href="/tags/Deeplearning/" rel="tag"># Deeplearning</a>
              <a href="/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/" rel="tag"># 머신러닝</a>
              <a href="/tags/%EC%A4%84%EB%A6%AC%EC%95%84/" rel="tag"># 줄리아</a>
              <a href="/tags/%EC%8B%A0%EA%B2%BD%EB%A7%9D/" rel="tag"># 신경망</a>
              <a href="/tags/%EC%88%9C%EC%A0%84%ED%8C%8C/" rel="tag"># 순전파</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/02/Deeplearning-6/" rel="prev" title="6. 인공신경망 구현 - 모델 학습">
      <i class="fa fa-chevron-left"></i> 6. 인공신경망 구현 - 모델 학습
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/12/mathematic-1/" rel="next" title="1. Linear Algebra (1)">
      1. Linear Algebra (1) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          훑어보기
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#순전파란"><span class="nav-number">1.</span> <span class="nav-text">순전파란</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#‘MNIST’-Project"><span class="nav-number">2.</span> <span class="nav-text">‘MNIST’ Project</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hyeonji Ryu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">카테고리</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">167</span>
        <span class="site-state-item-name">태그</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hyeonji Ryu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
